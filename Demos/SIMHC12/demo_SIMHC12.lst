                                      ;###############################################################################
                                      ;# S12CBase - Demo (SIMHC12)                                                   #
                                      ;###############################################################################
                                      ;#    Copyright 2010-2012 Dirk Heisswolf                                       #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    This demo application transmits each byte it receives via the SCI.       #
                                      ;#                                                                             #
                                      ;# Usage:                                                                      #
                                      ;#    1. Upload S-Record                                                       #
                                      ;#    2. Execute code at address "START_OF_CODE"                               #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    November 14, 2012                                                        #
                                      ;#      - Initial release                                                      #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Configuration                                                               #
                                      ;###############################################################################
                                      ;# Clocks
??????        -> $0001                CLOCK_CRG               EQU     1               ;CPMU
??????        -> $989680              CLOCK_OSC_FREQ          EQU     10000000        ;10 MHz
??????        -> $2FAF080             CLOCK_BUS_FREQ          EQU     50000000        ;50 MHz
??????        -> $989680              CLOCK_REF_FREQ          EQU     10000000        ;10 MHz
??????        -> $0003                CLOCK_VCOFRQ            EQU     3               ;VCO=100MHz
??????        -> $0002                CLOCK_REFFRQ            EQU     2               ;Ref=10Mhz
                                      ;# Memory map:
??????        -> $0001                MMAP_RAM                EQU     1               ;use RAM memory map
                                      ;# Interrupt stack
??????        -> $0001                ISTACK_LEVELS           EQU     1               ;interrupt nesting not guaranteed
                                      ;ISTACK_DEBUG           EQU     1               ;don't enter wait mode
??????        -> $0001                ISTACK_S12X             EQU     1               ;S12X interrupt handling
                                      ;# Subroutine stack
??????        -> $001B                SSTACK_DEPTH            EQU     27              ;no interrupt nesting
                                      ;SSTACK_DEBUG           EQU     1               ;debug behavior
                                      ;# RESET
??????        -> $0001                RESET_CLKFAIL_OFF       EQU     1               ;no clock monitor reset
??????        -> $F822                RESET_WELCOME           EQU     DEMO_WELCOME    ;welcome message
                                      ;# Vector table
                                      ;VECTAB_DEBUG           EQU     1               ;multiple dummy ISRs
                                      ;# SCI
??????        -> $0001                SCI_FC_NONE             EQU     1               ;no flow control
??????        -> $0001                SCI_HANDLE_BREAK        EQU     1               ;react to BREAK symbol
??????        -> $0001                SCI_HANDLE_SUSPEND      EQU     1               ;react to SUSPEND symbol
??????        -> $0001                SCI_BD_OFF              EQU     1               ;no baud rate detection
??????        -> $0001                SCI_ERRSIG_OFF          EQU     1               ;don't signal errors
??????        -> $0001                SCI_BLOCKING_ON         EQU     1               ;enable blocking subroutines
                                      ;###############################################################################
                                      ;# Resource mapping                                                            #
                                      ;###############################################################################
000800 0F4800                                                 ORG     MMAP_RAM_START
                                      ;Variables
000800 0F4800 -> $0800                DEMO_VARS_START         EQU     *
000800 0F4800 -> $F4800               DEMO_VARS_START_LIN     EQU     @
000800 0F4800 -> $0800                BASE_VARS_START         EQU     DEMO_VARS_END
000800 0F4800 -> $F4800               BASE_VARS_START_LIN     EQU     DEMO_VARS_END_LIN
00F000 0FF000                                                 ORG     MMAP_EEPROM_START
                                      ;Code
00F000 0FF000 -> $F000                START_OF_CODE           EQU     *
00F000 0FF000 -> $F000                DEMO_CODE_START         EQU     *
00F000 0FF000 -> $FF000               DEMO_CODE_START_LIN     EQU     @
00F000 0FF000 -> $F349                BASE_CODE_START         EQU     DEMO_CODE_END
00F000 0FF000 -> $FF349               BASE_CODE_START_LIN     EQU     DEMO_CODE_END_LIN
                                      ;Tables
00F000 0FF000 -> $F822                DEMO_TABS_START         EQU     BASE_CODE_END
00F000 0FF000 -> $FF822               DEMO_TABS_START_LIN     EQU     BASE_CODE_END_LIN
00F000 0FF000 -> $F89A                BASE_TABS_START         EQU     DEMO_TABS_END
00F000 0FF000 -> $FF89A               BASE_TABS_START_LIN     EQU     DEMO_TABS_END_LIN
                                      ;###############################################################################
                                      ;# S12CBase - Base Bundle (SIMHC12)                                            #
                                      ;###############################################################################
                                      ;#    Copyright 2010-2012 Dirk Heisswolf                                       #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    This module bundles all standard S12CBase modules into one.              #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    November 20, 2012                                                        #
                                      ;#      - Initial release                                                      #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Configuration                                                               #
                                      ;###############################################################################
                                      ;# Clocks
                                      ;# COP
00F000 0FF000 -> $0001                COP_DEBUG               EQU     1               ;disable COP
                                      ;# RESET
00F000 0FF000 -> $0001                RESET_COP_OFF           EQU     1               ;no COP reset
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000800 0F4800                                                 ORG     BASE_VARS_START, BASE_VARS_START_LIN
000800 0F4800 -> $0800                GPIO_VARS_START         EQU     *
000800 0F4800 -> $F4800               GPIO_VARS_START_LIN     EQU     @
000800 0F4800 -> $0800                MMAP_VARS_START         EQU     GPIO_VARS_END
000800 0F4800 -> $F4800               MMAP_VARS_START_LIN     EQU     GPIO_VARS_END_LIN
000800 0F4800 -> $0800                SSTACK_VARS_START       EQU     MMAP_VARS_END
000800 0F4800 -> $F4800               SSTACK_VARS_START_LIN   EQU     MMAP_VARS_END_LIN
000800 0F4800 -> $0800                ISTACK_VARS_START       EQU     SSTACK_VARS_END
000800 0F4800 -> $F4800               ISTACK_VARS_START_LIN   EQU     SSTACK_VARS_END_LIN
000800 0F4800 -> $0825                TIM_VARS_START          EQU     ISTACK_VARS_END
000800 0F4800 -> $F4825               TIM_VARS_START_LIN      EQU     ISTACK_VARS_END_LIN
000800 0F4800 -> $0825                SCI_VARS_START          EQU     TIM_VARS_END
000800 0F4800 -> $F4825               SCI_VARS_START_LIN      EQU     TIM_VARS_END_LIN
000800 0F4800 -> $0855                STRING_VARS_START       EQU     SCI_VARS_END
000800 0F4800 -> $F4855               STRING_VARS_START_LIN   EQU     SCI_VARS_END_LIN
000800 0F4800 -> $0855                RESET_VARS_START        EQU     STRING_VARS_END
000800 0F4800 -> $F4855               RESET_VARS_START_LIN    EQU     STRING_VARS_END_LIN
000800 0F4800 -> $0859                NUM_VARS_START          EQU     RESET_VARS_END
000800 0F4800 -> $F4859               NUM_VARS_START_LIN      EQU     RESET_VARS_END_LIN
000800 0F4800 -> $0859                NVM_VARS_START          EQU     NUM_VARS_END
000800 0F4800 -> $F4859               NVM_VARS_START_LIN      EQU     NUM_VARS_END_LIN
000800 0F4800 -> $0859                VECTAB_VARS_START       EQU     NVM_VARS_END
000800 0F4800 -> $F4859               VECTAB_VARS_START_LIN   EQU     NVM_VARS_END_LIN
000800 0F4800 -> $0859                BASE_VARS_END           EQU     VECTAB_VARS_START
000800 0F4800 -> $F4859               BASE_VARS_END_LIN       EQU     VECTAB_VARS_START_LIN
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F349 0FF349                                                 ORG     BASE_CODE_START, BASE_CODE_START_LIN
00F349 0FF349 -> $F349                GPIO_CODE_START         EQU     *
00F349 0FF349 -> $FF349               GPIO_CODE_START_LIN     EQU     @
00F349 0FF349 -> $F349                MMAP_CODE_START         EQU     GPIO_CODE_END
00F349 0FF349 -> $FF349               MMAP_CODE_START_LIN     EQU     GPIO_CODE_END_LIN
00F349 0FF349 -> $F349                SSTACK_CODE_START       EQU     MMAP_CODE_END
00F349 0FF349 -> $FF349               SSTACK_CODE_START_LIN   EQU     MMAP_CODE_END_LIN
00F349 0FF349 -> $F355                ISTACK_CODE_START       EQU     SSTACK_CODE_END
00F349 0FF349 -> $FF355               ISTACK_CODE_START_LIN   EQU     SSTACK_CODE_END_LIN
00F349 0FF349 -> $F361                TIM_CODE_START          EQU     ISTACK_CODE_END
00F349 0FF349 -> $FF361               TIM_CODE_START_LIN      EQU     ISTACK_CODE_END_LIN
00F349 0FF349 -> $F361                SCI_CODE_START          EQU     TIM_CODE_END
00F349 0FF349 -> $FF361               SCI_CODE_START_LIN      EQU     TIM_CODE_END_LIN
00F349 0FF349 -> $F672                STRING_CODE_START       EQU     SCI_CODE_END
00F349 0FF349 -> $FF672               STRING_CODE_START_LIN   EQU     SCI_CODE_END_LIN
00F349 0FF349 -> $F6D6                RESET_CODE_START        EQU     STRING_CODE_END
00F349 0FF349 -> $FF6D6               RESET_CODE_START_LIN    EQU     STRING_CODE_END_LIN
00F349 0FF349 -> $F722                NUM_CODE_START          EQU     RESET_CODE_END
00F349 0FF349 -> $FF722               NUM_CODE_START_LIN      EQU     RESET_CODE_END_LIN
00F349 0FF349 -> $F822                NVM_CODE_START          EQU     NUM_CODE_END
00F349 0FF349 -> $FF822               NVM_CODE_START_LIN      EQU     NUM_CODE_END_LIN
00F349 0FF349 -> $F822                VECTAB_CODE_START       EQU     NVM_CODE_END
00F349 0FF349 -> $FF822               VECTAB_CODE_START_LIN   EQU     NVM_CODE_END_LIN
00F349 0FF349 -> $F822                BASE_CODE_END           EQU     VECTAB_CODE_START
00F349 0FF349 -> $FF822               BASE_CODE_END_LIN       EQU     VECTAB_CODE_START_LIN
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F89A 0FF89A                                                 ORG     BASE_TABS_START, BASE_TABS_START_LIN
00F89A 0FF89A -> $F89A                GPIO_TABS_START         EQU     *
00F89A 0FF89A -> $FF89A               GPIO_TABS_START_LIN     EQU     @
00F89A 0FF89A -> $F89A                MMAP_TABS_START         EQU     GPIO_TABS_END
00F89A 0FF89A -> $FF89A               MMAP_TABS_START_LIN     EQU     GPIO_TABS_END_LIN
00F89A 0FF89A -> $F89A                SSTACK_TABS_START       EQU     MMAP_TABS_END
00F89A 0FF89A -> $FF89A               SSTACK_TABS_START_LIN   EQU     MMAP_TABS_END_LIN
00F89A 0FF89A -> $F8CD                ISTACK_TABS_START       EQU     SSTACK_TABS_END
00F89A 0FF89A -> $FF8CD               ISTACK_TABS_START_LIN   EQU     SSTACK_TABS_END_LIN
00F89A 0FF89A -> $F8FE                TIM_TABS_START          EQU     ISTACK_TABS_END
00F89A 0FF89A -> $FF8FE               TIM_TABS_START_LIN      EQU     ISTACK_TABS_END_LIN
00F89A 0FF89A -> $F8FE                SCI_TABS_START          EQU     TIM_TABS_END
00F89A 0FF89A -> $FF8FE               SCI_TABS_START_LIN      EQU     TIM_TABS_END_LIN
00F89A 0FF89A -> $F90E                STRING_TABS_START       EQU     SCI_TABS_END
00F89A 0FF89A -> $FF90E               STRING_TABS_START_LIN   EQU     SCI_TABS_END_LIN
00F89A 0FF89A -> $F911                RESET_TABS_START        EQU     STRING_TABS_END
00F89A 0FF89A -> $FF911               RESET_TABS_START_LIN    EQU     STRING_TABS_END_LIN
00F89A 0FF89A -> $F933                NUM_TABS_START          EQU     RESET_TABS_END
00F89A 0FF89A -> $FF933               NUM_TABS_START_LIN      EQU     RESET_TABS_END_LIN
00F89A 0FF89A -> $F944                NVM_TABS_START          EQU     NUM_TABS_END
00F89A 0FF89A -> $FF944               NVM_TABS_START_LIN      EQU     NUM_TABS_END_LIN
00F89A 0FF89A -> $F944                VECTAB_TABS_START       EQU     NVM_TABS_END
00F89A 0FF89A -> $FF944               VECTAB_TABS_START_LIN   EQU     NVM_TABS_END_LIN
00F89A 0FF89A -> $F944                BASE_TABS_END           EQU     VECTAB_TABS_START
00F89A 0FF89A -> $FF944               BASE_TABS_END_LIN       EQU     VECTAB_TABS_START_LIN
                                      ;###############################################################################
                                      ;# S12CBase - REGDEF - Register Definitions (SIMHC12)                          #
                                      ;###############################################################################
                                      ;#    Copyright 2010 - 2012 Dirk Heisswolf                                     #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12(X) MCU   #
                                      ;#    families.                                                                #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#   This module defines the register map of the 68HC12A4.                     #
                                      ;#   This version of REGDEF contains modifications to run on the SIM68HC12     #
                                      ;#   simulator.                                                                #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    - none                                                                   #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - none                                                                   #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    Apr 1, 2010                                                              #
                                      ;#      - Initial release                                                      #
                                      ;###############################################################################
                                      ;#################################
                                      ;# 68HC12A4 Register Definitions #
                                      ;#################################
00F89A 0FF89A -> $0000                PORTA           EQU     $0000
00F89A 0FF89A -> $0080                PTA7            EQU     $80
00F89A 0FF89A -> $0040                PTA6            EQU     $40
00F89A 0FF89A -> $0020                PTA5            EQU     $20
00F89A 0FF89A -> $0010                PTA4            EQU     $10
00F89A 0FF89A -> $0008                PTA3            EQU     $08
00F89A 0FF89A -> $0004                PTA2            EQU     $04
00F89A 0FF89A -> $0002                PTA1            EQU     $02
00F89A 0FF89A -> $0001                PTA0            EQU     $01
00F89A 0FF89A -> $0080                PA7             EQU     $80
00F89A 0FF89A -> $0040                PA6             EQU     $40
00F89A 0FF89A -> $0020                PA5             EQU     $20
00F89A 0FF89A -> $0010                PA4             EQU     $10
00F89A 0FF89A -> $0008                PA3             EQU     $08
00F89A 0FF89A -> $0004                PA2             EQU     $04
00F89A 0FF89A -> $0002                PA1             EQU     $02
00F89A 0FF89A -> $0001                PA0             EQU     $01
00F89A 0FF89A -> $0001                PORTB           EQU     $0001
00F89A 0FF89A -> $0080                PTB7            EQU     $80
00F89A 0FF89A -> $0040                PTB6            EQU     $40
00F89A 0FF89A -> $0020                PTB5            EQU     $20
00F89A 0FF89A -> $0010                PTB4            EQU     $10
00F89A 0FF89A -> $0008                PTB3            EQU     $08
00F89A 0FF89A -> $0004                PTB2            EQU     $04
00F89A 0FF89A -> $0002                PTB1            EQU     $02
00F89A 0FF89A -> $0001                PTB0            EQU     $01
00F89A 0FF89A -> $0080                PB7             EQU     $80
00F89A 0FF89A -> $0040                PB6             EQU     $40
00F89A 0FF89A -> $0020                PB5             EQU     $20
00F89A 0FF89A -> $0010                PB4             EQU     $10
00F89A 0FF89A -> $0008                PB3             EQU     $08
00F89A 0FF89A -> $0004                PB2             EQU     $04
00F89A 0FF89A -> $0002                PB1             EQU     $02
00F89A 0FF89A -> $0001                PB0             EQU     $01
00F89A 0FF89A -> $0002                DDRA            EQU     $0002
00F89A 0FF89A -> $0080                DDRA7           EQU     $80
00F89A 0FF89A -> $0040                DDRA6           EQU     $40
00F89A 0FF89A -> $0020                DDRA5           EQU     $20
00F89A 0FF89A -> $0010                DDRA4           EQU     $10
00F89A 0FF89A -> $0008                DDRA3           EQU     $08
00F89A 0FF89A -> $0004                DDRA2           EQU     $04
00F89A 0FF89A -> $0002                DDRA1           EQU     $02
00F89A 0FF89A -> $0001                DDRA0           EQU     $01
00F89A 0FF89A -> $0003                DDRB            EQU     $0003
00F89A 0FF89A -> $0080                DDRB7           EQU     $80
00F89A 0FF89A -> $0040                DDRB6           EQU     $40
00F89A 0FF89A -> $0020                DDRB5           EQU     $20
00F89A 0FF89A -> $0010                DDRB4           EQU     $10
00F89A 0FF89A -> $0008                DDRB3           EQU     $08
00F89A 0FF89A -> $0004                DDRB2           EQU     $04
00F89A 0FF89A -> $0002                DDRB1           EQU     $02
00F89A 0FF89A -> $0001                DDRB0           EQU     $01
00F89A 0FF89A -> $0004                PORTC           EQU     $0004
00F89A 0FF89A -> $0080                PTC7            EQU     $80
00F89A 0FF89A -> $0040                PTC6            EQU     $40
00F89A 0FF89A -> $0020                PTC5            EQU     $20
00F89A 0FF89A -> $0010                PTC4            EQU     $10
00F89A 0FF89A -> $0008                PTC3            EQU     $08
00F89A 0FF89A -> $0004                PTC2            EQU     $04
00F89A 0FF89A -> $0002                PTC1            EQU     $02
00F89A 0FF89A -> $0001                PTC0            EQU     $01
00F89A 0FF89A -> $0080                PC7             EQU     $80
00F89A 0FF89A -> $0040                PC6             EQU     $40
00F89A 0FF89A -> $0020                PC5             EQU     $20
00F89A 0FF89A -> $0010                PC4             EQU     $10
00F89A 0FF89A -> $0008                PC3             EQU     $08
00F89A 0FF89A -> $0004                PC2             EQU     $04
00F89A 0FF89A -> $0002                PC1             EQU     $02
00F89A 0FF89A -> $0001                PC0             EQU     $01
00F89A 0FF89A -> $0005                PORTD           EQU     $0005
00F89A 0FF89A -> $0080                PTD7            EQU     $80
00F89A 0FF89A -> $0040                PTD6            EQU     $40
00F89A 0FF89A -> $0020                PTD5            EQU     $20
00F89A 0FF89A -> $0010                PTD4            EQU     $10
00F89A 0FF89A -> $0008                PTD3            EQU     $08
00F89A 0FF89A -> $0004                PTD2            EQU     $04
00F89A 0FF89A -> $0002                PTD1            EQU     $02
00F89A 0FF89A -> $0001                PTD0            EQU     $01
00F89A 0FF89A -> $0080                PD7             EQU     $80
00F89A 0FF89A -> $0040                PD6             EQU     $40
00F89A 0FF89A -> $0020                PD5             EQU     $20
00F89A 0FF89A -> $0010                PD4             EQU     $10
00F89A 0FF89A -> $0008                PD3             EQU     $08
00F89A 0FF89A -> $0004                PD2             EQU     $04
00F89A 0FF89A -> $0002                PD1             EQU     $02
00F89A 0FF89A -> $0001                PD0             EQU     $01
00F89A 0FF89A -> $0006                DDRC            EQU     $0006
00F89A 0FF89A -> $0080                DDRC7           EQU     $80
00F89A 0FF89A -> $0040                DDRC6           EQU     $40
00F89A 0FF89A -> $0020                DDRC5           EQU     $20
00F89A 0FF89A -> $0010                DDRC4           EQU     $10
00F89A 0FF89A -> $0008                DDRC3           EQU     $08
00F89A 0FF89A -> $0004                DDRC2           EQU     $04
00F89A 0FF89A -> $0002                DDRC1           EQU     $02
00F89A 0FF89A -> $0001                DDRC0           EQU     $01
00F89A 0FF89A -> $0007                DDRD            EQU     $0007
00F89A 0FF89A -> $0080                DDRD7           EQU     $80
00F89A 0FF89A -> $0040                DDRD6           EQU     $40
00F89A 0FF89A -> $0020                DDRD5           EQU     $20
00F89A 0FF89A -> $0010                DDRD4           EQU     $10
00F89A 0FF89A -> $0008                DDRD3           EQU     $08
00F89A 0FF89A -> $0004                DDRD2           EQU     $04
00F89A 0FF89A -> $0002                DDRD1           EQU     $02
00F89A 0FF89A -> $0001                DDRD0           EQU     $01
00F89A 0FF89A -> $0008                PORTE           EQU     $0008
00F89A 0FF89A -> $0080                PTE7            EQU     $80
00F89A 0FF89A -> $0040                PTE6            EQU     $40
00F89A 0FF89A -> $0020                PTE5            EQU     $20
00F89A 0FF89A -> $0010                PTE4            EQU     $10
00F89A 0FF89A -> $0008                PTE3            EQU     $08
00F89A 0FF89A -> $0004                PTE2            EQU     $04
00F89A 0FF89A -> $0002                PTE1            EQU     $02
00F89A 0FF89A -> $0001                PTE0            EQU     $01
00F89A 0FF89A -> $0080                PE7             EQU     $80
00F89A 0FF89A -> $0040                PE6             EQU     $40
00F89A 0FF89A -> $0020                PE5             EQU     $20
00F89A 0FF89A -> $0010                PE4             EQU     $10
00F89A 0FF89A -> $0008                PE3             EQU     $08
00F89A 0FF89A -> $0004                PE2             EQU     $04
00F89A 0FF89A -> $0002                PE1             EQU     $02
00F89A 0FF89A -> $0001                PE0             EQU     $01
00F89A 0FF89A -> $0009                DDRE            EQU     $0009
00F89A 0FF89A -> $0080                DDRE7           EQU     $80
00F89A 0FF89A -> $0040                DDRE6           EQU     $40
00F89A 0FF89A -> $0020                DDRE5           EQU     $20
00F89A 0FF89A -> $0010                DDRE4           EQU     $10
00F89A 0FF89A -> $0008                DDRE3           EQU     $08
00F89A 0FF89A -> $0004                DDRE2           EQU     $04
00F89A 0FF89A -> $0002                DDRE1           EQU     $02
00F89A 0FF89A -> $0001                DDRE0           EQU     $01
00F89A 0FF89A -> $000A                PEAR            EQU     $000A
00F89A 0FF89A -> $0080                ARSIE           EQU     $80
00F89A 0FF89A -> $0040                PLLTE           EQU     $40
00F89A 0FF89A -> $0020                PIPOE           EQU     $20
00F89A 0FF89A -> $0010                NECLK           EQU     $10
00F89A 0FF89A -> $0008                LSTRE           EQU     $08
00F89A 0FF89A -> $0004                RDWE            EQU     $04
00F89A 0FF89A -> $000B                MODE            EQU     $000B
00F89A 0FF89A -> $0080                SMODN           EQU     $80
00F89A 0FF89A -> $0040                MODB            EQU     $40
00F89A 0FF89A -> $0020                MODA            EQU     $20
00F89A 0FF89A -> $0010                ESTRA           EQU     $10
00F89A 0FF89A -> $0008                IVIS            EQU     $08
00F89A 0FF89A -> $0002                EMD             EQU     $02
00F89A 0FF89A -> $0001                EME             EQU     $01
00F89A 0FF89A -> $000C                PUCR            EQU     $000C
00F89A 0FF89A -> $0080                PUPH            EQU     $80
00F89A 0FF89A -> $0040                PUPG            EQU     $40
00F89A 0FF89A -> $0020                PUPF            EQU     $20
00F89A 0FF89A -> $0010                PUPE            EQU     $10
00F89A 0FF89A -> $0008                PUPD            EQU     $08
00F89A 0FF89A -> $0004                PUPC            EQU     $04
00F89A 0FF89A -> $0002                PUPB            EQU     $02
00F89A 0FF89A -> $0001                PUPA            EQU     $01
00F89A 0FF89A -> $000D                RDRIV           EQU     $000D
00F89A 0FF89A -> $0080                RDPJ            EQU     $80
00F89A 0FF89A -> $0040                RDPH            EQU     $40
00F89A 0FF89A -> $0020                RDPG            EQU     $20
00F89A 0FF89A -> $0010                RDPF            EQU     $10
00F89A 0FF89A -> $0008                RDPE            EQU     $08
00F89A 0FF89A -> $0004                RDPD            EQU     $04
00F89A 0FF89A -> $0002                RDPC            EQU     $02
00F89A 0FF89A -> $0001                RDPAB           EQU     $01
00F89A 0FF89A -> $000E                EBICTL          EQU     $000E
00F89A 0FF89A -> $0001                ESTR            EQU     $01
                                      ;$000E - $000F reserved
00F89A 0FF89A -> $0010                INITRM          EQU     $0010
00F89A 0FF89A -> $0080                RAM15           EQU     $80
00F89A 0FF89A -> $0040                RAM14           EQU     $40
00F89A 0FF89A -> $0020                RAM13           EQU     $20
00F89A 0FF89A -> $0010                RAM12           EQU     $10
00F89A 0FF89A -> $0008                RAM11           EQU     $08
00F89A 0FF89A -> $0011                INITRG          EQU     $0011
00F89A 0FF89A -> $0040                REG14           EQU     $40
00F89A 0FF89A -> $0020                REG13           EQU     $20
00F89A 0FF89A -> $0010                REG12           EQU     $10
00F89A 0FF89A -> $0008                REG11           EQU     $08
00F89A 0FF89A -> $0012                INITEE          EQU     $0012
00F89A 0FF89A -> $0080                EE15            EQU     $80
00F89A 0FF89A -> $0040                EE14            EQU     $40
00F89A 0FF89A -> $0020                EE13            EQU     $20
00F89A 0FF89A -> $0010                EE12            EQU     $10
00F89A 0FF89A -> $0001                EEON            EQU     $01
00F89A 0FF89A -> $0013                MISC            EQU     $0013
00F89A 0FF89A -> $0008                EWDIR           EQU     $08
00F89A 0FF89A -> $0004                NDRC            EQU     $04
00F89A 0FF89A -> $0014                RTICTL          EQU     $0014
00F89A 0FF89A -> $0080                RTIE            EQU     $80
00F89A 0FF89A -> $0040                RTIWAI          EQU     $40
00F89A 0FF89A -> $0020                RSBCK           EQU     $20
00F89A 0FF89A -> $0080                RSBYP           EQU     $80
00F89A 0FF89A -> $0004                RTR2            EQU     $04
00F89A 0FF89A -> $0002                RTR1            EQU     $02
00F89A 0FF89A -> $0001                RTR0            EQU     $01
00F89A 0FF89A -> $0015                RTIFLG          EQU     $0015
00F89A 0FF89A -> $0080                RTIF            EQU     $80
00F89A 0FF89A -> $0016                COPCTL          EQU     $0016
00F89A 0FF89A -> $0080                CME             EQU     $80
00F89A 0FF89A -> $0040                FCME            EQU     $40
00F89A 0FF89A -> $0020                FCM             EQU     $20
00F89A 0FF89A -> $0010                FCOP            EQU     $10
00F89A 0FF89A -> $0008                DISR            EQU     $08
00F89A 0FF89A -> $0004                CR2             EQU     $04
00F89A 0FF89A -> $0002                CR1             EQU     $02
00F89A 0FF89A -> $0001                CR0             EQU     $01
00F89A 0FF89A -> $0017                ARMCOP          EQU     $0017
                                      ;$0018 - $001D reserved
00F89A 0FF89A -> $001E                INTCR           EQU     $001E
00F89A 0FF89A -> $0080                IRQE            EQU     $80
00F89A 0FF89A -> $0040                IRQEN           EQU     $40
00F89A 0FF89A -> $0020                DLY             EQU     $20
00F89A 0FF89A -> $001F                HPRIO           EQU     $001F
00F89A 0FF89A -> $0020                PSEL5           EQU     $20
00F89A 0FF89A -> $0010                PSEL4           EQU     $10
00F89A 0FF89A -> $0008                PSEL3           EQU     $08
00F89A 0FF89A -> $0004                PSEL2           EQU     $04
00F89A 0FF89A -> $0002                PSEL1           EQU     $02
00F89A 0FF89A -> $0020                KWIED           EQU     $0020
00F89A 0FF89A -> $0021                KWIFD           EQU     $0021
                                      ;$0022 - $0023 reserved
00F89A 0FF89A -> $0024                PORTH           EQU     $0024
00F89A 0FF89A -> $0080                PTH7            EQU     $80
00F89A 0FF89A -> $0040                PTH6            EQU     $40
00F89A 0FF89A -> $0020                PTH5            EQU     $20
00F89A 0FF89A -> $0010                PTH4            EQU     $10
00F89A 0FF89A -> $0008                PTH3            EQU     $08
00F89A 0FF89A -> $0004                PTH2            EQU     $04
00F89A 0FF89A -> $0002                PTH1            EQU     $02
00F89A 0FF89A -> $0001                PTH0            EQU     $01
00F89A 0FF89A -> $0080                PH7             EQU     $80
00F89A 0FF89A -> $0040                PH6             EQU     $40
00F89A 0FF89A -> $0020                PH5             EQU     $20
00F89A 0FF89A -> $0010                PH4             EQU     $10
00F89A 0FF89A -> $0008                PH3             EQU     $08
00F89A 0FF89A -> $0004                PH2             EQU     $04
00F89A 0FF89A -> $0002                PH1             EQU     $02
00F89A 0FF89A -> $0001                PH0             EQU     $01
00F89A 0FF89A -> $0025                DDRH            EQU     $0025
00F89A 0FF89A -> $0080                DDRH7           EQU     $80
00F89A 0FF89A -> $0040                DDRH6           EQU     $40
00F89A 0FF89A -> $0020                DDRH5           EQU     $20
00F89A 0FF89A -> $0010                DDRH4           EQU     $10
00F89A 0FF89A -> $0008                DDRH3           EQU     $08
00F89A 0FF89A -> $0004                DDRH2           EQU     $04
00F89A 0FF89A -> $0002                DDRH1           EQU     $02
00F89A 0FF89A -> $0001                DDRH0           EQU     $01
00F89A 0FF89A -> $0026                KWIEH           EQU     $0026
00F89A 0FF89A -> $0027                KWIFH           EQU     $0027
00F89A 0FF89A -> $0028                PORTJ           EQU     $0028
00F89A 0FF89A -> $0080                PTJ7            EQU     $80
00F89A 0FF89A -> $0040                PTJ6            EQU     $40
00F89A 0FF89A -> $0020                PTJ5            EQU     $20
00F89A 0FF89A -> $0010                PTJ4            EQU     $10
00F89A 0FF89A -> $0008                PTJ3            EQU     $08
00F89A 0FF89A -> $0004                PTJ2            EQU     $04
00F89A 0FF89A -> $0002                PTJ1            EQU     $02
00F89A 0FF89A -> $0001                PTJ0            EQU     $01
00F89A 0FF89A -> $0080                PJ7             EQU     $80
00F89A 0FF89A -> $0040                PJ6             EQU     $40
00F89A 0FF89A -> $0020                PJ5             EQU     $20
00F89A 0FF89A -> $0010                PJ4             EQU     $10
00F89A 0FF89A -> $0008                PJ3             EQU     $08
00F89A 0FF89A -> $0004                PJ2             EQU     $04
00F89A 0FF89A -> $0002                PJ1             EQU     $02
00F89A 0FF89A -> $0001                PJ0             EQU     $01
00F89A 0FF89A -> $0029                DDRJ            EQU     $0029
00F89A 0FF89A -> $0080                DDRJ7           EQU     $80
00F89A 0FF89A -> $0040                DDRJ6           EQU     $40
00F89A 0FF89A -> $0020                DDRJ5           EQU     $20
00F89A 0FF89A -> $0010                DDRJ4           EQU     $10
00F89A 0FF89A -> $0008                DDRJ3           EQU     $08
00F89A 0FF89A -> $0004                DDRJ2           EQU     $04
00F89A 0FF89A -> $0002                DDRJ1           EQU     $02
00F89A 0FF89A -> $0001                DDRJ0           EQU     $01
00F89A 0FF89A -> $002A                KWIEJ           EQU     $002A
00F89A 0FF89A -> $002B                KWIFJ           EQU     $002B
00F89A 0FF89A -> $002C                KPOL            EQU     $002C
00F89A 0FF89A -> $002D                PUPSJ           EQU     $002D
00F89A 0FF89A -> $002E                PULEJ           EQU     $002E
                                      ;$002F reserved
00F89A 0FF89A -> $0030                PORTF           EQU     $0030
00F89A 0FF89A -> $0040                PTF6            EQU     $40
00F89A 0FF89A -> $0020                PTF5            EQU     $20
00F89A 0FF89A -> $0010                PTF4            EQU     $10
00F89A 0FF89A -> $0008                PTF3            EQU     $08
00F89A 0FF89A -> $0004                PTF2            EQU     $04
00F89A 0FF89A -> $0002                PTF1            EQU     $02
00F89A 0FF89A -> $0001                PTF0            EQU     $01
00F89A 0FF89A -> $0040                PF6             EQU     $40
00F89A 0FF89A -> $0020                PF5             EQU     $20
00F89A 0FF89A -> $0010                PF4             EQU     $10
00F89A 0FF89A -> $0008                PF3             EQU     $08
00F89A 0FF89A -> $0004                PF2             EQU     $04
00F89A 0FF89A -> $0002                PF1             EQU     $02
00F89A 0FF89A -> $0001                PF0             EQU     $01
00F89A 0FF89A -> $0031                PORTG           EQU     $0031
00F89A 0FF89A -> $0020                PTG5            EQU     $20
00F89A 0FF89A -> $0010                PTG4            EQU     $10
00F89A 0FF89A -> $0008                PTG3            EQU     $08
00F89A 0FF89A -> $0004                PTG2            EQU     $04
00F89A 0FF89A -> $0002                PTG1            EQU     $02
00F89A 0FF89A -> $0001                PTG0            EQU     $01
00F89A 0FF89A -> $0020                PG5             EQU     $20
00F89A 0FF89A -> $0010                PG4             EQU     $10
00F89A 0FF89A -> $0008                PG3             EQU     $08
00F89A 0FF89A -> $0004                PG2             EQU     $04
00F89A 0FF89A -> $0002                PG1             EQU     $02
00F89A 0FF89A -> $0001                PG0             EQU     $01
00F89A 0FF89A -> $0032                DDRF            EQU     $0032
00F89A 0FF89A -> $0040                DDRF6           EQU     $40
00F89A 0FF89A -> $0020                DDRF5           EQU     $20
00F89A 0FF89A -> $0010                DDRF4           EQU     $10
00F89A 0FF89A -> $0008                DDRF3           EQU     $08
00F89A 0FF89A -> $0004                DDRF2           EQU     $04
00F89A 0FF89A -> $0002                DDRF1           EQU     $02
00F89A 0FF89A -> $0001                DDRF0           EQU     $01
00F89A 0FF89A -> $0033                DDRG            EQU     $0033
00F89A 0FF89A -> $0020                DDRG5           EQU     $20
00F89A 0FF89A -> $0010                DDRG4           EQU     $10
00F89A 0FF89A -> $0008                DDRG3           EQU     $08
00F89A 0FF89A -> $0004                DDRG2           EQU     $04
00F89A 0FF89A -> $0002                DDRG1           EQU     $02
00F89A 0FF89A -> $0001                DDRG0           EQU     $01
00F89A 0FF89A -> $0034                DPAGE           EQU     $0034
00F89A 0FF89A -> $0035                PPAGE           EQU     $0035
00F89A 0FF89A -> $0020                PIX5            EQU     $20
00F89A 0FF89A -> $0010                PIX4            EQU     $10
00F89A 0FF89A -> $0008                PIX3            EQU     $08
00F89A 0FF89A -> $0004                PIX2            EQU     $04
00F89A 0FF89A -> $0002                PIX1            EQU     $02
00F89A 0FF89A -> $0001                PIX0            EQU     $01
00F89A 0FF89A -> $0036                EPAGE           EQU     $0036
00F89A 0FF89A -> $0037                WINDEF          EQU     $0037
00F89A 0FF89A -> $0038                XMAR            EQU     $0038
                                      ;$0039 - $003B reserved
00F89A 0FF89A -> $003C                CSCTL0          EQU     $003C
00F89A 0FF89A -> $003D                CSCTL1          EQU     $003D
00F89A 0FF89A -> $003E                CSSTR0          EQU     $003E
00F89A 0FF89A -> $003F                CSSTR1          EQU     $003F
00F89A 0FF89A -> $0040                LDVH            EQU     $0040
00F89A 0FF89A -> $0041                LDVL            EQU     $0041
00F89A 0FF89A -> $0042                RDVH            EQU     $0042
00F89A 0FF89A -> $0043                RDVL            EQU     $0043
                                      ;$00044- $0047 reserved
00F89A 0FF89A -> $0047                CLKCTL          EQU     $0047
00F89A 0FF89A -> $0080                LCKF            EQU     $80
00F89A 0FF89A -> $0040                PLLON           EQU     $40
00F89A 0FF89A -> $0020                PLLS            EQU     $20
00F89A 0FF89A -> $0010                BCSC            EQU     $10
00F89A 0FF89A -> $0008                BCSB            EQU     $08
00F89A 0FF89A -> $0004                BCSA            EQU     $04
00F89A 0FF89A -> $0002                MCSB            EQU     $02
00F89A 0FF89A -> $0001                MCSA            EQU     $01
                                      ;$00048- $005F reserved
00F89A 0FF89A -> $0060                ATDCTL0         EQU     $0060
00F89A 0FF89A -> $0061                ATDCTL1         EQU     $0061
00F89A 0FF89A -> $0062                ATDCTL2         EQU     $0062
00F89A 0FF89A -> $0080                ADPU            EQU     $80
00F89A 0FF89A -> $0040                AFFC            EQU     $40
00F89A 0FF89A -> $0020                AWAI            EQU     $20
00F89A 0FF89A -> $0002                ASCIE           EQU     $02
00F89A 0FF89A -> $0001                ASCIF           EQU     $01
00F89A 0FF89A -> $0063                ATDCTL3         EQU     $0063
00F89A 0FF89A -> $0002                FRZ1            EQU     $02
00F89A 0FF89A -> $0001                FRZ0            EQU     $01
00F89A 0FF89A -> $0064                ATDCTL4         EQU     $0064
00F89A 0FF89A -> $0040                SMP1            EQU     $40
00F89A 0FF89A -> $0020                SMP0            EQU     $20
00F89A 0FF89A -> $0010                PRS4            EQU     $10
00F89A 0FF89A -> $0008                PRS3            EQU     $08
00F89A 0FF89A -> $0004                PRS2            EQU     $04
00F89A 0FF89A -> $0002                PRS1            EQU     $02
00F89A 0FF89A -> $0001                PRS0            EQU     $01
00F89A 0FF89A -> $0065                ATDCTL5         EQU     $0065
00F89A 0FF89A -> $0040                S8CM            EQU     $40
00F89A 0FF89A -> $0020                SCAN            EQU     $20
00F89A 0FF89A -> $0010                MULT            EQU     $10
00F89A 0FF89A -> $0008                CD              EQU     $08
00F89A 0FF89A -> $0004                CC              EQU     $04
00F89A 0FF89A -> $0002                CB              EQU     $02
00F89A 0FF89A -> $0001                CA              EQU     $01
00F89A 0FF89A -> $0066                ATDSTAT1        EQU     $0066
00F89A 0FF89A -> $0080                SCF             EQU     $80
00F89A 0FF89A -> $0004                CC2             EQU     $04
00F89A 0FF89A -> $0002                CC1             EQU     $02
00F89A 0FF89A -> $0001                CC0             EQU     $01
00F89A 0FF89A -> $0067                ATDSTAT2        EQU     $0067
00F89A 0FF89A -> $0080                CCF7            EQU     $80
00F89A 0FF89A -> $0040                CCF6            EQU     $40
00F89A 0FF89A -> $0020                CCF5            EQU     $20
00F89A 0FF89A -> $0010                CCF4            EQU     $10
00F89A 0FF89A -> $0008                CCF3            EQU     $08
00F89A 0FF89A -> $0004                CCF2            EQU     $04
00F89A 0FF89A -> $0002                CCF1            EQU     $02
00F89A 0FF89A -> $0001                CCF0            EQU     $01
00F89A 0FF89A -> $0068                ATDTEST0        EQU     $0068
00F89A 0FF89A -> $0080                SAR9            EQU     $80
00F89A 0FF89A -> $0040                SAR8            EQU     $40
00F89A 0FF89A -> $0020                SAR7            EQU     $20
00F89A 0FF89A -> $0010                SAR6            EQU     $10
00F89A 0FF89A -> $0008                SAR5            EQU     $08
00F89A 0FF89A -> $0004                SAR4            EQU     $04
00F89A 0FF89A -> $0002                SAR3            EQU     $02
00F89A 0FF89A -> $0001                SAR2            EQU     $01
00F89A 0FF89A -> $0069                ATDTEST1        EQU     $0069
00F89A 0FF89A -> $0080                SAR1            EQU     $80
00F89A 0FF89A -> $0040                SAR0            EQU     $40
00F89A 0FF89A -> $0020                RST             EQU     $20
00F89A 0FF89A -> $0010                TSTOUT          EQU     $10
00F89A 0FF89A -> $0008                TST3            EQU     $08
00F89A 0FF89A -> $0004                TST2            EQU     $04
00F89A 0FF89A -> $0002                TST1            EQU     $02
00F89A 0FF89A -> $0001                TST0            EQU     $01
                                      ;$006A - $006E reserved
00F89A 0FF89A -> $006F                PORTAD          EQU     $006F
00F89A 0FF89A -> $0080                PAD7            EQU     $80
00F89A 0FF89A -> $0040                PAD6            EQU     $40
00F89A 0FF89A -> $0020                PAD5            EQU     $20
00F89A 0FF89A -> $0010                PAD4            EQU     $10
00F89A 0FF89A -> $0008                PAD3            EQU     $08
00F89A 0FF89A -> $0004                PAD2            EQU     $04
00F89A 0FF89A -> $0002                PAD1            EQU     $02
00F89A 0FF89A -> $0001                PAD0            EQU     $01
00F89A 0FF89A -> $0070                ADR0H           EQU     $0070
                                      ;$0071 reserved
00F89A 0FF89A -> $0072                ADR1H           EQU     $0072
                                      ;$0073 reserved
00F89A 0FF89A -> $0074                ADR2H           EQU     $0074
                                      ;$0075 reserved
00F89A 0FF89A -> $0076                ADR3H           EQU     $0076
                                      ;$0077 reserved
00F89A 0FF89A -> $0078                ADR4H           EQU     $0078
                                      ;$0079 reserved
00F89A 0FF89A -> $007A                ADR5H           EQU     $007A
                                      ;$007B reserved
00F89A 0FF89A -> $007C                ADR6H           EQU     $007C
                                      ;$007D reserved
00F89A 0FF89A -> $007E                ADR7H           EQU     $007E
                                      ;$007F reserved
00F89A 0FF89A -> $0080                TIOS            EQU     $0080
00F89A 0FF89A -> $0080                IOS7            EQU     $80
00F89A 0FF89A -> $0040                IOS6            EQU     $40
00F89A 0FF89A -> $0020                IOS5            EQU     $20
00F89A 0FF89A -> $0010                IOS4            EQU     $10
00F89A 0FF89A -> $0008                IOS3            EQU     $08
00F89A 0FF89A -> $0004                IOS2            EQU     $04
00F89A 0FF89A -> $0002                IOS1            EQU     $02
00F89A 0FF89A -> $0001                IOS0            EQU     $01
00F89A 0FF89A -> $0081                TCFORC          EQU     $0081
00F89A 0FF89A -> $0080                FOC7            EQU     $80
00F89A 0FF89A -> $0040                FOC6            EQU     $40
00F89A 0FF89A -> $0020                FOC5            EQU     $20
00F89A 0FF89A -> $0010                FOC4            EQU     $10
00F89A 0FF89A -> $0008                FOC3            EQU     $08
00F89A 0FF89A -> $0004                FOC2            EQU     $04
00F89A 0FF89A -> $0002                FOC1            EQU     $02
00F89A 0FF89A -> $0001                FOC0            EQU     $01
00F89A 0FF89A -> $0082                TOC7M           EQU     $0082
00F89A 0FF89A -> $0080                OC7M7           EQU     $80
00F89A 0FF89A -> $0040                OC7M6           EQU     $40
00F89A 0FF89A -> $0020                OC7M5           EQU     $20
00F89A 0FF89A -> $0010                OC7M4           EQU     $10
00F89A 0FF89A -> $0008                OC7M3           EQU     $08
00F89A 0FF89A -> $0004                OC7M2           EQU     $04
00F89A 0FF89A -> $0002                OC7M1           EQU     $02
00F89A 0FF89A -> $0001                OC7M0           EQU     $01
00F89A 0FF89A -> $0083                TOC7D           EQU     $0083
00F89A 0FF89A -> $0080                OC7D7           EQU     $80
00F89A 0FF89A -> $0040                OC7D6           EQU     $40
00F89A 0FF89A -> $0020                OC7D5           EQU     $20
00F89A 0FF89A -> $0010                OC7D4           EQU     $10
00F89A 0FF89A -> $0008                OC7D3           EQU     $08
00F89A 0FF89A -> $0004                OC7D2           EQU     $04
00F89A 0FF89A -> $0002                OC7D1           EQU     $02
00F89A 0FF89A -> $0001                OC7D0           EQU     $01
00F89A 0FF89A -> $0084                TCNT            EQU     $0084
00F89A 0FF89A -> $0086                TSCR1           EQU     $0086
00F89A 0FF89A -> $0086                TSCR            EQU     $0086
00F89A 0FF89A -> $0080                TEN             EQU     $80
00F89A 0FF89A -> $0040                TSWAI           EQU     $40
00F89A 0FF89A -> $0020                TSFRZ           EQU     $20
00F89A 0FF89A -> $0010                TFFCA           EQU     $10
                                      ;$0087 reserved
00F89A 0FF89A -> $0088                TCTL1           EQU     $0088
00F89A 0FF89A -> $0080                OM7             EQU     $80
00F89A 0FF89A -> $0040                OL7             EQU     $40
00F89A 0FF89A -> $0020                OM6             EQU     $20
00F89A 0FF89A -> $0010                OL6             EQU     $10
00F89A 0FF89A -> $0008                OM5             EQU     $08
00F89A 0FF89A -> $0004                OL5             EQU     $04
00F89A 0FF89A -> $0002                OM4             EQU     $02
00F89A 0FF89A -> $0001                OL4             EQU     $01
00F89A 0FF89A -> $0089                TCTL2           EQU     $0089
00F89A 0FF89A -> $0080                OM3             EQU     $80
00F89A 0FF89A -> $0040                OL3             EQU     $40
00F89A 0FF89A -> $0020                OM2             EQU     $20
00F89A 0FF89A -> $0010                OL2             EQU     $10
00F89A 0FF89A -> $0008                OM1             EQU     $08
00F89A 0FF89A -> $0004                OL1             EQU     $04
00F89A 0FF89A -> $0002                OM0             EQU     $02
00F89A 0FF89A -> $0001                OL0             EQU     $01
00F89A 0FF89A -> $008A                TCTL3           EQU     $008A
00F89A 0FF89A -> $0080                EDG7B           EQU     $80
00F89A 0FF89A -> $0040                EDG7A           EQU     $40
00F89A 0FF89A -> $0020                EDG6B           EQU     $20
00F89A 0FF89A -> $0010                EDG6A           EQU     $10
00F89A 0FF89A -> $0008                EDG5B           EQU     $08
00F89A 0FF89A -> $0004                EDG5A           EQU     $04
00F89A 0FF89A -> $0002                EDG4B           EQU     $02
00F89A 0FF89A -> $0001                EDG4A           EQU     $01
00F89A 0FF89A -> $008B                TCTL4           EQU     $008B
00F89A 0FF89A -> $0080                EDG3B           EQU     $80
00F89A 0FF89A -> $0040                EDG3A           EQU     $40
00F89A 0FF89A -> $0020                EDG2B           EQU     $20
00F89A 0FF89A -> $0010                EDG2A           EQU     $10
00F89A 0FF89A -> $0008                EDG1B           EQU     $08
00F89A 0FF89A -> $0004                EDG1A           EQU     $04
00F89A 0FF89A -> $0002                EDG0B           EQU     $02
00F89A 0FF89A -> $0001                EDG0A           EQU     $01
00F89A 0FF89A -> $008C                TIE             EQU     $008C
00F89A 0FF89A -> $008C                TMSK1           EQU     $008C
00F89A 0FF89A -> $0080                C7I             EQU     $80
00F89A 0FF89A -> $0040                C6I             EQU     $40
00F89A 0FF89A -> $0020                C5I             EQU     $20
00F89A 0FF89A -> $0010                C4I             EQU     $10
00F89A 0FF89A -> $0008                C3I             EQU     $08
00F89A 0FF89A -> $0004                C2I             EQU     $04
00F89A 0FF89A -> $0002                C1I             EQU     $02
00F89A 0FF89A -> $0001                C0I             EQU     $01
00F89A 0FF89A -> $008D                TSCR2           EQU     $008D
00F89A 0FF89A -> $008D                TMSK2           EQU     $008D
00F89A 0FF89A -> $0080                TOI             EQU     $80
00F89A 0FF89A -> $0040                PUPT            EQU     $40
00F89A 0FF89A -> $0020                RDPT            EQU     $20
00F89A 0FF89A -> $0008                TCRE            EQU     $08
00F89A 0FF89A -> $0004                PR2             EQU     $04
00F89A 0FF89A -> $0002                PR1             EQU     $02
00F89A 0FF89A -> $0001                PR0             EQU     $01
00F89A 0FF89A -> $008E                TFLG1           EQU     $008E
00F89A 0FF89A -> $0080                C7F             EQU     $80
00F89A 0FF89A -> $0040                C6F             EQU     $40
00F89A 0FF89A -> $0020                C5F             EQU     $20
00F89A 0FF89A -> $0010                C4F             EQU     $10
00F89A 0FF89A -> $0008                C3F             EQU     $08
00F89A 0FF89A -> $0004                C2F             EQU     $04
00F89A 0FF89A -> $0002                C1F             EQU     $02
00F89A 0FF89A -> $0001                C0F             EQU     $01
00F89A 0FF89A -> $008F                TFLG2           EQU     $008F
00F89A 0FF89A -> $0080                TOF             EQU     $80
00F89A 0FF89A -> $0090                TC0             EQU     $0090
00F89A 0FF89A -> $0092                TC1             EQU     $0092
00F89A 0FF89A -> $0094                TC2             EQU     $0094
00F89A 0FF89A -> $0096                TC3             EQU     $0096
00F89A 0FF89A -> $0098                TC4             EQU     $0098
00F89A 0FF89A -> $009A                TC5             EQU     $009A
00F89A 0FF89A -> $009C                TC6             EQU     $009C
00F89A 0FF89A -> $009E                TC7             EQU     $009E
00F89A 0FF89A -> $00A0                PACTL           EQU     $00A0
00F89A 0FF89A -> $0040                PAEN            EQU     $40
00F89A 0FF89A -> $0020                PAMOD           EQU     $20
00F89A 0FF89A -> $0010                PEDGE           EQU     $10
00F89A 0FF89A -> $0008                CLK1            EQU     $08
00F89A 0FF89A -> $0004                CLK0            EQU     $04
00F89A 0FF89A -> $0002                PAOVI           EQU     $02
00F89A 0FF89A -> $0001                PAI             EQU     $01
00F89A 0FF89A -> $00A1                PAFLG           EQU     $00A1
00F89A 0FF89A -> $0002                PAOVF           EQU     $02
00F89A 0FF89A -> $0001                PAIF            EQU     $01
00F89A 0FF89A -> $00A2                PACNT           EQU     $00A2
                                      ;$00A4 - $00AC reserved
00F89A 0FF89A -> $00AD                TIMTST          EQU     $00AD
00F89A 0FF89A -> $00AE                PORTT           EQU     $00AE
00F89A 0FF89A -> $0080                PTT7            EQU     $80
00F89A 0FF89A -> $0040                PTT6            EQU     $40
00F89A 0FF89A -> $0020                PTT5            EQU     $20
00F89A 0FF89A -> $0010                PTT4            EQU     $10
00F89A 0FF89A -> $0008                PTT3            EQU     $08
00F89A 0FF89A -> $0004                PTT2            EQU     $04
00F89A 0FF89A -> $0002                PTT1            EQU     $02
00F89A 0FF89A -> $0001                PTT0            EQU     $01
00F89A 0FF89A -> $0080                PT7             EQU     $80
00F89A 0FF89A -> $0040                PT6             EQU     $40
00F89A 0FF89A -> $0020                PT5             EQU     $20
00F89A 0FF89A -> $0010                PT4             EQU     $10
00F89A 0FF89A -> $0008                PT3             EQU     $08
00F89A 0FF89A -> $0004                PT2             EQU     $04
00F89A 0FF89A -> $0002                PT1             EQU     $02
00F89A 0FF89A -> $0001                PT0             EQU     $01
00F89A 0FF89A -> $00AF                DDRT            EQU     $00AF
00F89A 0FF89A -> $0080                DDRT7           EQU     $80
00F89A 0FF89A -> $0040                DDRT6           EQU     $40
00F89A 0FF89A -> $0020                DDRT5           EQU     $20
00F89A 0FF89A -> $0010                DDRT4           EQU     $10
00F89A 0FF89A -> $0008                DDRT3           EQU     $08
00F89A 0FF89A -> $0004                DDRT2           EQU     $04
00F89A 0FF89A -> $0002                DDRT1           EQU     $02
00F89A 0FF89A -> $0001                DDRT0           EQU     $01
                                      ;$00B0 - $00BF reserved
00F89A 0FF89A -> $00C0                SCIBDH          EQU     $00C0
00F89A 0FF89A -> $00C0                SC0BDH          EQU     $00C0
00F89A 0FF89A -> $0080                BTST            EQU     $80
00F89A 0FF89A -> $0040                BSPL            EQU     $40
00F89A 0FF89A -> $0020                BRLD            EQU     $20
00F89A 0FF89A -> $0010                SBR12           EQU     $10
00F89A 0FF89A -> $0008                SBR11           EQU     $08
00F89A 0FF89A -> $0004                SBR10           EQU     $04
00F89A 0FF89A -> $0002                SBR9            EQU     $02
00F89A 0FF89A -> $0001                SBR8            EQU     $01
00F89A 0FF89A -> $00C1                SCIBDL          EQU     $00C1
00F89A 0FF89A -> $00C1                SC0BDL          EQU     $00C1
00F89A 0FF89A -> $0080                SBR7            EQU     $80
00F89A 0FF89A -> $0040                SBR6            EQU     $40
00F89A 0FF89A -> $0020                SBR5            EQU     $20
00F89A 0FF89A -> $0010                SBR4            EQU     $10
00F89A 0FF89A -> $0008                SBR3            EQU     $08
00F89A 0FF89A -> $0004                SBR2            EQU     $04
00F89A 0FF89A -> $0002                SBR1            EQU     $02
00F89A 0FF89A -> $0001                SBR0            EQU     $01
00F89A 0FF89A -> $00C2                SCICR1          EQU     $00C2
00F89A 0FF89A -> $00C2                SC0CR1          EQU     $00C2
00F89A 0FF89A -> $0080                LOOPS           EQU     $80
00F89A 0FF89A -> $0040                WOMS            EQU     $40
00F89A 0FF89A -> $0020                RSRC            EQU     $20
00F89A 0FF89A -> $0010                M               EQU     $10
00F89A 0FF89A -> $0008                WAKE            EQU     $08
00F89A 0FF89A -> $0004                ILT             EQU     $04
00F89A 0FF89A -> $0002                PE              EQU     $02
00F89A 0FF89A -> $0001                PT              EQU     $01
00F89A 0FF89A -> $00C3                SCICR2          EQU     $00C3
00F89A 0FF89A -> $00C3                SC0CR2          EQU     $00C3
00F89A 0FF89A -> $0080                TXIE            EQU     $80  ;renamed to txie, not to clash with tie register
00F89A 0FF89A -> $0040                TCIE            EQU     $40
00F89A 0FF89A -> $0020                RIE             EQU     $20
00F89A 0FF89A -> $0010                ILIE            EQU     $10
00F89A 0FF89A -> $0008                TE              EQU     $08
00F89A 0FF89A -> $0004                RE              EQU     $04
00F89A 0FF89A -> $0002                RWU             EQU     $02
00F89A 0FF89A -> $0001                SBK             EQU     $01
00F89A 0FF89A -> $00C4                SCISR1          EQU     $00C4
00F89A 0FF89A -> $00C4                SC0SR1          EQU     $00C4
00F89A 0FF89A -> $0080                TDRE            EQU     $80
00F89A 0FF89A -> $0040                TC              EQU     $40
00F89A 0FF89A -> $0020                RDRF            EQU     $20
00F89A 0FF89A -> $0010                IDLE            EQU     $10
00F89A 0FF89A -> $0008                OR              EQU     $08
00F89A 0FF89A -> $0004                NF              EQU     $04
00F89A 0FF89A -> $0002                FE              EQU     $02
00F89A 0FF89A -> $0001                PF              EQU     $01
00F89A 0FF89A -> $00C5                SCISR2          EQU     $00C5
00F89A 0FF89A -> $00C5                SC0SR2          EQU     $00C5
00F89A 0FF89A -> $0001                RAF             EQU     $01
00F89A 0FF89A -> $00C6                SCIDRH          EQU     $00C6
00F89A 0FF89A -> $00C6                SC0DRH          EQU     $00C6
00F89A 0FF89A -> $0080                R8              EQU     $80
00F89A 0FF89A -> $0040                T8              EQU     $40
00F89A 0FF89A -> $00C7                SCIDRL          EQU     $00C7
00F89A 0FF89A -> $00C7                SC0DRL          EQU     $00C7
00F89A 0FF89A -> $00C8                SC1BDH          EQU     $00C8
00F89A 0FF89A -> $0080                BTST            EQU     $80
00F89A 0FF89A -> $0040                BSPL            EQU     $40
00F89A 0FF89A -> $0020                BRLD            EQU     $20
00F89A 0FF89A -> $0010                SBR12           EQU     $10
00F89A 0FF89A -> $0008                SBR11           EQU     $08
00F89A 0FF89A -> $0004                SBR10           EQU     $04
00F89A 0FF89A -> $0002                SBR9            EQU     $02
00F89A 0FF89A -> $0001                SBR8            EQU     $01
00F89A 0FF89A -> $00C9                SC1BDL          EQU     $00C9
00F89A 0FF89A -> $0080                SBR7            EQU     $80
00F89A 0FF89A -> $0040                SBR6            EQU     $40
00F89A 0FF89A -> $0020                SBR5            EQU     $20
00F89A 0FF89A -> $0010                SBR4            EQU     $10
00F89A 0FF89A -> $0008                SBR3            EQU     $08
00F89A 0FF89A -> $0004                SBR2            EQU     $04
00F89A 0FF89A -> $0002                SBR1            EQU     $02
00F89A 0FF89A -> $0001                SBR0            EQU     $01
00F89A 0FF89A -> $00CA                SC1CR1          EQU     $00CA
00F89A 0FF89A -> $0080                LOOPS           EQU     $80
00F89A 0FF89A -> $0040                WOMS            EQU     $40
00F89A 0FF89A -> $0020                RSRC            EQU     $20
00F89A 0FF89A -> $0010                M               EQU     $10
00F89A 0FF89A -> $0008                WAKE            EQU     $08
00F89A 0FF89A -> $0004                ILT             EQU     $04
00F89A 0FF89A -> $0002                PE              EQU     $02
00F89A 0FF89A -> $0001                PT              EQU     $01
00F89A 0FF89A -> $00CB                SC1CR2          EQU     $00CB
00F89A 0FF89A -> $0080                TXIE            EQU     $80  ;renamed to txie, not to clash with tie register
00F89A 0FF89A -> $0040                TCIE            EQU     $40
00F89A 0FF89A -> $0020                RIE             EQU     $20
00F89A 0FF89A -> $0010                ILIE            EQU     $10
00F89A 0FF89A -> $0008                TE              EQU     $08
00F89A 0FF89A -> $0004                RE              EQU     $04
00F89A 0FF89A -> $0002                RWU             EQU     $02
00F89A 0FF89A -> $0001                SBK             EQU     $01
00F89A 0FF89A -> $00CC                SC1SR1          EQU     $00CC
00F89A 0FF89A -> $0080                TDRE            EQU     $80
00F89A 0FF89A -> $0040                TC              EQU     $40
00F89A 0FF89A -> $0020                RDRF            EQU     $20
00F89A 0FF89A -> $0010                IDLE            EQU     $10
00F89A 0FF89A -> $0008                OR              EQU     $08
00F89A 0FF89A -> $0004                NF              EQU     $04
00F89A 0FF89A -> $0002                FE              EQU     $02
00F89A 0FF89A -> $0001                PF              EQU     $01
00F89A 0FF89A -> $00CD                SC1SR2          EQU     $00CD
00F89A 0FF89A -> $0001                RAF             EQU     $01
00F89A 0FF89A -> $00CE                SC1DRH          EQU     $00CE
00F89A 0FF89A -> $0080                R8              EQU     $80
00F89A 0FF89A -> $0040                T8              EQU     $40
00F89A 0FF89A -> $00CF                SC1DRL          EQU     $00CF
00F89A 0FF89A -> $00D0                SPICR1          EQU     $00D0
00F89A 0FF89A -> $00D0                SP0CR1          EQU     $00D0
00F89A 0FF89A -> $0080                SPIE            EQU     $80
00F89A 0FF89A -> $0040                SPE             EQU     $40
00F89A 0FF89A -> $0020                SPTIE           EQU     $20
00F89A 0FF89A -> $0010                MSTR            EQU     $10
00F89A 0FF89A -> $0008                CPOL            EQU     $08
00F89A 0FF89A -> $0004                CPHA            EQU     $04
00F89A 0FF89A -> $0002                SSOE            EQU     $02
00F89A 0FF89A -> $0001                LSBFE           EQU     $01
00F89A 0FF89A -> $00D1                SPICR2          EQU     $00D1
00F89A 0FF89A -> $00D1                SP0CR2          EQU     $00D1
00F89A 0FF89A -> $0008                PUPS            EQU     $08
00F89A 0FF89A -> $0004                RDS             EQU     $04
00F89A 0FF89A -> $0001                SPC0            EQU     $01
00F89A 0FF89A -> $00D2                SPIBR           EQU     $00D2
00F89A 0FF89A -> $00D2                SP0BR           EQU     $00D2
00F89A 0FF89A -> $0040                SPPR2           EQU     $40
00F89A 0FF89A -> $0020                SPPR1           EQU     $20
00F89A 0FF89A -> $0010                SPPR0           EQU     $10
00F89A 0FF89A -> $0004                SPR2            EQU     $04
00F89A 0FF89A -> $0002                SPR1            EQU     $02
00F89A 0FF89A -> $0001                SPR0            EQU     $01
00F89A 0FF89A -> $00D3                SPISR           EQU     $00D3
00F89A 0FF89A -> $00D3                SP0SR           EQU     $00D3
00F89A 0FF89A -> $0080                SPIF            EQU     $80
00F89A 0FF89A -> $0020                SPTEF           EQU     $20
00F89A 0FF89A -> $0010                MODF            EQU     $10
                                      ;$00D4 reserved
00F89A 0FF89A -> $00D5                SPIDR           EQU     $00D5
00F89A 0FF89A -> $00D5                SP0DR           EQU     $00D5
00F89A 0FF89A -> $00D6                PORTS           EQU     $00D6
00F89A 0FF89A -> $0080                PTS7            EQU     $80
00F89A 0FF89A -> $0040                PTS6            EQU     $40
00F89A 0FF89A -> $0020                PTS5            EQU     $20
00F89A 0FF89A -> $0010                PTS4            EQU     $10
00F89A 0FF89A -> $0008                PTS3            EQU     $08
00F89A 0FF89A -> $0004                PTS2            EQU     $04
00F89A 0FF89A -> $0002                PTS1            EQU     $02
00F89A 0FF89A -> $0001                PTS0            EQU     $01
00F89A 0FF89A -> $0080                PS7             EQU     $80
00F89A 0FF89A -> $0040                PS6             EQU     $40
00F89A 0FF89A -> $0020                PS5             EQU     $20
00F89A 0FF89A -> $0010                PS4             EQU     $10
00F89A 0FF89A -> $0008                PS3             EQU     $08
00F89A 0FF89A -> $0004                PS2             EQU     $04
00F89A 0FF89A -> $0002                PS1             EQU     $02
00F89A 0FF89A -> $0001                PS0             EQU     $01
00F89A 0FF89A -> $00D7                DDRS            EQU     $00D7
00F89A 0FF89A -> $0080                DDRS7           EQU     $80
00F89A 0FF89A -> $0040                DDRS6           EQU     $40
00F89A 0FF89A -> $0020                DDRS5           EQU     $20
00F89A 0FF89A -> $0010                DDRS4           EQU     $10
00F89A 0FF89A -> $0008                DDRS3           EQU     $08
00F89A 0FF89A -> $0004                DDRS2           EQU     $04
00F89A 0FF89A -> $0002                DDRS1           EQU     $02
00F89A 0FF89A -> $0001                DDRS0           EQU     $01
                                      ;$00D8 - $00EF reserved
00F89A 0FF89A -> $00F0                EEMCR           EQU     $00F0
00F89A 0FF89A -> $00F1                EEPROT          EQU     $00F1
00F89A 0FF89A -> $00F2                EETST           EQU     $00F2
00F89A 0FF89A -> $00F3                EEPROG          EQU     $00F3
                                      ;###############################################################################
                                      ;# S12CBase - GPIO - GPIO Handler (SIMHC12)                                    #
                                      ;###############################################################################
                                      ;#    Copyright 2010-2012 Dirk Heisswolf                                       #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    This module initializes all unused GPIO ports. The OpenBDM firmware      #
                                      ;#    assumes the following I/O pin configuration of the S12C128 MCU:          #
                                      ;#    Port A:                                                                  #
                                      ;#     PA0 - NC                           (input        pull-up)               #
                                      ;#     PA1 - NC                           (input        pull-up)               #
                                      ;#     PA2 - NC                           (input        pull-up)               #
                                      ;#     PA3 - NC                           (input        pull-up)               #
                                      ;#     PA4 - NC                           (input        pull-up)               #
                                      ;#     PA5 - NC                           (input        pull-up)               #
                                      ;#     PA6 - NC                           (input        pull-up)               #
                                      ;#     PA7 - NC                           (input        pull-up)               #
                                      ;#    Port B:                                                                  #
                                      ;#     PB0 - NC                           (input        pull-up)               #
                                      ;#     PB1 - NC                           (input        pull-up)               #
                                      ;#     PB2 - NC                           (input        pull-up)               #
                                      ;#     PB3 - NC                           (input        pull-up)               #
                                      ;#     PB4 - NC                           (input        pull-up)               #
                                      ;#     PB5 - NC                           (input        pull-up)               #
                                      ;#     PB6 - NC                           (input        pull-up)               #
                                      ;#     PB7 - NC                           (input        pull-up)               #
                                      ;#    Port C:                                                                  #
                                      ;#     PC0 - NC                           (input        pull-up)               #
                                      ;#     PC1 - NC                           (input        pull-up)               #
                                      ;#     PC2 - NC                           (input        pull-up)               #
                                      ;#     PC3 - NC                           (input        pull-up)               #
                                      ;#     PC4 - NC                           (input        pull-up)               #
                                      ;#     PC5 - NC                           (input        pull-up)               #
                                      ;#     PC6 - NC                           (input        pull-up)               #
                                      ;#     PC7 - NC                           (input        pull-up)               #
                                      ;#    Port D:                                                                  #
                                      ;#     PD0 - NC                           (input        pull-up)               #
                                      ;#     PD1 - NC                           (input        pull-up)               #
                                      ;#     PD2 - NC                           (input        pull-up)               #
                                      ;#     PD3 - NC                           (input        pull-up)               #
                                      ;#     PD4 - NC                           (input        pull-up)               #
                                      ;#     PD5 - NC                           (input        pull-up)               #
                                      ;#     PD6 - NC                           (input        pull-up)               #
                                      ;#     PD7 - NC                           (input        pull-up)               #
                                      ;#    Port E:                                                                  #
                                      ;#     PE0 - /IRQ                         (input        pull-up)               #
                                      ;#     PE1 - /XIRQ                        (input        no pull)               #
                                      ;#     PE2 - NC                           (input        pull-up)               #
                                      ;#     PE3 - NC                           (input        pull-up)               #
                                      ;#     PE4 - NC                           (input        no pull)               #
                                      ;#     PE5 - NC                           (input        no pull)               #
                                      ;#     PE6 - NC                           (input        no pull)               #
                                      ;#     PE7 - NC                           (input        no pull)               #
                                      ;#    Port F:                                                                  #
                                      ;#     PF0 - NC                           (input        pull-up)               #
                                      ;#     PF1 - NC                           (input        pull-up)               #
                                      ;#     PF2 - NC                           (input        pull-up)               #
                                      ;#     PF3 - NC                           (input        pull-up)               #
                                      ;#     PF4 - NC                           (input        pull-up)               #
                                      ;#     PF5 - NC                           (input        pull-up)               #
                                      ;#     PF6 - NC                           (input        pull-up)               #
                                      ;#    Port G:                                                                  #
                                      ;#     PG0 - NC                           (input        pull-up)               #
                                      ;#     PG1 - NC                           (input        pull-up)               #
                                      ;#     PG2 - NC                           (input        pull-up)               #
                                      ;#     PG3 - NC                           (input        pull-up)               #
                                      ;#     PG4 - NC                           (input        pull-up)               #
                                      ;#     PG5 - NC                           (input        pull-up)               #
                                      ;#    Port H:                                                                  #
                                      ;#     PH0 - NC                           (input        pull-up)               #
                                      ;#     PH1 - NC                           (input        pull-up)               #
                                      ;#     PH2 - NC                           (input        pull-up)               #
                                      ;#     PH3 - NC                           (input        pull-up)               #
                                      ;#     PH4 - NC                           (input        pull-up)               #
                                      ;#     PH5 - NC                           (input        pull-up)               #
                                      ;#     PH6 - NC                           (input        pull-up)               #
                                      ;#     PH7 - NC                           (input        pull-up)               #
                                      ;#    Port J:                                                                  #
                                      ;#     PJ0 - NC                           (input        no pull)               #
                                      ;#     PJ1 - NC                           (input        no pull)               #
                                      ;#     PJ2 - NC                           (input        no pull)               #
                                      ;#     PJ3 - NC                           (input        no pull)               #
                                      ;#     PJ4 - NC                           (input        no pull)               #
                                      ;#     PJ5 - NC                           (input        no pull)               #
                                      ;#     PJ6 - NC                           (input        no pull)               #
                                      ;#     PJ7 - NC                           (input        no pull)               #
                                      ;#    Port S:                                                                  #
                                      ;#     PS0 - SCI RX input                 (input        no pull)               #
                                      ;#     PS1 - SCI TX output                (output       no pull)               #
                                      ;#     PS2 - NC                           (input        no pull)               #
                                      ;#     PS3 - NC                           (input        no pull)               #
                                      ;#     PS4 - NC                           (input        no pull)               #
                                      ;#     PS5 - NC                           (input        no pull)               #
                                      ;#     PS6 - NC                           (input        no pull)               #
                                      ;#     PS7 - NC                           (input        no pull)               #
                                      ;#    Port T:                                                                  #
                                      ;#     PT0 - NC                           (input        no pull)               #
                                      ;#     PT1 - NC                           (input        no pull)               #
                                      ;#     PT2 - NC                           (input        no pull)               #
                                      ;#     PT3 - NC                           (input        no pull)               #
                                      ;#     PT4 - NC                           (input        no pull)               #
                                      ;#     PT5 - NC                           (input        no pull)               #
                                      ;#     PT6 - NC                           (input        no pull)               #
                                      ;#     PT7 - NC                           (input        no pull)               #
                                      ;#    Port AD:                                                                 #
                                      ;#     PAD0 - NC                          (input        no pull)               #
                                      ;#     PAD1 - NC                          (input        no pull)               #
                                      ;#     PAD2 - NC                          (input        no pull)               #
                                      ;#     PAD3 - NC                          (input        no pull)               #
                                      ;#     PAD4 - NC                          (input        no pull)               #
                                      ;#     PAD5 - NC                          (input        no pull)               #
                                      ;#     PAD6 - NC                          (input        no pull)               #
                                      ;#     PAD7 - NC                          (input        no pull)               #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    REGDEF - Register Definitions                                            #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - none                                                                   #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    April 4, 2010                                                            #
                                      ;#      - Initial release                                                      #
                                      ;#    July 10, 2012                                                             #
                                      ;#      - Added support for linear PC                                          #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Constants                                                                   #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000800 0F4800                                                 ORG     GPIO_VARS_START, GPIO_VARS_START_LIN
000800 0F4800 -> $0800                GPIO_VARS_END           EQU     *
000800 0F4800 -> $F4800               GPIO_VARS_END_LIN       EQU     @
                                      ;###############################################################################
                                      ;# Macros                                                                      #
                                      ;###############################################################################
                                      ;#Initialization
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F349 0FF349                                                 ORG     GPIO_CODE_START, GPIO_CODE_START_LIN
00F349 0FF349 -> $F349                GPIO_CODE_END           EQU     *
00F349 0FF349 -> $FF349               GPIO_CODE_END_LIN       EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F89A 0FF89A                                                 ORG     GPIO_TABS_START, GPIO_TABS_START_LIN
00F89A 0FF89A -> $F89A                GPIO_TABS_END           EQU     *
00F89A 0FF89A -> $FF89A               GPIO_TABS_END_LIN       EQU     @
                                      ;###############################################################################
                                      ;# S12CBase - MMAP - Memory Map (SIMHC12)                                      #
                                      ;###############################################################################
                                      ;#    Copyright 2010 Dirk Heisswolf                                            #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    This module module performs all the necessary steps to initialize the    #
                                      ;#    device after each reset.                                                 #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    REGDEF - Register Definitions                                            #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - none                                                                   #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    November 15, 2012                                                            #
                                      ;#      - Initial release                                                      #
                                      ;###############################################################################
                                      ;  Flash Memory Map:
                                      ;  -----------------
                                      ;                     HC12A4
                                      ;                +-------------+ $0000
                                      ;                |  Registers  |
                                      ;                +-------------+ $0200
                                      ;                |/////////////|
                                      ;             R+ +-------------+ $0800
                                      ;             A| |  Variables  |
                                      ;             M+ +-------------+ $0C00
                                      ;                |/////////////|
                                      ;              + +-------------+ $F000
                                      ;             E| |    Code     |
                                      ;             E| +-------------+
                                      ;             P| |  Tables     |
                                      ;             R| +-------------+
                                      ;             O| |/////////////|
                                      ;             M| +-------------+ $FFC0
                                      ;              | |  Vectors    |
                                      ;              + +-------------+
                                      ;###############################################################################
                                      ;# Configuration                                                               #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Constants                                                                   #
                                      ;###############################################################################
                                      ;# Memory sizes
00F89A 0FF89A -> $0200                MMAP_REG_SIZE           EQU     $0200
00F89A 0FF89A -> $0400                MMAP_RAM_SIZE           EQU     $0400
00F89A 0FF89A -> $1000                MMAP_EEPROM_SIZE        EQU     $1000
                                      ;# Memory Locations
00F89A 0FF89A -> $0000                MMAP_REG_START          EQU     $0000
00F89A 0FF89A -> $0800                MMAP_RAM_START          EQU     $0800
00F89A 0FF89A -> $F000                MMAP_EEPROM_START       EQU     $F000
                                      ;###############################################################################
                                      ;# Security and Protection                                                     #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000800 0F4800                                                 ORG     MMAP_VARS_START, MMAP_VARS_START_LIN
000800 0F4800 -> $0800                MMAP_VARS_END           EQU     *
000800 0F4800 -> $F4800               MMAP_VARS_END_LIN       EQU     @
                                                              ;MOVB   #(((MMAP_EEPROM_START>>8)&$F1)|$01), INITEE ;keep whatever reset value
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F349 0FF349                                                 ORG     MMAP_CODE_START, MMAP_CODE_START_LIN
00F349 0FF349 -> $F349                MMAP_CODE_END           EQU     *
00F349 0FF349 -> $FF349               MMAP_CODE_END_LIN       EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F89A 0FF89A                                                 ORG     MMAP_TABS_START, MMAP_TABS_START_LIN
00F89A 0FF89A -> $F89A                MMAP_TABS_END           EQU     *
00F89A 0FF89A -> $FF89A               MMAP_TABS_END_LIN       EQU     @
                                      ;###############################################################################
                                      ;# S12CBase - SSTACK - Subroutine Stack Handler                                #
                                      ;###############################################################################
                                      ;#    Copyright 2010-2012 Dirk Heisswolf                                       #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    Early versions of S12CBase framework used to have separate stacks        #
                                      ;#    interrupt handling and subroutine calls. These two stacks have noe been  #
                                      ;#    combined to one. However the API of the separate stacks has been kept:   #
                                      ;#    => The ISTACK module implements all functions required for interrupt     #
                                      ;#       handling.                                                             #
                                      ;#    => The SSTACK module implements all functions for subroutine calls and   #
                                      ;#       temporary RAM storage.                                                #
                                      ;#                                                                             #
                                      ;#    All of the stacking functions check the upper and lower boundaries of    #
                                      ;#    the stack. Fatal errors are thrown if the stacking space is exceeded.    #
                                      ;#                                                                             #
                                      ;#    The ISTACK module no longer implements an idle loop. Instead it offers   #
                                      ;#    the macro ISTACK_WAIT to build local idle loops for drivers which        #
                                      ;#    implement blocking I/O.                                                  #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    April 4, 2010                                                            #
                                      ;#      - Initial release                                                      #
                                      ;#    January 8, 2011                                                          #
                                      ;#      - Combined ISTACK and SSTACK                                           #
                                      ;#    June 29, 2012                                                            #
                                      ;#      - Added support for linear PC                                          #
                                      ;#      - Debug option "SSTACK_DEBUG"                                          #
                                      ;#      - Added new stacking macros                                            #
                                      ;#      - Switched from post-checks to pre-checks                              #
                                      ;#      - Added option to disable stack range checks "SSTACK_NO_CHECK"         #
                                      ;#    November 14, 2012                                                        #
                                      ;#      - Removed PSH/PUL macros                                               #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    ISTACK - Interrupt Stack Handler                                         #
                                      ;#    ERROR  - Error Handler                                                   #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - none                                                                   #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Stack Layout                                                                #
                                      ;###############################################################################
                                      ; ISTACK_VARS_START,   +-------------------+
                                      ;        ISTACK_TOP -> |                   |
                                      ;                      | ISTACK_FRAME_SIZE |
                                      ;                      |                   |
                                      ;                      +-------------------+
                                      ;        SSTACK_TOP -> |                   |
                                      ;                      |                   |
                                      ;                      |                   |
                                      ;                      |                   |
                                      ;                      |    SSTACK_DEPTH   |
                                      ;                      |                   |
                                      ;                      |                   |
                                      ;                      |                   |
                                      ;     SSTACK_BOTTOM,   |                   |
                                      ;     ISTACK_BOTTOM,   +-------------------+
                                      ;   ISTACK_VARS_END ->
                                      ;
                                      ;The SSTACK is checked once before every JOBSR and once before every RTS.
                                      ;###############################################################################
                                      ;# Configuration                                                               #
                                      ;###############################################################################
                                      ;Debug option for stack over/underflows
                                      ;SSTACK_DEBUG           EQU     1
                                      ;Disable stack range checks
                                      ;SSTACK_NO_CHECK        EQU     1
                                      ;Stack depth
                                      ;###############################################################################
                                      ;# Constants                                                                   #
                                      ;###############################################################################
00F89A 0FF89A -> $080A                SSTACK_TOP              EQU     ISTACK_TOP+ISTACK_FRAME_SIZE
00F89A 0FF89A -> $0825                SSTACK_BOTTOM           EQU     ISTACK_BOTTOM
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000800 0F4800                                                 ORG     SSTACK_VARS_START, SSTACK_VARS_START_LIN
000800 0F4800 -> $0800                SSTACK_VARS_END         EQU     *
000800 0F4800 -> $F4800               SSTACK_VARS_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F349 0FF349                                                 ORG     SSTACK_CODE_START, SSTACK_CODE_START_LIN
                                      ;#Handle stack overflows
00F349 0FF349 -> $F349                SSTACK_OF               EQU     *
00F349 0FF349 MACRO                                           RESET_FATAL     SSTACK_MSG_OF ;throw a fatal error
                                      ;#Perform a reset due to a fatal error                                           (RESET_FATAL)
                                      ; args: 1: message pointer                                                       (RESET_FATAL)
                                                              ;BGND                                                    (RESET_FATAL)
00F349 0FF349 CE F8 9A                                        LDX     #\1                                              (RESET_FATAL)
00F34C 0FF34C 06 F6 DC                                        JOB     RESET_FATAL                                      (RESET_FATAL)
                                      ;#Handle stack underflows
00F34F 0FF34F -> $F34F                SSTACK_UF               EQU     *
00F34F 0FF34F MACRO                                           RESET_FATAL     SSTACK_MSG_UF ;throw a fatal error
                                      ;#Perform a reset due to a fatal error                                           (RESET_FATAL)
                                      ; args: 1: message pointer                                                       (RESET_FATAL)
                                                              ;BGND                                                    (RESET_FATAL)
00F34F 0FF34F CE F8 B3                                        LDX     #\1                                              (RESET_FATAL)
00F352 0FF352 06 F6 DC                                        JOB     RESET_FATAL                                      (RESET_FATAL)
00F355 0FF355 -> $F355                SSTACK_CODE_END         EQU     *
00F355 0FF355 -> $FF355               SSTACK_CODE_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F89A 0FF89A                                                 ORG     SSTACK_TABS_START, SSTACK_TABS_START_LIN
                                      ;#Error Messages
00F89A 0FF89A 53 75 62 72 6F 75 74 69 SSTACK_MSG_OF           FCS     "Subroutine stack overflow"
              6E 65 20 73 74 61 63 6B 
              20 6F 76 65 72 66 6C 6F 
              F7                      
00F8B3 0FF8B3 53 75 62 72 6F 75 74 69 SSTACK_MSG_UF           FCS     "Subroutine stack underflow"
              6E 65 20 73 74 61 63 6B 
              20 75 6E 64 65 72 66 6C 
              6F F7                   
00F8CD 0FF8CD -> $F8CD                SSTACK_TABS_END         EQU     *
00F8CD 0FF8CD -> $FF8CD               SSTACK_TABS_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# S12CBase - ISTACK - Interrupt Stack Handler                                 #
                                      ;###############################################################################
                                      ;#    Copyright 2010-2012 Dirk Heisswolf                                       #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    Early versions of S12CBase framework used to have separate stacks        #
                                      ;#    interrupt handling and subroutine calls. These two stacks have noe been  #
                                      ;#    combined to one. However the API of the separate stacks has been kept:   #
                                      ;#    => The ISTACK module implements all functions required for interrupt     #
                                      ;#       handling.                                                             #
                                      ;#    => The SSTACK module implements all functions for subroutine calls and   #
                                      ;#       temporary RAM storage.                                                #
                                      ;#                                                                             #
                                      ;#    All of the stacking functions check the upper and lower boundaries of    #
                                      ;#    the stack. Fatal errors are thrown if the stacking space is exceeded.    #
                                      ;#                                                                             #
                                      ;#    The ISTACK module no longer implements an idle loop. Instead it offers   #
                                      ;#    the macro ISTACK_WAIT to build local idle loops for drivers which        #
                                      ;#    implement blocking I/O.                                                  #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    April 4, 2010                                                            #
                                      ;#      - Initial release                                                      #
                                      ;#    January 8, 2011                                                          #
                                      ;#      - Combined ISTACK and SSTACK                                           #
                                      ;#    June 29, 2012                                                            #
                                      ;#      - Added support for linear PC                                          #
                                      ;#      - Added debug option "ISTACK_DEBUG"                                    #
                                      ;#      - Added option to disable stack range checks "ISTACK_NO_CHECK"         #
                                      ;#      - Added support for multiple interrupt nesting levels                  #
                                      ;#    July 27, 2012                                                            #
                                      ;#      - Added macro "ISTACK_CALL_ISR"                                        #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    SSTACK - Subroutine Stack Handler                                        #
                                      ;#    ERROR  - Error Handler                                                   #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - none                                                                   #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Stack Layout                                                                #
                                      ;###############################################################################
                                      ; ISTACK_VARS_START,   +-------------------+
                                      ;        ISTACK_TOP -> |                   |
                                      ;                      | ISTACK_FRAME_SIZE |
                                      ;                      |                   |
                                      ;                      +-------------------+
                                      ;        SSTACK_TOP -> |                   |
                                      ;                      |                   |
                                      ;                      |                   |
                                      ;                      |                   |
                                      ;                      |    SSTACK_DEPTH   |
                                      ;                      |                   |
                                      ;                      |                   |
                                      ;                      |                   |
                                      ;     SSTACK_BOTTOM,   |                   |
                                      ;     ISTACK_BOTTOM,   +-------------------+
                                      ;   ISTACK_VARS_END ->
                                      ;
                                      ;###############################################################################
                                      ;# Configuration                                                               #
                                      ;###############################################################################
                                      ;Debug option for stack over/underflows
                                      ;ISTACK_DEBUG           EQU     1
                                      ;Disable stack range checks
                                      ;ISTACK_NO_CHECK        EQU     1
                                      ;Interrupt nesting levels
                                      ;CPU
                                      ;###############################################################################
                                      ;# Constants                                                                   #
                                      ;###############################################################################
00F8CD 0FF8CD -> $0040                ISTACK_CCR              EQU     %0100_0000
00F8CD 0FF8CD -> $000A                ISTACK_FRAME_SIZE       EQU     10
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000800 0F4800                                                 ORG     ISTACK_VARS_START, ISTACK_VARS_START_LIN
000800 0F4800 -> $0800                ISTACK_TOP              EQU     *
000800 0F4800                                                 DS      ISTACK_FRAME_SIZE*ISTACK_LEVELS
00080A 0F480A                                                 DS      SSTACK_DEPTH
000825 0F4825 -> $0825                ISTACK_BOTTOM           EQU     *
000825 0F4825 -> $0825                ISTACK_VARS_END         EQU     *
000825 0F4825 -> $F4825               ISTACK_VARS_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F355 0FF355                                                 ORG     ISTACK_CODE_START, ISTACK_CODE_START_LIN
                                      ;#Handle stack overflows
00F355 0FF355 -> $F355                ISTACK_OF               EQU     *
00F355 0FF355 MACRO                                           RESET_FATAL     ISTACK_MSG_OF ;throw a fatal error
                                      ;#Perform a reset due to a fatal error                                           (RESET_FATAL)
                                      ; args: 1: message pointer                                                       (RESET_FATAL)
                                                              ;BGND                                                    (RESET_FATAL)
00F355 0FF355 CE F8 CD                                        LDX     #\1                                              (RESET_FATAL)
00F358 0FF358 06 F6 DC                                        JOB     RESET_FATAL                                      (RESET_FATAL)
                                      ;#Handle stack underflows
00F35B 0FF35B -> $F35B                ISTACK_UF               EQU     *
00F35B 0FF35B MACRO                                           RESET_FATAL     ISTACK_MSG_UF ;throw a fatal error
                                      ;#Perform a reset due to a fatal error                                           (RESET_FATAL)
                                      ; args: 1: message pointer                                                       (RESET_FATAL)
                                                              ;BGND                                                    (RESET_FATAL)
00F35B 0FF35B CE F8 E5                                        LDX     #\1                                              (RESET_FATAL)
00F35E 0FF35E 06 F6 DC                                        JOB     RESET_FATAL                                      (RESET_FATAL)
00F361 0FF361 -> $F361                ISTACK_CODE_END         EQU     *
00F361 0FF361 -> $FF361               ISTACK_CODE_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F8CD 0FF8CD                                                 ORG     ISTACK_TABS_START, ISTACK_TABS_START_LIN
                                      ;#Error Messages
00F8CD 0FF8CD 49 6E 74 65 72 72 75 70 ISTACK_MSG_OF           FCS     "Interrupt stack overflow"
              74 20 73 74 61 63 6B 20 
              6F 76 65 72 66 6C 6F F7 
00F8E5 0FF8E5 49 6E 74 65 72 72 75 70 ISTACK_MSG_UF           FCS     "Interrupt stack underflow"
              74 20 73 74 61 63 6B 20 
              75 6E 64 65 72 66 6C 6F 
              F7                      
00F8FE 0FF8FE -> $F8FE                ISTACK_TABS_END         EQU     *
00F8FE 0FF8FE -> $FF8FE               ISTACK_TABS_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# S12CBase - TIM - Timer Driver                                               #
                                      ;###############################################################################
                                      ;#    Copyright 2010-2012 Dirk Heisswolf                                       #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    The module controls the timer. The eight timer channes are used as       #
                                      ;#    follows:                                                                 #
                                      ;#      IC0:     SCI baud rate detection (capture posedges on RX pin)          #
                                      ;#      IC1:     SCI baud rate detection (capture negedges on RX pin)          #
                                      ;#      OC2:     SCI baud rate detection (timeout)                             #
                                      ;#      OC3:     SCI (timeout)                                                 #
                                      ;#      OC4:     unasigned                                                     #
                                      ;#      IC5:     BDM (capture posedges on BKGD pin)                            #
                                      ;#      IC6/OC5: BDM (capture negedges on BKGD pin/toggle BKGD pin)            #
                                      ;#      OC7:     BDM (toggle BKGD pin/timeouts)                                #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    April 4, 2010                                                            #
                                      ;#      - Initial release                                                      #
                                      ;#    February 22, 2012                                                        #
                                      ;#      - Back-ported LFBDMPGMR updates                                        #
                                      ;#    November 14, 2012                                                        #
                                      ;#      - Total redo                                                           #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    REGDEF - Register Definitions                                            #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - none                                                                   #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Configuration                                                               #
                                      ;###############################################################################
                                      ;Clock divider
                                      ;-------------
00F8FE 0FF8FE -> $0001                TIM_DIV2_OFF            EQU     1       ;default no clock divider
                                      ;###############################################################################
                                      ;# Constants                                                                   #
                                      ;###############################################################################
                                      ;#SCI channels defaults
00F8FE 0FF8FE -> $000F                TIM_SCI                 EQU     $0F     ;all channels
00F8FE 0FF8FE -> $0001                TIM_SCIBDPE             EQU     $01     ;posedge/toggle detection
00F8FE 0FF8FE -> $0002                TIM_SCIBDNE             EQU     $02     ;negedge detection
00F8FE 0FF8FE -> $0004                TIM_SCIBDTO             EQU     $04     ;Baud rate detection
00F8FE 0FF8FE -> $0008                TIM_SCITO               EQU     $08     ;XON/XOFF reminders
                                      ;#BDM channel defaults
00F8FE 0FF8FE -> $00E0                TIM_BDM                 EQU     $E0     ;all channels
00F8FE 0FF8FE -> $0020                TIM_BDMPE               EQU     $20     ;posedge/toggle detection
00F8FE 0FF8FE -> $0040                TIM_BDMNE               EQU     $40     ;negedge detection
00F8FE 0FF8FE -> $0080                TIM_BDMTO               EQU     $80     ;SCI bug workaround
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000825 0F4825                                                 ORG     TIM_VARS_START, TIM_VARS_START_LIN
000825 0F4825 -> $0825                TIM_VARS_END            EQU     *
000825 0F4825 -> $F4825               TIM_VARS_END_LIN        EQU     @
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F361 0FF361                                                 ORG     TIM_CODE_START, TIM_CODE_START_LIN
00F361 0FF361 -> $F361                TIM_CODE_END            EQU     *
00F361 0FF361 -> $FF361               TIM_CODE_END_LIN        EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F8FE 0FF8FE                                                 ORG     TIM_TABS_START, TIM_TABS_START_LIN
00F8FE 0FF8FE -> $F8FE                TIM_TABS_END            EQU     *
00F8FE 0FF8FE -> $FF8FE               TIM_TABS_END_LIN        EQU     @
                                      ;###############################################################################
                                      ;# S12CBase - SCI - Serial Communication Interface Driver                      #
                                      ;###############################################################################
                                      ;#    Copyright 2010-2012 Dirk Heisswolf                                       #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    This is the low level driver for the SCI module.                         #
                                      ;#                                                                             #
                                      ;#    This module provides the following functions to the main program:        #
                                      ;#    SCI_TX_NB     - This function sends a byte over the serial interface. In #
                                      ;#                    case of a transmit buffer overflow, it will return       #
                                      ;#                    immediately with an error status.                        #
                                      ;#    SCI_TX_BL     - This function sends a byte over the serial interface. It #
                                      ;#                    will block the program flow until the data can be handed #
                                      ;#                    over to the transmit queue.                              #
                                      ;#    SCI_TX_CHECK  - Checks if a transmission is ongoing.                     #
                                      ;#    SCI_TX_WAIT   - This function blocksthe program execution until all      #
                                      ;#                    pending data is sent.                                    #
                                      ;#    SCI_RX_NB     - This function reads a byte (and associated error flags)  #
                                      ;#                    It will return an error status if no read data is        #
                                      ;#                    available.                                               #
                                      ;#    SCI_RX_BL     - This function reads a byte (and associated error flags)  #
                                      ;#                    from the serial interface. It will block the             #
                                      ;#                    program flow until data is available.                    #
                                      ;#    SCI_RX_PEEK   - This function reads the oldest buffer entry and the      #
                                      ;#                    number receive buffer entries, without modifying the     #
                                      ;#                    buffer.                                                  #
                                      ;#    SCI_BAUD      - This function allows the application to set the SCI's    #
                                      ;#                    baud rate manually.                                      #
                                      ;#                                                                             #
                                      ;#    For convinience, all of these functions may also be called as macro.     #
                                      ;#                                                                             #
                                      ;#    Five error condition can occur when receiving data from the serial       #
                                      ;#    interface:                                                               #
                                      ;#    SWOR - Software Overrun (in RX Queue)                                    #
                                      ;#         The main program has failed to free up the RX queeue in time.       #
                                      ;#         The received data is considerd to be valid.                         #
                                      ;#         Baud rate detection will not be triggered.                          #
                                      ;#         This condition will be reported to the application.                 #
                                      ;#                                                                             #
                                      ;#    OR - Overrun (in SCI hardware)                                           #
                                      ;#         The software has failed to transfer RX data to the RX queue in      #
                                      ;#         time.                                                               #
                                      ;#         The received data is considerd to be valid.                         #
                                      ;#         Baud rate detection will not be triggered.                          #
                                      ;#         This condition will be reported to the application.                 #
                                      ;#                                                                             #
                                      ;#    NF - Noise (Flag)                                                        #
                                      ;#         Noise has been detected on the RX line.                             #
                                      ;#         The received data is still considerd to be valid.                   #
                                      ;#         Baud rate detection will be triggered.                              #
                                      ;#         This condition will not be reported to the application.             #
                                      ;#                                                                             #
                                      ;#    FE - Framing Error                                                       #
                                      ;#         An invalid data frame (stop bit) has been received                  #
                                      ;#         The received data is considerd to be invalid.                       #
                                      ;#         If a sequence of invalid data is received, only one entry will be   #
                                      ;#         stored in the RX queue.                                             #
                                      ;#         Baud rate detection will be triggered.                              #
                                      ;#         This condition will be reported to the application.                 #
                                      ;#                                                                             #
                                      ;#    PE - Parity Error (only occurs if parity is enabled)                     #
                                      ;#         An invalid parity bit has been received                             #
                                      ;#         The received data is considerd to be invalid.                       #
                                      ;#         If a sequence of invalid data is received, only one entry will be   #
                                      ;#         stored in the RX queue.                                             #
                                      ;#         Baud rate detection will be triggered.                              #
                                      ;#         This condition will be reported to the application.                 #
                                      ;#                                                                             #
                                      ;#    The SCI module is capable of detecting the baud rate of received data.   #
                                      ;#    Whenever a framing error, a parity error or noise is detected, the baud  #
                                      ;#    rate detection is activated and the module begins measuring all high and #
                                      ;#    low pulses on the RX line. Assuming that the sender uses one of the      #
                                      ;#    following baud rates:     4800                                           #
                                      ;#                              7200                                           #
                                      ;#                              9600                                           #
                                      ;#                             14400                                           #
                                      ;#                             19200                                           #
                                      ;#                             28800                                           #
                                      ;#                             38400                                           #
                                      ;#                             57600                                           #
                                      ;#    ...it finds the senders baud rate by elimination. When the baud rate has #
                                      ;#    been detected (all but one of the valid baud rates eliminated) and 15    #
                                      ;#    consecutive low or high ulses match this baud rate, then the SCI will be #
                                      ;#    set to the new baud rate.                                                #
                                      ;#    While the baud rate detection is active, a communication error will be   #
                                      ;#    signaled over the LED.                                                   #
                                      ;#                                                                             #
                                      ;#    The SCI driver supports hardware flow control (RTS/CTS) to allow 8-bit   #
                                      ;#    data transmissions. The flow control signals are implemented to using    #
                                      ;#    the following GPIO pins:  RTS input:  PM0                                #
                                      ;#                              CTS output: PM1                                #
                                      ;#    The remaining PM pins are unused.                                        #
                                      ;###############################################################################
                                      ;# Flow Control:                                                               #
                                      ;# RTS/CTS:                                                                    #
                                      ;#          Only transmit if RTS is set                                        #
                                      ;#          Forbid incoming data -> clear CTS                                  #
                                      ;#          Allow incoming data -> set CTS                                     #
                                      ;# XON/XOFF:                                                                   #
                                      ;#          Remember the last received XON/XOFF                                #
                                      ;#          Only transmit if XON was received last                             #
                                      ;#          Forbid incoming data                                               #
                                      ;#                                                                             #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    ISTACK - Interrupt Stack Handler                                         #
                                      ;#    SSTACK - Subroutine Stack Handler                                        #
                                      ;#    GPIO   - GPIO driver                                                     #
                                      ;#    TIM    - Timer driver                                                    #
                                      ;#    LED    - LED driver                                                      #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - The bus clock must be set to 24.576MHz                                 #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    April 4, 2010                                                            #
                                      ;#      - Initial release                                                      #
                                      ;#    April 22, 2010                                                           #
                                      ;#      - added functions SCI_TBE and SCI_BAUD                                 #
                                      ;#    June 6, 2010                                                             #
                                      ;#      - changed selection of detectable baud rates                           #
                                      ;#      - stop baud rate detection when receiving a corret character           #
                                      ;#      - stop baud rate detection when manually setting the baud rate         #
                                      ;#    January 2, 2012                                                          #
                                      ;#      - Mini-BDM-Pod uses XON/XOFF flow control instead of RTS/CTS           #
                                      ;#    November 14, 2012                                                        #
                                      ;#      - Total redo                                                           #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Baud rate detection                                                         #
                                      ;###############################################################################
                                      ;typ. bus speed:     25 MHz
                                      ;max. baud rate:  153600 baud   ==>  162 bus cycles per bit
                                      ;min. baud rate:    4800 baud   ==> 5208 bus cycles per bit (46875 per frame)
                                      ;###############################################################################
                                      ;# Configuration                                                               #
                                      ;###############################################################################
                                      ;General settings
                                      ;----------------
                                      ;Bus frequency
                                      ;Invert RXD/TXD
00F8FE 0FF8FE -> $0001                SCI_RXTX_ACTLO          EQU     1               ;default is active low RXD/TXD
                                      ;Flow control
                                      ;------------
                                      ;RTS/CTS or XON/XOFF
                                      ;XON/XOFF reminder intervall
00F8FE 0FF8FE -> $1DCD                SCI_XONXOFF_REMINDER    EQU     (10*CLOCK_BUS_FREQ)/65536
                                      ;RTS/CTS pins
                                      ;Delay counter
                                      ;-------------
00F8FE 0FF8FE -> $0003                SCI_DLY_OC              EQU     $3              ;default is OC3
                                      ;C0 character handling
                                      ;---------------------
                                      ;Detect BREAK character
                                      ;Detect SUSPEND character
                                      ;Baud rate detection
                                      ;-------------------
                                      ;Enable (SCI_BD_ON or SCI_BD_OFF)
                                      ;ECT or TIM (SCI_BD_ECT or SCI_BD_TIM)
00F8FE 0FF8FE -> $0001                SCI_BD_TIM              EQU     1               ;default is TIM
                                      ;Input capture channels
00F8FE 0FF8FE -> $0000                SCI_BD_ICPE             EQU     $0              ;default is IC0
00F8FE 0FF8FE -> $0001                SCI_BD_ICNE             EQU     $1              ;default is IC1
00F8FE 0FF8FE -> $0000                SCI_BD_IC               EQU     $0              ;default is IC0
                                      ;Output compare channels
00F8FE 0FF8FE -> $0002                SCI_BD_OC               EQU     $2              ;default is OC2
                                      ;Log captured BD pulse length
00F8FE 0FF8FE -> $0001                SCI_BD_LOG_OFF          EQU     1               ;default is SCI_BD_LOG_OFF
                                      ;Communication error signaling
                                      ;-----------------------------
                                      ;Enable error signaling (if enabled, macros SCI_ERRSIG_ON and SCI_ERRSIG_OFF must be defined)
                                      ;Blocking subroutines
                                      ;--------------------
                                      ;Enable blocking subroutines
                                      ;.MC9S12DP25625 SCI IRQ workaround (MUCts00510)
                                      ;----------------------------------------------
                                      ;###############################################################################
                                      ;# The will SCI only request interrupts if an odd number of interrupt flags is #
                                      ;# This will cause disabled and spourious interrupts.                          #
                                      ;# -> The RX/TX ISR must be periodically triggered by a timer interrupt.       #
                                      ;#    The timer period should be about as long as two SCI frames:              #
                                      ;#    RT cycle = SCIBD * bus cycles                                            #
                                      ;#    bit time = 16 * RT cycles = 16 * SCIBD * bus cycles                      #
                                      ;#    frame time = 10 * bit times = 160 RT cycles = 160 * SCIBD * bus cycles   #
                                      ;#    2 * frame times = 320 * SCIBD * bus cycles = 0x140 * SCIBD * bus cycles  #
                                      ;#    Simplification:                                                          #
                                      ;#    TIM period = 0x100 * SCIBD * bus cycles                                  #
                                      ;###############################################################################
                                      ;Enable IRQ workaround
00F8FE 0FF8FE -> $0001                SCI_IRQ_WORKAROUND_OFF  EQU     1               ;IRQ workaround disabled by default
                                      ;###############################################################################
                                      ;# Constants                                                                   #
                                      ;###############################################################################
                                      ;#Baud rate devider settings
                                      ; SCIBD = 25MHz / (16*baud rate)
00F8FE 0FF8FE -> $0A2C                SCI_1200                EQU     (CLOCK_BUS_FREQ/(16*  1200))+(((2*CLOCK_BUS_FREQ)/(16*  1200))&1)
00F8FE 0FF8FE -> $0516                SCI_2400                EQU     (CLOCK_BUS_FREQ/(16*  2400))+(((2*CLOCK_BUS_FREQ)/(16*  2400))&1)
00F8FE 0FF8FE -> $028B                SCI_4800                EQU     (CLOCK_BUS_FREQ/(16*  4800))+(((2*CLOCK_BUS_FREQ)/(16*  4800))&1)
00F8FE 0FF8FE -> $01B2                SCI_7200                EQU     (CLOCK_BUS_FREQ/(16*  7200))+(((2*CLOCK_BUS_FREQ)/(16*  7200))&1)
00F8FE 0FF8FE -> $0146                SCI_9600                EQU     (CLOCK_BUS_FREQ/(16*  9600))+(((2*CLOCK_BUS_FREQ)/(16*  9600))&1)
00F8FE 0FF8FE -> $00D9                SCI_14400               EQU     (CLOCK_BUS_FREQ/(16* 14400))+(((2*CLOCK_BUS_FREQ)/(16* 14400))&1)
00F8FE 0FF8FE -> $00A3                SCI_19200               EQU     (CLOCK_BUS_FREQ/(16* 19200))+(((2*CLOCK_BUS_FREQ)/(16* 19200))&1)
00F8FE 0FF8FE -> $006D                SCI_28800               EQU     (CLOCK_BUS_FREQ/(16* 28800))+(((2*CLOCK_BUS_FREQ)/(16* 28800))&1)
00F8FE 0FF8FE -> $0051                SCI_38400               EQU     (CLOCK_BUS_FREQ/(16* 38400))+(((2*CLOCK_BUS_FREQ)/(16* 38400))&1)
00F8FE 0FF8FE -> $0036                SCI_57600               EQU     (CLOCK_BUS_FREQ/(16* 57600))+(((2*CLOCK_BUS_FREQ)/(16* 57600))&1)
00F8FE 0FF8FE -> $0029                SCI_76800               EQU     (CLOCK_BUS_FREQ/(16* 76800))+(((2*CLOCK_BUS_FREQ)/(16* 76800))&1)
00F8FE 0FF8FE -> $001B                SCI_115200              EQU     (CLOCK_BUS_FREQ/(16*115200))+(((2*CLOCK_BUS_FREQ)/(16*115200))&1)
00F8FE 0FF8FE -> $0014                SCI_153600              EQU     (CLOCK_BUS_FREQ/(16*153600))+(((2*CLOCK_BUS_FREQ)/(16*153600))&1)
00F8FE 0FF8FE -> $0146                SCI_BDEF                EQU     SCI_9600                        ;default baud rate
00F8FE 0FF8FE -> $0CCC                SCI_BMUL                EQU     $FFFF/SCI_153600                ;Multiplicator for storing the baud rate
                                      ;#Frame format
00F8FE 0FF8FE -> $0004                SCI_8N1                 EQU       ILT           ;8N1
00F8FE 0FF8FE -> $0006                SCI_8E1                 EQU       ILT|PE        ;8E1
00F8FE 0FF8FE -> $0007                SCI_8O1                 EQU       ILT|PE|PT     ;8O1
00F8FE 0FF8FE -> $0014                SCI_8N2                 EQU     M|ILT           ;8N2 TX8=1
                                      ;#C0 characters
00F8FE 0FF8FE -> $00E0                SCI_C0_MASK             EQU     $E0             ;mask for C0 character range
00F8FE 0FF8FE -> $0003                SCI_BREAK               EQU     $03             ;ctrl-c (terminate program execution)
00F8FE 0FF8FE -> $0010                SCI_DLE                 EQU     $10             ;data link escape (treat next byte as data)
00F8FE 0FF8FE -> $0011                SCI_XON                 EQU     $11             ;unblock transmission
00F8FE 0FF8FE -> $0013                SCI_XOFF                EQU     $13             ;block transmission
00F8FE 0FF8FE -> $001A                SCI_SUSPEND             EQU     $1A             ;ctrl-z (suspend program execution)
                                      ;#Buffer sizes
00F8FE 0FF8FE -> $0020                SCI_RXBUF_SIZE          EQU      16*2           ;size of the receive buffer (8 error:data entries)
00F8FE 0FF8FE -> $0008                SCI_TXBUF_SIZE          EQU       8             ;size of the transmit buffer
00F8FE 0FF8FE -> $001F                SCI_RXBUF_MASK          EQU     $1F             ;mask for rolling over the RX buffer
00F8FE 0FF8FE -> $0007                SCI_TXBUF_MASK          EQU     $07             ;mask for rolling over the TX buffer
                                      ;#Hardware handshake borders
00F8FE 0FF8FE -> $0010                SCI_RX_FULL_LEVEL       EQU      8*2            ;RX buffer threshold to block transmissions
00F8FE 0FF8FE -> $0004                SCI_RX_EMPTY_LEVEL      EQU      2*2            ;RX buffer threshold to unblock transmissions
                                      ;#Flag definitions
00F8FE 0FF8FE -> $0080                SCI_FLG_SEND_XONXOFF    EQU     $80             ;send XON/XOFF symbol asap
00F8FE 0FF8FE -> $0040                SCI_FLG_POLL_RTS        EQU     $40             ;poll RTS input
00F8FE 0FF8FE -> $0010                SCI_FLG_SWOR            EQU     $10             ;software buffer overrun (RX buffer)
00F8FE 0FF8FE -> $0008                SCI_FLG_TX_BLOCKED      EQU     $08             ;don't transmit (XOFF received)
00F8FE 0FF8FE -> $0004                SCI_FLG_RX_ESC          EQU     $04             ;character is to be escaped
00F8FE 0FF8FE -> $0002                SCI_FLG_TX_ESC          EQU     $02             ;character is to be escaped
                                      ;#Timer setup
00F8FE 0FF8FE -> $0000                SCI_DLY_TIOS_VAL        EQU     0
                                      ;#Baud rate detection
00F8FE 0FF8FE -> $0008                SCI_BD_RECOVCNT_INIT    EQU     8
00F8FE 0FF8FE -> $00FF                SCI_BD_LIST_INIT        EQU     $FF
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000825 0F4825                                                 ORG     SCI_VARS_START, SCI_VARS_START_LIN
000825 0F4825 -> $0825                SCI_AUTO_LOC1           EQU     *               ;1st auto-place location
000826 0F4826                                                 ALIGN   1
                                      ;#Receive buffer
000826 0F4826                         SCI_RXBUF               DS      SCI_RXBUF_SIZE
000846 0F4846                         SCI_RXBUF_IN            DS      1               ;points to the next free space
000847 0F4847                         SCI_RXBUF_OUT           DS      1               ;points to the oldest entry
                                      ;#Transmit buffer
000848 0F4848                         SCI_TXBUF               DS      SCI_TXBUF_SIZE
000850 0F4850                         SCI_TXBUF_IN            DS      1               ;points to the next free space
000851 0F4851                         SCI_TXBUF_OUT           DS      1               ;points to the oldest entry
                                      ;#Baud rate (reset proof)
000852 0F4852                         SCI_BVAL                DS      2               ;value of the SCIBD register *SCI_BMUL
000854 0F4854                         SCI_AUTO_LOC2           DS      1               ;2nd auto-place location
000855 0F4855                                                 UNALIGN 1
                                      ;#Flags
000855 0F4855 -> $0825                SCI_FLGS                EQU     ((SCI_VARS_START&1)*SCI_AUTO_LOC1)+((~SCI_VARS_START&1)*SCI_AUTO_LOC2)
000855 0F4855                                                 UNALIGN (~SCI_AUTO_LOC1&1)
                                      ;#XON/XOFF reminder count
                                      ;#Baud rate detection registers
                                      ;#BD log buffer
000855 0F4855 -> $0855                SCI_VARS_END            EQU     *
000855 0F4855 -> $F4855               SCI_VARS_END_LIN        EQU     @
                                      ;Clear BD pulse log
                                      ; args:   none
                                      ; SSTACK: none
                                      ;         X, and Y are preserved
                                      ;Log BD pulse length
                                      ; args: X: pulse length
                                      ;       Y: search tree pointer
                                      ; SSTACK: none
                                      ;         X, and Y are preserved
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F361 0FF361                                                 ORG     SCI_CODE_START, SCI_CODE_START_LIN
                                      ;#Transmit one byte - non-blocking
                                      ; args:   B: data to be send
                                      ; result: C-flag: set if successful
                                      ; SSTACK: 5 bytes
                                      ;         X, Y, and D are preserved
00F361 0FF361 -> $F361                SCI_TX_NB               EQU     *
                                                              ;Save registers (data in B)
00F361 0FF361 35                                              PSHY
00F362 0FF362 36                                              PSHA
                                                              ;Write data into the TX buffer (data in B)
00F363 0FF363 CD 08 48                                        LDY     #SCI_TXBUF
00F366 0FF366 B6 08 50                                        LDAA    SCI_TXBUF_IN
00F369 0FF369 6B EC                                           STAB    A,Y
                                                              ;Check if there is room for this entry (data in B, in-index in A, TX buffer pointer in Y)
00F36B 0FF36B 42                                              INCA                                            ;increment index
00F36C 0FF36C 84 07                                           ANDA    #SCI_TXBUF_MASK
00F36E 0FF36E B1 08 51                                        CMPA    SCI_TXBUF_OUT
00F371 0FF371 27 17                                           BEQ     SCI_TX_NB_1                             ;buffer is full
                                                              ;Update buffer
00F373 0FF373 7A 08 50                                        STAA    SCI_TXBUF_IN
                                                              ;Enable interrupts
00F376 0FF376 18 0B AC 00 C3                                  MOVB    #(TXIE|RIE|TE|RE), SCICR2                               ;enable TX interrupt
                                                              ;Restore registers
00F37B 0FF37B MACRO                                           SSTACK_PREPULL  5
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F37B 0FF37B 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F37E 0FF37E 25 C9                                           BLO     OF                                               (SSTACK_PREPULL)
00F380 0FF380 8F 08 20                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F383 0FF383 22 CA                                           BHI     UF                                               (SSTACK_PREPULL)
00F385 0FF385 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F385 0FF385 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F385 0FF385 32                                              PULA
00F386 0FF386 31                                              PULY
                                                              ;Signal success
00F387 0FF387 14 01                                           SEC
                                                              ;Done
00F389 0FF389 3D                                              RTS
                                                              ;Buffer is full
                                                              ;Restore registers
00F38A 0FF38A MACRO                   SCI_TX_NB_1             SSTACK_PREPULL  5
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F38A 0FF38A 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F38D 0FF38D 25 BA                                           BLO     OF                                               (SSTACK_PREPULL)
00F38F 0FF38F 8F 08 20                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F392 0FF392 22 BB                                           BHI     UF                                               (SSTACK_PREPULL)
00F394 0FF394 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F394 0FF394 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F394 0FF394 32                                              PULA
00F395 0FF395 31                                              PULY
                                                              ;Signal failure
00F396 0FF396 10 FE                                           CLC
                                                              ;Done
00F398 0FF398 3D                                              RTS
                                      ;#Transmit one byte - blocking
                                      ; args:   B: data to be send
                                      ; result: none
                                      ; SSTACK: 7 bytes
                                      ;         X, Y, and D are preserved
00F399 0FF399 -> $F399                SCI_TX_BL               EQU     *
00F399 0FF399 MACRO                                           SCI_MAKE_BL     SCI_TX_NB, 5
                                      ;# Macros for internal use                                                       (SCI_MAKE_BL)
                                      ;#Turn a non-blocking subroutine into a blocking subroutine                      (SCI_MAKE_BL)
                                      ; args:   1: non-blocking function                                               (SCI_MAKE_BL)
                                      ;         2: subroutine stack usage of non-blocking function                     (SCI_MAKE_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (SCI_MAKE_BL)
                                      ;         rgister output of the non-blocking function is preserved               (SCI_MAKE_BL)
                                                              ;Disable interrupts                                      (SCI_MAKE_BL)
00F399 0FF399 14 10                   LOOP                    SEI                                                      (SCI_MAKE_BL)
                                                              ;Call non-blocking function                              (SCI_MAKE_BL)
00F39B 0FF39B                                                 //SSTACK_PREPUSH        \2                               (SCI_MAKE_BL)
00F39B 0FF39B 07 C4                                           JOBSR   \1                                               (SCI_MAKE_BL)
00F39D 0FF39D 24 0D                                           BCC     WAIT            ;function unsuccessful           (SCI_MAKE_BL)
                                                              ;Enable interrupts                                       (SCI_MAKE_BL)
00F39F 0FF39F 10 EF                                           CLI                                                      (SCI_MAKE_BL)
                                                              ;Done                                                    (SCI_MAKE_BL)
00F3A1 0FF3A1 MACRO                                           SSTACK_PREPULL  2                                        (SCI_MAKE_BL)
                                      ;#Check stack before pull operation                                              (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; result: none                                                                   (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/SSTACK_PREPULL)
00F3A1 0FF3A1 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SCI_MAKE_BL/SSTACK_PREPULL)
00F3A4 0FF3A4 25 A3                                           BLO     OF                                               (SCI_MAKE_BL/SSTACK_PREPULL)
00F3A6 0FF3A6 8F 08 23                                        CPS     #SSTACK_BOTTOM-\1                                (SCI_MAKE_BL/SSTACK_PREPULL)
00F3A9 0FF3A9 22 A4                                           BHI     UF                                               (SCI_MAKE_BL/SSTACK_PREPULL)
00F3AB 0FF3AB -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_MAKE_BL/SSTACK_PREPULL)
00F3AB 0FF3AB -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_MAKE_BL/SSTACK_PREPULL)
00F3AB 0FF3AB 3D                                              RTS                                                      (SCI_MAKE_BL)
                                                              ;Wait for next interrupt                                 (SCI_MAKE_BL)
00F3AC 0FF3AC MACRO                   WAIT                    ISTACK_WAIT                                              (SCI_MAKE_BL)
                                      ;#Wait until any interrupt has been serviced                                     (SCI_MAKE_BL/ISTACK_WAIT)
                                      ; args:   none                                                                   (SCI_MAKE_BL/ISTACK_WAIT)
                                      ; ISTACK: none                                                                   (SCI_MAKE_BL/ISTACK_WAIT)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Verify SP before runnung ISRs                           (SCI_MAKE_BL/ISTACK_WAIT)
00F3AC 0FF3AC 8F 08 0A                                        CPS     #ISTACK_TOP+ISTACK_FRAME_SIZE                    (SCI_MAKE_BL/ISTACK_WAIT)
00F3AF 0FF3AF 25 A4                                           BLO     OF ;ISTACK_OF                                    (SCI_MAKE_BL/ISTACK_WAIT)
00F3B1 0FF3B1 8F 08 25                                        CPS     #ISTACK_BOTTOM                                   (SCI_MAKE_BL/ISTACK_WAIT)
00F3B4 0FF3B4 22 A5                                           BHI     UF ;ISTACK_UF                                    (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Wait for the next interrupt                             (SCI_MAKE_BL/ISTACK_WAIT)
00F3B6 0FF3B6 MACRO                                           COP_SERVICE                     ;already taken care of by WAI (SCI_MAKE_BL/ISTACK_WAIT)
00F3B6 0FF3B6 10 EF                                           CLI                                                      (SCI_MAKE_BL/ISTACK_WAIT)
00F3B8 0FF3B8 3E                                              WAI                                                      (SCI_MAKE_BL/ISTACK_WAIT)
00F3B9 0FF3B9 -> $F355                OF                      EQU     ISTACK_OF                                        (SCI_MAKE_BL/ISTACK_WAIT)
00F3B9 0FF3B9 -> $F35B                UF                      EQU     ISTACK_UF                                        (SCI_MAKE_BL/ISTACK_WAIT)
00F3B9 0FF3B9 -> $F3B9                DONE                    EQU     *                                                (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Try again                                               (SCI_MAKE_BL)
00F3B9 0FF3B9 MACRO                                           SSTACK_PREPUSH  \2                                       (SCI_MAKE_BL)
                                      ;############################################################################### (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;############################################################################### (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; result: none                                                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/SSTACK_PREPUSH)
00F3B9 0FF3B9 8F 08 0F                                        CPS     #SSTACK_TOP+\1                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
00F3BC 0FF3BC 25 8B                                           BLO     OF                                               (SCI_MAKE_BL/SSTACK_PREPUSH)
00F3BE 0FF3BE 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
00F3C1 0FF3C1 22 8C                                           BHI     UF                                               (SCI_MAKE_BL/SSTACK_PREPUSH)
00F3C3 0FF3C3 -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
00F3C3 0FF3C3 -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
00F3C3 0FF3C3 20 D4                                           JOB     LOOP                                             (SCI_MAKE_BL)
                                      ;#Check if a transmission is ongoing
                                      ; args:   none
                                      ; result:  C-flag: set if all transmissionsare complete
                                      ; SSTACK: 4 bytes
                                      ;         X, Y, and D are preserved
00F3C5 0FF3C5 -> $F3C5                SCI_TX_DONE_NB          EQU     *
                                                              ;Save registers
00F3C5 0FF3C5 3B                                              PSHD
                                                              ;Check TX queue
00F3C6 0FF3C6 FC 08 50                                        LDD     SCI_TXBUF_IN
00F3C9 0FF3C9 18 17                                           CBA
00F3CB 0FF3CB 26 04                                           BNE     SCI_TX_DONE_NB_1 ;transmissions queued
                                                              ;Check SCI status
00F3CD 0FF3CD 4E C4 C0 12                                     BRSET   SCISR1, #(TDRE|TC), SCI_TX_DONE_NB_2 ;all transmissionscomplete
                                                              ;Transmissions ongoing
                                                              ;Restore registers
00F3D1 0FF3D1 MACRO                   SCI_TX_DONE_NB_1        SSTACK_PREPULL  4
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F3D1 0FF3D1 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F3D4 0FF3D4 18 25 FF 71                                     BLO     OF                                               (SSTACK_PREPULL)
00F3D8 0FF3D8 8F 08 21                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F3DB 0FF3DB 18 22 FF 70                                     BHI     UF                                               (SSTACK_PREPULL)
00F3DF 0FF3DF -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F3DF 0FF3DF -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F3DF 0FF3DF 3A                                              PULD
                                                              ;Signal failure
00F3E0 0FF3E0 10 FE                                           CLC
                                                              ;Done
00F3E2 0FF3E2 3D                                              RTS
                                                              ;All transmissions complete
                                                              ;Restore registers
00F3E3 0FF3E3 MACRO                   SCI_TX_DONE_NB_2        SSTACK_PREPULL  4
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F3E3 0FF3E3 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F3E6 0FF3E6 18 25 FF 5F                                     BLO     OF                                               (SSTACK_PREPULL)
00F3EA 0FF3EA 8F 08 21                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F3ED 0FF3ED 18 22 FF 5E                                     BHI     UF                                               (SSTACK_PREPULL)
00F3F1 0FF3F1 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F3F1 0FF3F1 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F3F1 0FF3F1 3A                                              PULD
                                                              ;Signal failure
00F3F2 0FF3F2 14 01                                           SEC
                                                              ;Done
00F3F4 0FF3F4 3D                                              RTS
                                      ;#Wait until all pending data is sent
                                      ; args:   none
                                      ; result: none
                                      ; SSTACK: 6 bytes
                                      ;         X, Y, and D are preserved
00F3F5 0FF3F5 -> $F3F5                SCI_TX_DONE_BL          EQU     *
00F3F5 0FF3F5 MACRO                                           SCI_MAKE_BL     SCI_TX_DONE_NB, 4
                                      ;# Macros for internal use                                                       (SCI_MAKE_BL)
                                      ;#Turn a non-blocking subroutine into a blocking subroutine                      (SCI_MAKE_BL)
                                      ; args:   1: non-blocking function                                               (SCI_MAKE_BL)
                                      ;         2: subroutine stack usage of non-blocking function                     (SCI_MAKE_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (SCI_MAKE_BL)
                                      ;         rgister output of the non-blocking function is preserved               (SCI_MAKE_BL)
                                                              ;Disable interrupts                                      (SCI_MAKE_BL)
00F3F5 0FF3F5 14 10                   LOOP                    SEI                                                      (SCI_MAKE_BL)
                                                              ;Call non-blocking function                              (SCI_MAKE_BL)
00F3F7 0FF3F7                                                 //SSTACK_PREPUSH        \2                               (SCI_MAKE_BL)
00F3F7 0FF3F7 07 CC                                           JOBSR   \1                                               (SCI_MAKE_BL)
00F3F9 0FF3F9 24 11                                           BCC     WAIT            ;function unsuccessful           (SCI_MAKE_BL)
                                                              ;Enable interrupts                                       (SCI_MAKE_BL)
00F3FB 0FF3FB 10 EF                                           CLI                                                      (SCI_MAKE_BL)
                                                              ;Done                                                    (SCI_MAKE_BL)
00F3FD 0FF3FD MACRO                                           SSTACK_PREPULL  2                                        (SCI_MAKE_BL)
                                      ;#Check stack before pull operation                                              (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; result: none                                                                   (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/SSTACK_PREPULL)
00F3FD 0FF3FD 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SCI_MAKE_BL/SSTACK_PREPULL)
00F400 0FF400 18 25 FF 45                                     BLO     OF                                               (SCI_MAKE_BL/SSTACK_PREPULL)
00F404 0FF404 8F 08 23                                        CPS     #SSTACK_BOTTOM-\1                                (SCI_MAKE_BL/SSTACK_PREPULL)
00F407 0FF407 18 22 FF 44                                     BHI     UF                                               (SCI_MAKE_BL/SSTACK_PREPULL)
00F40B 0FF40B -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_MAKE_BL/SSTACK_PREPULL)
00F40B 0FF40B -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_MAKE_BL/SSTACK_PREPULL)
00F40B 0FF40B 3D                                              RTS                                                      (SCI_MAKE_BL)
                                                              ;Wait for next interrupt                                 (SCI_MAKE_BL)
00F40C 0FF40C MACRO                   WAIT                    ISTACK_WAIT                                              (SCI_MAKE_BL)
                                      ;#Wait until any interrupt has been serviced                                     (SCI_MAKE_BL/ISTACK_WAIT)
                                      ; args:   none                                                                   (SCI_MAKE_BL/ISTACK_WAIT)
                                      ; ISTACK: none                                                                   (SCI_MAKE_BL/ISTACK_WAIT)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Verify SP before runnung ISRs                           (SCI_MAKE_BL/ISTACK_WAIT)
00F40C 0FF40C 8F 08 0A                                        CPS     #ISTACK_TOP+ISTACK_FRAME_SIZE                    (SCI_MAKE_BL/ISTACK_WAIT)
00F40F 0FF40F 18 25 FF 42                                     BLO     OF ;ISTACK_OF                                    (SCI_MAKE_BL/ISTACK_WAIT)
00F413 0FF413 8F 08 25                                        CPS     #ISTACK_BOTTOM                                   (SCI_MAKE_BL/ISTACK_WAIT)
00F416 0FF416 18 22 FF 41                                     BHI     UF ;ISTACK_UF                                    (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Wait for the next interrupt                             (SCI_MAKE_BL/ISTACK_WAIT)
00F41A 0FF41A MACRO                                           COP_SERVICE                     ;already taken care of by WAI (SCI_MAKE_BL/ISTACK_WAIT)
00F41A 0FF41A 10 EF                                           CLI                                                      (SCI_MAKE_BL/ISTACK_WAIT)
00F41C 0FF41C 3E                                              WAI                                                      (SCI_MAKE_BL/ISTACK_WAIT)
00F41D 0FF41D -> $F355                OF                      EQU     ISTACK_OF                                        (SCI_MAKE_BL/ISTACK_WAIT)
00F41D 0FF41D -> $F35B                UF                      EQU     ISTACK_UF                                        (SCI_MAKE_BL/ISTACK_WAIT)
00F41D 0FF41D -> $F41D                DONE                    EQU     *                                                (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Try again                                               (SCI_MAKE_BL)
00F41D 0FF41D MACRO                                           SSTACK_PREPUSH  \2                                       (SCI_MAKE_BL)
                                      ;############################################################################### (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;############################################################################### (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; result: none                                                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/SSTACK_PREPUSH)
00F41D 0FF41D 8F 08 0E                                        CPS     #SSTACK_TOP+\1                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
00F420 0FF420 18 25 FF 25                                     BLO     OF                                               (SCI_MAKE_BL/SSTACK_PREPUSH)
00F424 0FF424 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
00F427 0FF427 18 22 FF 24                                     BHI     UF                                               (SCI_MAKE_BL/SSTACK_PREPUSH)
00F42B 0FF42B -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
00F42B 0FF42B -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
00F42B 0FF42B 20 C8                                           JOB     LOOP                                             (SCI_MAKE_BL)
                                      ;#Check if TX queue can hold further data
                                      ; args:   none
                                      ; result: C-flag: set if successful
                                      ; SSTACK: 4 bytes
                                      ;         X, Y, and D are preserved
00F42D 0FF42D -> $F42D                SCI_TX_READY_NB         EQU     *
                                                              ;Save registers
00F42D 0FF42D 3B                                              PSHD
                                                              ;Check if there is room for this entry
00F42E 0FF42E FC 08 50                                        LDD     SCI_TXBUF_IN            ;in-index in A, out-index in B
00F431 0FF431 42                                              INCA
00F432 0FF432 84 07                                           ANDA    #SCI_TXBUF_MASK
00F434 0FF434 B1 08 51                                        CMPA    SCI_TXBUF_OUT
00F437 0FF437 27 12                                           BEQ     SCI_TX_READY_NB_1                               ;buffer is full
                                                              ;Restore registers
00F439 0FF439 MACRO                                           SSTACK_PREPULL  4
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F439 0FF439 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F43C 0FF43C 18 25 FF 09                                     BLO     OF                                               (SSTACK_PREPULL)
00F440 0FF440 8F 08 21                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F443 0FF443 18 22 FF 08                                     BHI     UF                                               (SSTACK_PREPULL)
00F447 0FF447 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F447 0FF447 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F447 0FF447 3A                                              PULD
                                                              ;Done
00F448 0FF448 14 01                                           SEC
00F44A 0FF44A 3D                                              RTS
                                                              ;TX buffer is full
00F44B 0FF44B MACRO                   SCI_TX_READY_NB_1       SSTACK_PREPULL  4
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F44B 0FF44B 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F44E 0FF44E 18 25 FE F7                                     BLO     OF                                               (SSTACK_PREPULL)
00F452 0FF452 8F 08 21                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F455 0FF455 18 22 FE F6                                     BHI     UF                                               (SSTACK_PREPULL)
00F459 0FF459 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F459 0FF459 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F459 0FF459 3A                                              PULD
                                                              ;Done
00F45A 0FF45A 10 FE                                           CLC
00F45C 0FF45C 3D                                              RTS
                                      ;#Wait until TX queue can hold further data
                                      ; args:   none
                                      ; result: none
                                      ; SSTACK: 6 bytes
                                      ;         X, Y, and D are preserved
00F45D 0FF45D -> $F45D                SCI_TX_READY_BL         EQU     *
00F45D 0FF45D MACRO                                           SCI_MAKE_BL     SCI_TX_READY_NB, 4
                                      ;# Macros for internal use                                                       (SCI_MAKE_BL)
                                      ;#Turn a non-blocking subroutine into a blocking subroutine                      (SCI_MAKE_BL)
                                      ; args:   1: non-blocking function                                               (SCI_MAKE_BL)
                                      ;         2: subroutine stack usage of non-blocking function                     (SCI_MAKE_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (SCI_MAKE_BL)
                                      ;         rgister output of the non-blocking function is preserved               (SCI_MAKE_BL)
                                                              ;Disable interrupts                                      (SCI_MAKE_BL)
00F45D 0FF45D 14 10                   LOOP                    SEI                                                      (SCI_MAKE_BL)
                                                              ;Call non-blocking function                              (SCI_MAKE_BL)
00F45F 0FF45F                                                 //SSTACK_PREPUSH        \2                               (SCI_MAKE_BL)
00F45F 0FF45F 07 CC                                           JOBSR   \1                                               (SCI_MAKE_BL)
00F461 0FF461 24 11                                           BCC     WAIT            ;function unsuccessful           (SCI_MAKE_BL)
                                                              ;Enable interrupts                                       (SCI_MAKE_BL)
00F463 0FF463 10 EF                                           CLI                                                      (SCI_MAKE_BL)
                                                              ;Done                                                    (SCI_MAKE_BL)
00F465 0FF465 MACRO                                           SSTACK_PREPULL  2                                        (SCI_MAKE_BL)
                                      ;#Check stack before pull operation                                              (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; result: none                                                                   (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/SSTACK_PREPULL)
00F465 0FF465 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SCI_MAKE_BL/SSTACK_PREPULL)
00F468 0FF468 18 25 FE DD                                     BLO     OF                                               (SCI_MAKE_BL/SSTACK_PREPULL)
00F46C 0FF46C 8F 08 23                                        CPS     #SSTACK_BOTTOM-\1                                (SCI_MAKE_BL/SSTACK_PREPULL)
00F46F 0FF46F 18 22 FE DC                                     BHI     UF                                               (SCI_MAKE_BL/SSTACK_PREPULL)
00F473 0FF473 -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_MAKE_BL/SSTACK_PREPULL)
00F473 0FF473 -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_MAKE_BL/SSTACK_PREPULL)
00F473 0FF473 3D                                              RTS                                                      (SCI_MAKE_BL)
                                                              ;Wait for next interrupt                                 (SCI_MAKE_BL)
00F474 0FF474 MACRO                   WAIT                    ISTACK_WAIT                                              (SCI_MAKE_BL)
                                      ;#Wait until any interrupt has been serviced                                     (SCI_MAKE_BL/ISTACK_WAIT)
                                      ; args:   none                                                                   (SCI_MAKE_BL/ISTACK_WAIT)
                                      ; ISTACK: none                                                                   (SCI_MAKE_BL/ISTACK_WAIT)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Verify SP before runnung ISRs                           (SCI_MAKE_BL/ISTACK_WAIT)
00F474 0FF474 8F 08 0A                                        CPS     #ISTACK_TOP+ISTACK_FRAME_SIZE                    (SCI_MAKE_BL/ISTACK_WAIT)
00F477 0FF477 18 25 FE DA                                     BLO     OF ;ISTACK_OF                                    (SCI_MAKE_BL/ISTACK_WAIT)
00F47B 0FF47B 8F 08 25                                        CPS     #ISTACK_BOTTOM                                   (SCI_MAKE_BL/ISTACK_WAIT)
00F47E 0FF47E 18 22 FE D9                                     BHI     UF ;ISTACK_UF                                    (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Wait for the next interrupt                             (SCI_MAKE_BL/ISTACK_WAIT)
00F482 0FF482 MACRO                                           COP_SERVICE                     ;already taken care of by WAI (SCI_MAKE_BL/ISTACK_WAIT)
00F482 0FF482 10 EF                                           CLI                                                      (SCI_MAKE_BL/ISTACK_WAIT)
00F484 0FF484 3E                                              WAI                                                      (SCI_MAKE_BL/ISTACK_WAIT)
00F485 0FF485 -> $F355                OF                      EQU     ISTACK_OF                                        (SCI_MAKE_BL/ISTACK_WAIT)
00F485 0FF485 -> $F35B                UF                      EQU     ISTACK_UF                                        (SCI_MAKE_BL/ISTACK_WAIT)
00F485 0FF485 -> $F485                DONE                    EQU     *                                                (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Try again                                               (SCI_MAKE_BL)
00F485 0FF485 MACRO                                           SSTACK_PREPUSH  \2                                       (SCI_MAKE_BL)
                                      ;############################################################################### (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;############################################################################### (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; result: none                                                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/SSTACK_PREPUSH)
00F485 0FF485 8F 08 0E                                        CPS     #SSTACK_TOP+\1                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
00F488 0FF488 18 25 FE BD                                     BLO     OF                                               (SCI_MAKE_BL/SSTACK_PREPUSH)
00F48C 0FF48C 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
00F48F 0FF48F 18 22 FE BC                                     BHI     UF                                               (SCI_MAKE_BL/SSTACK_PREPUSH)
00F493 0FF493 -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
00F493 0FF493 -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
00F493 0FF493 20 C8                                           JOB     LOOP                                             (SCI_MAKE_BL)
                                      ;#Receive one byte - non-blocking ;OK!
                                      ; args:   none
                                      ; result: A:      error flags
                                      ;         B:      received data
                                      ;         C-flag: set if successful
                                      ; SSTACK: 4 bytes
                                      ;         X and Y are preserved
00F495 0FF495 -> $F495                SCI_RX_NB               EQU     *
                                                              ;Save registers
00F495 0FF495 34                                              PSHX
                                                              ;Check if there is data in the RX queue
00F496 0FF496 FC 08 46                                        LDD     SCI_RXBUF_IN                            ;A:B=in:out
00F499 0FF499 18 16                                           SBA                                             ;A=in-out
00F49B 0FF49B 27 26                                           BEQ     SCI_RX_NB_2                             ;RX buffer is empty
00F49D 0FF49D 84 1F                                           ANDA    #SCI_RXBUF_MASK
00F49F 0FF49F 81 04                                           CMPA    #SCI_RX_EMPTY_LEVEL
00F4A1 0FF4A1 27 32                                           BEQ     SCI_RX_NB_3                             ;unblock flow control
                                                              ;Pull entry from the RX queue (out-index in B)
00F4A3 0FF4A3 CE 08 26                SCI_RX_NB_1             LDX     #SCI_RXBUF
00F4A6 0FF4A6 EE E5                                           LDX     B,X
00F4A8 0FF4A8 CB 02                                           ADDB    #$02                                    ;increment out pointer
00F4AA 0FF4AA C4 1F                                           ANDB    #SCI_RXBUF_MASK
00F4AC 0FF4AC 7B 08 47                                        STAB    SCI_RXBUF_OUT
                                                              ;MOVB   #(TXIE|RIE|TE|RE), SCICR2               ;trigger RXTX ISR
00F4AF 0FF4AF B7 54                                           TFR     X, D
                                                              ;Restore registers
00F4B1 0FF4B1 MACRO                                           SSTACK_PREPULL  4
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F4B1 0FF4B1 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F4B4 0FF4B4 18 25 FE 91                                     BLO     OF                                               (SSTACK_PREPULL)
00F4B8 0FF4B8 8F 08 21                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F4BB 0FF4BB 18 22 FE 90                                     BHI     UF                                               (SSTACK_PREPULL)
00F4BF 0FF4BF -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F4BF 0FF4BF -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F4BF 0FF4BF 30                                              PULX
                                                              ;Done
00F4C0 0FF4C0 14 01                                           SEC
00F4C2 0FF4C2 3D                                              RTS
                                                              ;RX buffer is empty (CCR in X)
00F4C3 0FF4C3 MACRO                   SCI_RX_NB_2             SSTACK_PREPULL  4
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F4C3 0FF4C3 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F4C6 0FF4C6 18 25 FE 7F                                     BLO     OF                                               (SSTACK_PREPULL)
00F4CA 0FF4CA 8F 08 21                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F4CD 0FF4CD 18 22 FE 7E                                     BHI     UF                                               (SSTACK_PREPULL)
00F4D1 0FF4D1 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F4D1 0FF4D1 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F4D1 0FF4D1 30                                              PULX
                                                              ;Done
00F4D2 0FF4D2 10 FE                                           CLC
00F4D4 0FF4D4 3D                                              RTS
                                                              ;Unblock flow control (out-index in B, CCR in X)
00F4D5 0FF4D5 -> $F4D5                SCI_RX_NB_3             EQU     *
00F4D5 0FF4D5 MACRO                                           SCI_ASSERT_CTS
00F4D5 0FF4D5 MACRO                                           SCI_SEND_XONXOFF
00F4D5 0FF4D5 20 CC                                           JOB     SCI_RX_NB_1
                                      ;#Receive one byte - blocking
                                      ; args:   none
                                      ; result: A:      error flags
                                      ;         B:      received data
                                      ;         C-flag: set if successful
                                      ; SSTACK: 6 bytes
                                      ;         X and Y are preserved
00F4D7 0FF4D7 -> $F4D7                SCI_RX_BL               EQU     *
00F4D7 0FF4D7 MACRO                                           SCI_MAKE_BL     SCI_RX_NB, 4
                                      ;# Macros for internal use                                                       (SCI_MAKE_BL)
                                      ;#Turn a non-blocking subroutine into a blocking subroutine                      (SCI_MAKE_BL)
                                      ; args:   1: non-blocking function                                               (SCI_MAKE_BL)
                                      ;         2: subroutine stack usage of non-blocking function                     (SCI_MAKE_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (SCI_MAKE_BL)
                                      ;         rgister output of the non-blocking function is preserved               (SCI_MAKE_BL)
                                                              ;Disable interrupts                                      (SCI_MAKE_BL)
00F4D7 0FF4D7 14 10                   LOOP                    SEI                                                      (SCI_MAKE_BL)
                                                              ;Call non-blocking function                              (SCI_MAKE_BL)
00F4D9 0FF4D9                                                 //SSTACK_PREPUSH        \2                               (SCI_MAKE_BL)
00F4D9 0FF4D9 07 BA                                           JOBSR   \1                                               (SCI_MAKE_BL)
00F4DB 0FF4DB 24 11                                           BCC     WAIT            ;function unsuccessful           (SCI_MAKE_BL)
                                                              ;Enable interrupts                                       (SCI_MAKE_BL)
00F4DD 0FF4DD 10 EF                                           CLI                                                      (SCI_MAKE_BL)
                                                              ;Done                                                    (SCI_MAKE_BL)
00F4DF 0FF4DF MACRO                                           SSTACK_PREPULL  2                                        (SCI_MAKE_BL)
                                      ;#Check stack before pull operation                                              (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; result: none                                                                   (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/SSTACK_PREPULL)
00F4DF 0FF4DF 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SCI_MAKE_BL/SSTACK_PREPULL)
00F4E2 0FF4E2 18 25 FE 63                                     BLO     OF                                               (SCI_MAKE_BL/SSTACK_PREPULL)
00F4E6 0FF4E6 8F 08 23                                        CPS     #SSTACK_BOTTOM-\1                                (SCI_MAKE_BL/SSTACK_PREPULL)
00F4E9 0FF4E9 18 22 FE 62                                     BHI     UF                                               (SCI_MAKE_BL/SSTACK_PREPULL)
00F4ED 0FF4ED -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_MAKE_BL/SSTACK_PREPULL)
00F4ED 0FF4ED -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_MAKE_BL/SSTACK_PREPULL)
00F4ED 0FF4ED 3D                                              RTS                                                      (SCI_MAKE_BL)
                                                              ;Wait for next interrupt                                 (SCI_MAKE_BL)
00F4EE 0FF4EE MACRO                   WAIT                    ISTACK_WAIT                                              (SCI_MAKE_BL)
                                      ;#Wait until any interrupt has been serviced                                     (SCI_MAKE_BL/ISTACK_WAIT)
                                      ; args:   none                                                                   (SCI_MAKE_BL/ISTACK_WAIT)
                                      ; ISTACK: none                                                                   (SCI_MAKE_BL/ISTACK_WAIT)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Verify SP before runnung ISRs                           (SCI_MAKE_BL/ISTACK_WAIT)
00F4EE 0FF4EE 8F 08 0A                                        CPS     #ISTACK_TOP+ISTACK_FRAME_SIZE                    (SCI_MAKE_BL/ISTACK_WAIT)
00F4F1 0FF4F1 18 25 FE 60                                     BLO     OF ;ISTACK_OF                                    (SCI_MAKE_BL/ISTACK_WAIT)
00F4F5 0FF4F5 8F 08 25                                        CPS     #ISTACK_BOTTOM                                   (SCI_MAKE_BL/ISTACK_WAIT)
00F4F8 0FF4F8 18 22 FE 5F                                     BHI     UF ;ISTACK_UF                                    (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Wait for the next interrupt                             (SCI_MAKE_BL/ISTACK_WAIT)
00F4FC 0FF4FC MACRO                                           COP_SERVICE                     ;already taken care of by WAI (SCI_MAKE_BL/ISTACK_WAIT)
00F4FC 0FF4FC 10 EF                                           CLI                                                      (SCI_MAKE_BL/ISTACK_WAIT)
00F4FE 0FF4FE 3E                                              WAI                                                      (SCI_MAKE_BL/ISTACK_WAIT)
00F4FF 0FF4FF -> $F355                OF                      EQU     ISTACK_OF                                        (SCI_MAKE_BL/ISTACK_WAIT)
00F4FF 0FF4FF -> $F35B                UF                      EQU     ISTACK_UF                                        (SCI_MAKE_BL/ISTACK_WAIT)
00F4FF 0FF4FF -> $F4FF                DONE                    EQU     *                                                (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Try again                                               (SCI_MAKE_BL)
00F4FF 0FF4FF MACRO                                           SSTACK_PREPUSH  \2                                       (SCI_MAKE_BL)
                                      ;############################################################################### (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;############################################################################### (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; result: none                                                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/SSTACK_PREPUSH)
00F4FF 0FF4FF 8F 08 0E                                        CPS     #SSTACK_TOP+\1                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
00F502 0FF502 18 25 FE 43                                     BLO     OF                                               (SCI_MAKE_BL/SSTACK_PREPUSH)
00F506 0FF506 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
00F509 0FF509 18 22 FE 42                                     BHI     UF                                               (SCI_MAKE_BL/SSTACK_PREPUSH)
00F50D 0FF50D -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
00F50D 0FF50D -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
00F50D 0FF50D 20 C8                                           JOB     LOOP                                             (SCI_MAKE_BL)
                                      ;#Check if there is data in the RX queue
                                      ; args:   none
                                      ; result: C-flag: set if successful
                                      ; SSTACK: 4 bytes
                                      ;         X, Y and D are preserved
00F50F 0FF50F -> $F50F                SCI_RX_READY_NB         EQU     *
                                                              ;Save registers
00F50F 0FF50F 3B                                              PSHD
                                                              ;Check if there is data in the RX queue
00F510 0FF510 FC 08 46                                        LDD     SCI_RXBUF_IN            ;A:B=in:out
00F513 0FF513 18 17                                           CBA
00F515 0FF515 27 12                                           BEQ     SCI_RX_READY_NB_1
                                                              ;RX buffer holds data
00F517 0FF517 MACRO                                           SSTACK_PREPULL  4
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F517 0FF517 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F51A 0FF51A 18 25 FE 2B                                     BLO     OF                                               (SSTACK_PREPULL)
00F51E 0FF51E 8F 08 21                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F521 0FF521 18 22 FE 2A                                     BHI     UF                                               (SSTACK_PREPULL)
00F525 0FF525 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F525 0FF525 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F525 0FF525 3A                                              PULD
                                                              ;Done
00F526 0FF526 14 01                                           SEC
00F528 0FF528 3D                                              RTS
                                                              ;RX buffer is empty
00F529 0FF529 MACRO                   SCI_RX_READY_NB_1       SSTACK_PREPULL  4
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F529 0FF529 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F52C 0FF52C 18 25 FE 19                                     BLO     OF                                               (SSTACK_PREPULL)
00F530 0FF530 8F 08 21                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F533 0FF533 18 22 FE 18                                     BHI     UF                                               (SSTACK_PREPULL)
00F537 0FF537 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F537 0FF537 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F537 0FF537 3A                                              PULD
                                                              ;Done
00F538 0FF538 10 FE                                           CLC
00F53A 0FF53A 3D                                              RTS
                                      ;#Wait until there is data in the RX queue
                                      ; args:   none
                                      ; result: C-flag: set if successful
                                      ; SSTACK: 4 bytes
                                      ;         X, Y and D are preserved
00F53B 0FF53B -> $F53B                SCI_RX_READY_BL         EQU     *
00F53B 0FF53B MACRO                                           SCI_MAKE_BL     SCI_RX_READY_BL, 4
                                      ;# Macros for internal use                                                       (SCI_MAKE_BL)
                                      ;#Turn a non-blocking subroutine into a blocking subroutine                      (SCI_MAKE_BL)
                                      ; args:   1: non-blocking function                                               (SCI_MAKE_BL)
                                      ;         2: subroutine stack usage of non-blocking function                     (SCI_MAKE_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (SCI_MAKE_BL)
                                      ;         rgister output of the non-blocking function is preserved               (SCI_MAKE_BL)
                                                              ;Disable interrupts                                      (SCI_MAKE_BL)
00F53B 0FF53B 14 10                   LOOP                    SEI                                                      (SCI_MAKE_BL)
                                                              ;Call non-blocking function                              (SCI_MAKE_BL)
00F53D 0FF53D                                                 //SSTACK_PREPUSH        \2                               (SCI_MAKE_BL)
00F53D 0FF53D 07 FC                                           JOBSR   \1                                               (SCI_MAKE_BL)
00F53F 0FF53F 24 11                                           BCC     WAIT            ;function unsuccessful           (SCI_MAKE_BL)
                                                              ;Enable interrupts                                       (SCI_MAKE_BL)
00F541 0FF541 10 EF                                           CLI                                                      (SCI_MAKE_BL)
                                                              ;Done                                                    (SCI_MAKE_BL)
00F543 0FF543 MACRO                                           SSTACK_PREPULL  2                                        (SCI_MAKE_BL)
                                      ;#Check stack before pull operation                                              (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; result: none                                                                   (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SCI_MAKE_BL/SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/SSTACK_PREPULL)
00F543 0FF543 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SCI_MAKE_BL/SSTACK_PREPULL)
00F546 0FF546 18 25 FD FF                                     BLO     OF                                               (SCI_MAKE_BL/SSTACK_PREPULL)
00F54A 0FF54A 8F 08 23                                        CPS     #SSTACK_BOTTOM-\1                                (SCI_MAKE_BL/SSTACK_PREPULL)
00F54D 0FF54D 18 22 FD FE                                     BHI     UF                                               (SCI_MAKE_BL/SSTACK_PREPULL)
00F551 0FF551 -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_MAKE_BL/SSTACK_PREPULL)
00F551 0FF551 -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_MAKE_BL/SSTACK_PREPULL)
00F551 0FF551 3D                                              RTS                                                      (SCI_MAKE_BL)
                                                              ;Wait for next interrupt                                 (SCI_MAKE_BL)
00F552 0FF552 MACRO                   WAIT                    ISTACK_WAIT                                              (SCI_MAKE_BL)
                                      ;#Wait until any interrupt has been serviced                                     (SCI_MAKE_BL/ISTACK_WAIT)
                                      ; args:   none                                                                   (SCI_MAKE_BL/ISTACK_WAIT)
                                      ; ISTACK: none                                                                   (SCI_MAKE_BL/ISTACK_WAIT)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Verify SP before runnung ISRs                           (SCI_MAKE_BL/ISTACK_WAIT)
00F552 0FF552 8F 08 0A                                        CPS     #ISTACK_TOP+ISTACK_FRAME_SIZE                    (SCI_MAKE_BL/ISTACK_WAIT)
00F555 0FF555 18 25 FD FC                                     BLO     OF ;ISTACK_OF                                    (SCI_MAKE_BL/ISTACK_WAIT)
00F559 0FF559 8F 08 25                                        CPS     #ISTACK_BOTTOM                                   (SCI_MAKE_BL/ISTACK_WAIT)
00F55C 0FF55C 18 22 FD FB                                     BHI     UF ;ISTACK_UF                                    (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Wait for the next interrupt                             (SCI_MAKE_BL/ISTACK_WAIT)
00F560 0FF560 MACRO                                           COP_SERVICE                     ;already taken care of by WAI (SCI_MAKE_BL/ISTACK_WAIT)
00F560 0FF560 10 EF                                           CLI                                                      (SCI_MAKE_BL/ISTACK_WAIT)
00F562 0FF562 3E                                              WAI                                                      (SCI_MAKE_BL/ISTACK_WAIT)
00F563 0FF563 -> $F355                OF                      EQU     ISTACK_OF                                        (SCI_MAKE_BL/ISTACK_WAIT)
00F563 0FF563 -> $F35B                UF                      EQU     ISTACK_UF                                        (SCI_MAKE_BL/ISTACK_WAIT)
00F563 0FF563 -> $F563                DONE                    EQU     *                                                (SCI_MAKE_BL/ISTACK_WAIT)
                                                              ;Try again                                               (SCI_MAKE_BL)
00F563 0FF563 MACRO                                           SSTACK_PREPUSH  \2                                       (SCI_MAKE_BL)
                                      ;############################################################################### (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;############################################################################### (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; result: none                                                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (SCI_MAKE_BL/SSTACK_PREPUSH)
00F563 0FF563 8F 08 0E                                        CPS     #SSTACK_TOP+\1                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
00F566 0FF566 18 25 FD DF                                     BLO     OF                                               (SCI_MAKE_BL/SSTACK_PREPUSH)
00F56A 0FF56A 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (SCI_MAKE_BL/SSTACK_PREPUSH)
00F56D 0FF56D 18 22 FD DE                                     BHI     UF                                               (SCI_MAKE_BL/SSTACK_PREPUSH)
00F571 0FF571 -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
00F571 0FF571 -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_MAKE_BL/SSTACK_PREPUSH)
00F571 0FF571 20 C8                                           JOB     LOOP                                             (SCI_MAKE_BL)
                                      ;#Set baud rate
                                      ; args:   D: new SCIBD value
                                      ; result: none
                                      ; SSTACK: 6 bytes
                                      ;         X, Y, and D are preserved
00F573 0FF573 -> $F573                SCI_SET_BAUD            EQU     *
                                                              ;Save registers (new SCIBD value in D)
00F573 0FF573 35                                              PSHY                                    ;push Y onto the SSTACK
00F574 0FF574 3B                                              PSHD                                    ;push D onto the SSTACK
                                                              ;Set baud rate (new SCIBD value in D)
00F575 0FF575 5C C0                                           STD     SCIBDH                          ;set baud rate
00F577 0FF577 CD 0C CC                                        LDY     #SCI_BMUL                       ;save baud rate for next warmstart
00F57A 0FF57A 13                                              EMUL                                    ;D*Y -> Y:D
00F57B 0FF57B 7C 08 52                                        STD     SCI_BVAL
                                                              ;Clear input buffer
00F57E 0FF57E 18 03 00 00 08 46                               MOVW    #$0000, SCI_RXBUF_IN            ;reset in and out pointer of the RX buffer
                                                              ;Restore registers
00F584 0FF584 MACRO                                           SSTACK_PREPULL  6
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F584 0FF584 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F587 0FF587 18 25 FD BE                                     BLO     OF                                               (SSTACK_PREPULL)
00F58B 0FF58B 8F 08 1F                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F58E 0FF58E 18 22 FD BD                                     BHI     UF                                               (SSTACK_PREPULL)
00F592 0FF592 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F592 0FF592 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F592 0FF592 3A                                              PULD                                    ;pull D from the SSTACK
00F593 0FF593 31                                              PULY                                    ;pull Y from the SSTACK
                                                              ;Done
00F594 0FF594 3D                                              RTS
                                      ;#Timer delay
                                      ; period: approx. 2 SCI frames
                                      ; RTS/CTS:    if RTL polling is requested (SCI_FLG_POLL_RTS) -> enable TX IRQ
                                      ; XON/XOFF:   if reminder count == 1 -> request XON/XOFF reminder, enable TX IRQ
                                      ;             if reminder count > 1  -> decrement reminder count, retrigger delay
                                      ; workaround: retrigger delay, jump to SCI_ISR_RXTX
00F595 0FF595 -> $F595                SCI_ISR_DELAY           EQU     *
00F595 0FF595 10 FE                                           CLC                                                             ;don't retrigger
                                                              ;Retrigger if required (retrigger request in C-flag)
00F597 0FF597 24 22                                           BCC     SCI_ISR_DELAY_7
00F599 0FF599 MACRO                                           SCI_RESET_DELAY
                                      ;#ReSET delay (approx. 2 SCI frames)                                             (SCI_RESET_DELAY)
                                      ; args:   none                                                                   (SCI_RESET_DELAY)
                                      ; SSTACK: none                                                                   (SCI_RESET_DELAY)
                                      ;         X, and Y are preserved                                                 (SCI_RESET_DELAY)
00F599 0FF599 MACRO                                           TIM_CLRIF       SCI_DLY_OC                               (SCI_RESET_DELAY)
                                      ;#Clear one interrupt flag                                                       (SCI_RESET_DELAY/TIM_CLRIF)
                                      ; args: 1: channel number                                                        (SCI_RESET_DELAY/TIM_CLRIF)
                                      ; SSTACK: none                                                                   (SCI_RESET_DELAY/TIM_CLRIF)
                                      ;         X, Y, and D are preserved                                              (SCI_RESET_DELAY/TIM_CLRIF)
00F599 0FF599 MACRO                                           TIM_MULT_CLRIF  (1<<\1)                                  (SCI_RESET_DELAY/TIM_CLRIF)
                                      ;#Clear multiple interrupt flags                                                 (SCI_RESET_DELAY/TIM_CLRIF/TIM_MULT_CLRIF)
                                      ; args: 1: channel mask                                                          (SCI_RESET_DELAY/TIM_CLRIF/TIM_MULT_CLRIF)
                                      ; SSTACK: none                                                                   (SCI_RESET_DELAY/TIM_CLRIF/TIM_MULT_CLRIF)
                                      ;         X, Y, and D are preserved                                              (SCI_RESET_DELAY/TIM_CLRIF/TIM_MULT_CLRIF)
00F599 0FF599 18 0B 08 00 8E                                  MOVB    #\1, TFLG1                                       (SCI_RESET_DELAY/TIM_CLRIF/TIM_MULT_CLRIF)
00F59E 0FF59E DC C0                                           LDD     SCIBDH                                  ;retrigger delay (SCI_RESET_DELAY)
00F5A0 0FF5A0 04 60 07                                        TBNE    A, MAX_DELAY                            ;max. delay ($FFFF) exceeded (SCI_RESET_DELAY)
00F5A3 0FF5A3 B7 10                                           TFR     B, A                                    ;determine delay (SCI_RESET_DELAY)
00F5A5 0FF5A5 C7                                              CLRB                                                     (SCI_RESET_DELAY)
00F5A6 0FF5A6 MACRO                                           TIM_SET_DLY_D   SCI_DLY_OC                      ;update OC count (SCI_RESET_DELAY)
                                      ;#Setup timer delay                                                              (SCI_RESET_DELAY/TIM_SET_DLY_D)
                                      ; args: 1: channel number                                                        (SCI_RESET_DELAY/TIM_SET_DLY_D)
                                      ;       D: delay (in bus cycles)                                                 (SCI_RESET_DELAY/TIM_SET_DLY_D)
                                      ; SSTACK: none                                                                   (SCI_RESET_DELAY/TIM_SET_DLY_D)
                                      ;         X, and Y are preserved                                                 (SCI_RESET_DELAY/TIM_SET_DLY_D)
00F5A6 0FF5A6 D3 84                                           ADDD    TCNT                                             (SCI_RESET_DELAY/TIM_SET_DLY_D)
00F5A8 0FF5A8 5C 96                                           STD     (TC0+(2*\1))                                     (SCI_RESET_DELAY/TIM_SET_DLY_D)
00F5AA 0FF5AA -> $F5AA                MAX_DELAY               EQU     *                                                (SCI_RESET_DELAY)
00F5AA 0FF5AA MACRO                   SCI_ISR_DELAY_6         ISTACK_RTI
                                      ;#Return from interrupt                                                          (ISTACK_RTI)
                                      ; args:   none                                                                   (ISTACK_RTI)
                                      ; ISTACK: -9 (S12)/-10 (S12X)                                                    (ISTACK_RTI)
                                      ;         X, Y, and D are pulled from the interrupt stack                        (ISTACK_RTI)
                                                              ;Verify SP at the end of each ISR                        (ISTACK_RTI)
00F5AA 0FF5AA 8F 08 00                                        CPS     #ISTACK_TOP                                      (ISTACK_RTI)
00F5AD 0FF5AD 25 06                                           BLO     OF                                               (ISTACK_RTI)
00F5AF 0FF5AF 8F 08 1B                                        CPS     #ISTACK_BOTTOM-ISTACK_FRAME_SIZE                 (ISTACK_RTI)
00F5B2 0FF5B2 22 04                                           BHI     UF                                               (ISTACK_RTI)
                                                              ;End ISR                                                 (ISTACK_RTI)
00F5B4 0FF5B4 0B                                              RTI                                                      (ISTACK_RTI)
00F5B5 0FF5B5 06 F3 55                OF                      JOB     ISTACK_OF                                        (ISTACK_RTI)
00F5B8 0FF5B8 06 F3 5B                UF                      JOB     ISTACK_UF                                        (ISTACK_RTI)
00F5BB 0FF5BB MACRO                   SCI_ISR_DELAY_7         SCI_STOP_DELAY
                                      ;#Stop delay (approx. 2 SCI frames)                                              (SCI_STOP_DELAY)
                                      ; args:   none                                                                   (SCI_STOP_DELAY)
                                      ; SSTACK: none                                                                   (SCI_STOP_DELAY)
                                      ;         X, Y, and D are preserved                                              (SCI_STOP_DELAY)
00F5BB 0FF5BB MACRO                                           TIM_DIS         SCI_DLY_OC                               (SCI_STOP_DELAY)
                                      ;#Disable one timer channel                                                      (SCI_STOP_DELAY/TIM_DIS)
                                      ; args: 1: channel number                                                        (SCI_STOP_DELAY/TIM_DIS)
                                      ; SSTACK: none                                                                   (SCI_STOP_DELAY/TIM_DIS)
                                      ;         X, Y, and D are preserved                                              (SCI_STOP_DELAY/TIM_DIS)
00F5BB 0FF5BB MACRO                                           TIM_MULT_DIS    (1<<\1)                                  (SCI_STOP_DELAY/TIM_DIS)
                                      ;#Disable multiple timer channels                                                (SCI_STOP_DELAY/TIM_DIS/TIM_MULT_DIS)
                                      ; args: 1: channel mask                                                          (SCI_STOP_DELAY/TIM_DIS/TIM_MULT_DIS)
                                      ; SSTACK: none                                                                   (SCI_STOP_DELAY/TIM_DIS/TIM_MULT_DIS)
                                      ;         X, Y, and D are preserved                                              (SCI_STOP_DELAY/TIM_DIS/TIM_MULT_DIS)
00F5BB 0FF5BB 4D 8C 08                                        BCLR    TIE, #\1                                         (SCI_STOP_DELAY/TIM_DIS/TIM_MULT_DIS)
00F5BE 0FF5BE 26 03                                           BNE     DONE                                             (SCI_STOP_DELAY/TIM_DIS/TIM_MULT_DIS)
00F5C0 0FF5C0 79 00 86                                        CLR     TSCR1                                            (SCI_STOP_DELAY/TIM_DIS/TIM_MULT_DIS)
00F5C3 0FF5C3 -> $F5C3                DONE                    EQU     *                                                (SCI_STOP_DELAY/TIM_DIS/TIM_MULT_DIS)
00F5C3 0FF5C3 -> $F5C3                                        EQU     *                                                (SCI_STOP_DELAY)
00F5C3 0FF5C3 20 E5                                           JOB     SCI_ISR_DELAY_6
                                                              ;#Transmit ISR (status flags in A)
00F5C5 0FF5C5 -> $F5C5                SCI_ISR_TX              EQU     *
00F5C5 0FF5C5 85 80                                           BITA    #TDRE                                   ;check if SCI is ready for new TX data
00F5C7 0FF5C7 27 1E                                           BEQ     <SCI_ISR_TX_4                           ;done for now
                                                              ;Check TX buffer
00F5C9 0FF5C9 FC 08 50                SCI_ISR_TX_1            LDD     SCI_TXBUF_IN
00F5CC 0FF5CC 18 17                                           CBA
00F5CE 0FF5CE 27 12                                           BEQ     <SCI_ISR_TX_3                           ;stop transmitting
                                                              ;Transmit data (in-index in A, out-index in B)
00F5D0 0FF5D0 CD 08 48                                        LDY     #SCI_TXBUF
00F5D3 0FF5D3 18 0D ED 00 C7                                  MOVB    B,Y ,SCIDRL
                                                              ;Increment index
00F5D8 0FF5D8 52                                              INCB
00F5D9 0FF5D9 C4 07                                           ANDB    #SCI_TXBUF_MASK
00F5DB 0FF5DB 7B 08 51                                        STAB    SCI_TXBUF_OUT
00F5DE 0FF5DE 18 17                                           CBA
00F5E0 0FF5E0 26 05                                           BNE     <SCI_ISR_TX_4                           ;done
                                                              ;Stop transmitting
00F5E2 0FF5E2 -> $F5E2                SCI_ISR_TX_3            EQU     *
00F5E2 0FF5E2 18 0B 2C 00 C3                                  MOVB    #(RIE|TE|RE), SCICR2                    ;disable TX interrupts
                                                              ;Done
00F5E7 0FF5E7 MACRO                   SCI_ISR_TX_4            ISTACK_RTI
                                      ;#Return from interrupt                                                          (ISTACK_RTI)
                                      ; args:   none                                                                   (ISTACK_RTI)
                                      ; ISTACK: -9 (S12)/-10 (S12X)                                                    (ISTACK_RTI)
                                      ;         X, Y, and D are pulled from the interrupt stack                        (ISTACK_RTI)
                                                              ;Verify SP at the end of each ISR                        (ISTACK_RTI)
00F5E7 0FF5E7 8F 08 00                                        CPS     #ISTACK_TOP                                      (ISTACK_RTI)
00F5EA 0FF5EA 25 06                                           BLO     OF                                               (ISTACK_RTI)
00F5EC 0FF5EC 8F 08 1B                                        CPS     #ISTACK_BOTTOM-ISTACK_FRAME_SIZE                 (ISTACK_RTI)
00F5EF 0FF5EF 22 04                                           BHI     UF                                               (ISTACK_RTI)
                                                              ;End ISR                                                 (ISTACK_RTI)
00F5F1 0FF5F1 0B                                              RTI                                                      (ISTACK_RTI)
00F5F2 0FF5F2 06 F3 55                OF                      JOB     ISTACK_OF                                        (ISTACK_RTI)
00F5F5 0FF5F5 06 F3 5B                UF                      JOB     ISTACK_UF                                        (ISTACK_RTI)
                                      ;#Receive/Transmit ISR (Common ISR entry point for the SCI)
00F5F8 0FF5F8 -> $F5F8                SCI_ISR_RXTX            EQU     *
                                                              ;Common entry point for all SCI interrupts
                                                              ;Load flags
00F5F8 0FF5F8 96 C4                                           LDAA    SCISR1                                  ;load status flags into accu A
                                                                                                              ;SCI Flag order:
                                                                                                              ; 7:TDRE (Transmit Data Register Empty Flag)
                                                                                                              ; 6:TC   (TransmitCompleteFlag)
                                                                                                              ; 5:RDRF (Receive Data Register Full Flag)
                                                                                                              ; 4:IDLE (Idle Line Flag)
                                                                                                              ; 3:OR   (Overrun Flag)
                                                                                                              ; 2:NF   (Noise Flag)
                                                                                                              ; 1:FE   (Framing Error Flag)
                                                                                                              ; 0:PE   (Parity Error Flag)
                                                              ;Check for RX data (status flags in A)
00F5FA 0FF5FA 85 28                                           BITA    #(RDRF|OR)                              ;go to receive handler if receive buffer
00F5FC 0FF5FC 27 C7                                           BEQ     SCI_ISR_TX                              ; is full or if an overrun has occured
                                      ;#Receive ISR (status flags in A)
00F5FE 0FF5FE D6 C7                   SCI_ISR_RX              LDAB    SCIDRL                                  ;load receive data into accu B (clears flags)
                                                              ;Transfer SWOR flag to current error flags (status flags in A, RX data in B)
00F600 0FF600 84 0F                                           ANDA    #(OR|NF|FE|PF)                          ;only maintain relevant error flags
00F602 0FF602 1F 08 25 10 06                                  BRCLR   SCI_FLGS, #SCI_FLG_SWOR, SCI_ISR_RX_1   ;SWOR bit not set
00F607 0FF607 8A 10                                           ORAA    #SCI_FLG_SWOR                           ;set SWOR bit in accu A
00F609 0FF609 1D 08 25 10                                     BCLR    SCI_FLGS, #SCI_FLG_SWOR                 ;clear SWOR bit in variable
00F60D 0FF60D -> $F60D                SCI_ISR_RX_1            EQU     *
                                                              ;Check for RX errors (status flags in A, RX data in B)
00F60D 0FF60D 85 07                                           BITA    #(NF|FE|PF)                             ;check for: noise, frame errors, parity errors
00F60F 0FF60F 26 3B                                           BNE     <SCI_ISR_RX_8                           ;RX error detected (skip special caracter detection)
                                                              ;No RX error detected (status flags in A, RX data in B)
                                      ;                       DEC     SCI_BD_RECOVCNT                         ;decrement recovery count if >$00
                                      ;                       BCS     <SCI_ISR_RX_2                           ;keep recovery count at $00
                                      ;                       BNE     <SCI_ISR_RX_3                           ;baud rate detection is ongoing
                                      ;                       ;Auto-recover from baud rate detection (status flags in A, RX data in B)
                                      ;                       SCI_ERRSIG_OFF                                  ;clear error signal
                                      ;                       SCI_STOP_BD                                     ;disable baud rate detection
                                      ;SCI_ISR_RX_2           EQU     *-6
                                                              ;Check for control characters (status flags in A, RX data in B)
00F611 0FF611 -> $F611                SCI_ISR_RX_3            EQU     *
00F611 0FF611 1E 08 25 04 04                                  BRSET   SCI_FLGS, #SCI_FLG_RX_ESC, SCI_ISR_RX_4 ;charakter is escaped (skip detection)
00F616 0FF616 C1 1A                                           CMPB    #SCI_SUSPEND
                                                              ;BLE    <SCI_ISR_RX_11                          ;determine control signal
00F618 0FF618 2F 3A                                           BLE     SCI_ISR_RX_11                           ;determine control signal
00F61A 0FF61A 1D 08 25 04             SCI_ISR_RX_4            BCLR    SCI_FLGS, #SCI_FLG_RX_ESC               ;clear escape marker
                                                              ;Place data into RX queue (status flags in A, RX data in B)
00F61E 0FF61E B7 46                   SCI_ISR_RX_5            TFR     D, Y                                    ;flags:data -> Y
00F620 0FF620 CE 08 26                                        LDX     #SCI_RXBUF
00F623 0FF623 FC 08 46                                        LDD     SCI_RXBUF_IN                            ;in:out -> A:B
00F626 0FF626 6D E4                                           STY     A,X
00F628 0FF628 8B 02                                           ADDA    #2
00F62A 0FF62A 84 1F                                           ANDA    #SCI_RXBUF_MASK
00F62C 0FF62C 18 17                                           CBA
00F62E 0FF62E 27 1C                                           BEQ     <SCI_ISR_RX_9                           ;buffer overflow
00F630 0FF630 7A 08 46                                        STAA    SCI_RXBUF_IN                            ;update IN pointer
                                                              ;Check flow control threshold (in:out in D)
00F633 0FF633 18 16                                           SBA
00F635 0FF635 84 1F                                           ANDA    #SCI_RXBUF_MASK
00F637 0FF637 81 10                                           CMPA    #SCI_RX_FULL_LEVEL
00F639 0FF639 24 17                                           BHS     <SCI_ISR_RX_10                          ;buffer is getting full
00F63B 0FF63B -> $F63B                SCI_ISR_RX_6            EQU     *
00F63B 0FF63B -> $F63B                SCI_ISR_RX_7            EQU     *
                                                              ;Done
00F63B 0FF63B MACRO                                           ISTACK_RTI
                                      ;#Return from interrupt                                                          (ISTACK_RTI)
                                      ; args:   none                                                                   (ISTACK_RTI)
                                      ; ISTACK: -9 (S12)/-10 (S12X)                                                    (ISTACK_RTI)
                                      ;         X, Y, and D are pulled from the interrupt stack                        (ISTACK_RTI)
                                                              ;Verify SP at the end of each ISR                        (ISTACK_RTI)
00F63B 0FF63B 8F 08 00                                        CPS     #ISTACK_TOP                                      (ISTACK_RTI)
00F63E 0FF63E 25 06                                           BLO     OF                                               (ISTACK_RTI)
00F640 0FF640 8F 08 1B                                        CPS     #ISTACK_BOTTOM-ISTACK_FRAME_SIZE                 (ISTACK_RTI)
00F643 0FF643 22 04                                           BHI     UF                                               (ISTACK_RTI)
                                                              ;End ISR                                                 (ISTACK_RTI)
00F645 0FF645 0B                                              RTI                                                      (ISTACK_RTI)
00F646 0FF646 06 F3 55                OF                      JOB     ISTACK_OF                                        (ISTACK_RTI)
00F649 0FF649 06 F3 5B                UF                      JOB     ISTACK_UF                                        (ISTACK_RTI)
                                                              ;RX error detected (status flags in A, RX data in B)
00F64C 0FF64C MACRO                   SCI_ISR_RX_8            SCI_ERRSIG_ON
00F64C 0FF64C MACRO                                           SCI_START_BD
                                                              ;Buffer overflow
00F64C 0FF64C 1C 08 25 10             SCI_ISR_RX_9            BSET    SCI_FLGS, #SCI_FLG_SWOR                 ;set overflow flag
00F650 0FF650 20 E9                                           JOB     SCI_ISR_RX_6                            ;done
                                                              ;RX buffer is getting full
00F652 0FF652 MACRO                   SCI_ISR_RX_10           SCI_DEASSERT_CTS
00F652 0FF652 MACRO                                           SCI_SEND_XONXOFF
00F652 0FF652 20 E7                                           JOB     SCI_ISR_RX_6                            ;done
                                                              ;Determine control signal (status flags in A, RX data in B)
00F654 0FF654 -> $F654                SCI_ISR_RX_11           EQU     *
                                                              ;Check for SUSPEND (status flags in A, RX data in B)
00F654 0FF654 C1 1A                                           CMPB    #SCI_SUSPEND
00F656 0FF656 26 07                                           BNE     <SCI_ISR_RX_14                          ;determine control signal
00F658 0FF658 MACRO                                           SCI_SUSPEND_ACTION
                                      ;Suspend handler                                                                 (SCI_SUSPEND_ACTION)
00F658 0FF658 18 0B 50 00 AE                                  MOVB    #$50, PORTT                                      (SCI_SUSPEND_ACTION)
00F65D 0FF65D 20 DC                                           JOB     SCI_ISR_RX_6                            ;done
00F65F 0FF65F -> $F65F                SCI_ISR_RX_14           EQU     *
                                                              ;Check for BREAK (status flags in A, RX data in B)
00F65F 0FF65F C1 03                                           CMPB    #SCI_BREAK
00F661 0FF661 26 05                                           BNE     <SCI_ISR_RX_15                          ;determine control signal
00F663 0FF663 MACRO                                           SCI_BREAK_ACTION
                                      ;############################################################################### (SCI_BREAK_ACTION)
                                      ;# Macros                                                                      # (SCI_BREAK_ACTION)
                                      ;###############################################################################;Break handler (SCI_BREAK_ACTION)
00F663 0FF663 18 0B A0 00 AE                                  MOVB    #$A0, PORTT                                      (SCI_BREAK_ACTION)
00F668 0FF668 C1 10                   SCI_ISR_RX_15           CMPB    #SCI_DLE
00F66A 0FF66A 26 04                                           BNE     <SCI_ISR_RX_16                          ;done
00F66C 0FF66C 1C 08 25 04                                     BSET    SCI_FLGS, #SCI_FLG_RX_ESC               ;set escape marker
00F670 0FF670 20 C9                   SCI_ISR_RX_16           JOB     SCI_ISR_RX_6                            ;done
00F672 0FF672 -> $F672                SCI_CODE_END            EQU     *
00F672 0FF672 -> $FF672               SCI_CODE_END_LIN        EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F8FE 0FF8FE                                                 ORG     SCI_TABS_START, SCI_TABS_START_LIN
00F8FE 0FF8FE                                                 ALIGN   1
                                                              ;List of prescaler values
00F8FE 0FF8FE -> $F8FE                SCI_BTAB                EQU     *
00F8FE 0FF8FE 02 8B                                           DW      SCI_4800
00F900 0FF900 01 B2                                           DW      SCI_7200
00F902 0FF902 01 46                                           DW      SCI_9600
00F904 0FF904 00 D9                                           DW      SCI_14400
00F906 0FF906 00 A3                                           DW      SCI_19200
00F908 0FF908 00 6D                                           DW      SCI_28800
00F90A 0FF90A 00 51                                           DW      SCI_38400
00F90C 0FF90C 00 36                                           DW      SCI_57600
00F90E 0FF90E -> $F90E                SCI_BTAB_END            EQU     *
00F90E 0FF90E -> $F90E                SCI_TABS_END            EQU     *
00F90E 0FF90E -> $FF90E               SCI_TABS_END_LIN        EQU     @
                                      ;###############################################################################
                                      ;# S12CBase - STRING - String Printing routines                                #
                                      ;###############################################################################
                                      ;#    Copyright 2010 Dirk Heisswolf                                            #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    This module implements various print routines for the SCI driver:        #
                                      ;#    STRING_PRINT_NB  - print a string (non-blocking)                         #
                                      ;#    STRING_PRINT_BL  - print a string (blocking)                             #
                                      ;#    STRING_FILL_NB   - print a number of filler characters (non-blocking)    #
                                      ;#    STRING_FILL_BL   - print a number of filler characters (blocking)        #
                                      ;#    STRING_UPPER_B   - convert a character to upper case                     #
                                      ;#    STRING_LOWER_B   - convert a character to lower case                     #
                                      ;#                                                                             #
                                      ;#    Each of these functions has a coresponding macro definition              #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    SCI    - SCI driver                                                      #
                                      ;#    SSTACK - Subroutine Stack Handler                                        #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - none                                                                   #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    Apr  4, 2010                                                             #
                                      ;#      - Initial release                                                      #
                                      ;#    Apr 29, 2010                                                             #
                                      ;#      - Added macros "STRING_UPPER_B" and "STRING_LOWER_B"                   #
                                      ;#    Jul 29, 2010                                                             #
                                      ;#      - fixed STRING_SINTCNT                                                 #
                                      ;#    July 2, 2012                                                             #
                                      ;#      - Added support for linear PC                                          #
                                      ;#      - Added non-blocking functions                                         #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Configuration                                                               #
                                      ;###############################################################################
                                      ;Blocking subroutines
                                      ;--------------------
                                      ;Enable blocking subroutines
00F90E 0FF90E -> $0001                STRING_BLOCKING_OFF     EQU     1       ;blocking functions disabled by default
                                      ;###############################################################################
                                      ;# Constants                                                                   #
                                      ;###############################################################################
                                      ;#ASCII code
00F90E 0FF90E -> $0007                STRING_SYM_BEEP         EQU     $07     ;acoustic signal
00F90E 0FF90E -> $0008                STRING_SYM_BACKSPACE    EQU     $08     ;backspace symbol
00F90E 0FF90E -> $0009                STRING_SYM_TAB          EQU     $09     ;tab symbol
00F90E 0FF90E -> $000A                STRING_SYM_LF           EQU     $0A     ;line feed symbol
00F90E 0FF90E -> $000D                STRING_SYM_CR           EQU     $0D     ;carriage return symbol
00F90E 0FF90E -> $0020                STRING_SYM_SPACE        EQU     $20     ;space (first printable ASCII character)
00F90E 0FF90E -> $007E                STRING_SYM_TILDE        EQU     $7E     ;"~" (last printable ASCII character)
00F90E 0FF90E -> $007F                STRING_SYM_DEL          EQU     $7F     ;delete symbol
                                      ;#String ternination
00F90E 0FF90E -> $0080                STRING_STRING_TERM      EQU     $80     ;MSB for string termination
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000855 0F4855                                                 ORG     STRING_VARS_START, STRING_VARS_START_LIN
000855 0F4855 -> $0855                STRING_VARS_END         EQU     *
000855 0F4855 -> $F4855               STRING_VARS_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F672 0FF672                                                 ORG     STRING_CODE_START, STRING_CODE_START_LIN
                                      ;#Basic print function - non-blocking
                                      ; args:   X:      start of the string
                                      ; result: X;      remaining string (points to the byte after the string, if successful)
                                      ;         C-flag: set if successful
                                      ; SSTACK: 8 bytes
                                      ;         Y and D are preserved
00F672 0FF672 -> $F672                STRING_PRINT_NB         EQU     *
                                                              ;Save registers (string pointer in X)
00F672 0FF672 37                                              PSHB                            ;save B
                                                              ;Print characters (string pointer in X)
00F673 0FF673 E6 30                   STRING_PRINT_NB_1       LDAB    1,X+                    ;get next ASCII character
00F675 0FF675 2B 19                                           BMI     STRING_PRINT_NB_3       ;last character
00F677 0FF677 16 F3 61                                        JOBSR   SCI_TX_NB               ;print character non blocking (SSTACK: 5 bytes)
00F67A 0FF67A 25 F7                                           BCS     STRING_PRINT_NB_1
                                                              ;Adjust string pointer (next string pointer in X)
00F67C 0FF67C 1A 1F                   STRING_PRINT_NB_2       LEAX    -1,X
                                                              ;Restore registers (string pointer in X)
00F67E 0FF67E MACRO                                           SSTACK_PREPULL  3
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F67E 0FF67E 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F681 0FF681 18 25 FC C4                                     BLO     OF                                               (SSTACK_PREPULL)
00F685 0FF685 8F 08 22                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F688 0FF688 18 22 FC C3                                     BHI     UF                                               (SSTACK_PREPULL)
00F68C 0FF68C -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F68C 0FF68C -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F68C 0FF68C 33                                              PULB
                                                              ;Signal failure (string pointer in X)
00F68D 0FF68D 10 FE                                           CLC
                                                              ;Done
00F68F 0FF68F 3D                                              RTS
                                                              ;Print last character (next string pointer in X, last char in B)
00F690 0FF690 C4 7F                   STRING_PRINT_NB_3       ANDB    #$7F                    ;remove termination bit
00F692 0FF692 16 F3 61                                        JOBSR   SCI_TX_NB               ;print character non blocking (SSTACK: 5 bytes)
00F695 0FF695 24 E5                                           BCC     STRING_PRINT_NB_2
                                                              ;Restore registers (next string pointer in X)
00F697 0FF697 MACRO                                           SSTACK_PREPULL  3
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F697 0FF697 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F69A 0FF69A 18 25 FC AB                                     BLO     OF                                               (SSTACK_PREPULL)
00F69E 0FF69E 8F 08 22                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F6A1 0FF6A1 18 22 FC AA                                     BHI     UF                                               (SSTACK_PREPULL)
00F6A5 0FF6A5 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F6A5 0FF6A5 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F6A5 0FF6A5 33                                              PULB
                                                              ;Signal success (next string pointer in X)
00F6A6 0FF6A6 14 01                                           SEC
                                                              ;Done
00F6A8 0FF6A8 3D                                              RTS
                                      ;#Basic print function - blocking
                                      ; args:   X:      start of the string
                                      ; result: X;      points to the byte after the string
                                      ; SSTACK: 10 bytes
                                      ;         Y and D are preserved
                                      ;#Print a number of filler characters - non-blocking
                                      ; args:   A: number of characters to be printed
                                      ;         B: filler character
                                      ; result: A: remaining space characters to be printed (0 if successfull)
                                      ;         C-flag: set if successful
                                      ; result: none
                                      ; SSTACK: 7 bytes
                                      ;         X, Y and B are preserved
00F6A9 0FF6A9 -> $F6A9                STRING_FILL_NB  EQU     *
                                                              ;Print characters (requested spaces in A)
00F6A9 0FF6A9 04 40 08                                        TBEQ    A, STRING_FILL_NB_2     ;nothing to do
00F6AC 0FF6AC 16 F3 61                STRING_FILL_NB_1        JOBSR   SCI_TX_NB               ;print character non blocking (SSTACK: 5 bytes)
00F6AF 0FF6AF 24 14                                           BCC     STRING_FILL_NB_3        ;unsuccessful
00F6B1 0FF6B1 04 30 F8                                        DBNE    A, STRING_FILL_NB_1
                                                              ;Restore registers (remaining spaces in A)
00F6B4 0FF6B4 MACRO                   STRING_FILL_NB_2        SSTACK_PREPULL  2
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F6B4 0FF6B4 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F6B7 0FF6B7 18 25 FC 8E                                     BLO     OF                                               (SSTACK_PREPULL)
00F6BB 0FF6BB 8F 08 23                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F6BE 0FF6BE 18 22 FC 8D                                     BHI     UF                                               (SSTACK_PREPULL)
00F6C2 0FF6C2 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F6C2 0FF6C2 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
                                                              ;Signal success (remaining spaces in A)
00F6C2 0FF6C2 14 01                                           SEC
                                                              ;Done
00F6C4 0FF6C4 3D                                              RTS
                                                              ;Restore registers (remaining spaces in A)
00F6C5 0FF6C5 MACRO                   STRING_FILL_NB_3        SSTACK_PREPULL  2
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F6C5 0FF6C5 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F6C8 0FF6C8 18 25 FC 7D                                     BLO     OF                                               (SSTACK_PREPULL)
00F6CC 0FF6CC 8F 08 23                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F6CF 0FF6CF 18 22 FC 7C                                     BHI     UF                                               (SSTACK_PREPULL)
00F6D3 0FF6D3 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F6D3 0FF6D3 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
                                                              ;Signal failure (remaining spaces in A)
00F6D3 0FF6D3 10 FE                                           CLC
                                                              ;Done
00F6D5 0FF6D5 3D                                              RTS
                                      ;#Print a number of filler characters - blocking
                                      ; args:   A: number of characters to be printed
                                      ;         B: filler character
                                      ; result: A: $00
                                      ; SSTACK: 9 bytes
                                      ;         X, Y and B are preserved
00F6D6 0FF6D6 -> $F6D6                STRING_CODE_END         EQU     *
00F6D6 0FF6D6 -> $FF6D6               STRING_CODE_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F90E 0FF90E                                                 ORG     STRING_TABS_START, STRING_TABS_START_LIN
                                      ;Common strings
00F90E 0FF90E 21                      STRING_STR_EXCLAM_NL    DB      "!"     ;exclamation mark + new line
00F90F 0FF90F MACRO                   STRING_STR_NL           STRING_NL_TERM  ;new line
                                      ;#Terminated line break                                                          (STRING_NL_TERM)
00F90F 0FF90F 0D                                              DB      STRING_SYM_CR                                    (STRING_NL_TERM)
00F910 0FF910 8A                                              DB      (STRING_SYM_LF|$80)                              (STRING_NL_TERM)
00F911 0FF911 -> $F911                STRING_TABS_END         EQU     *
00F911 0FF911 -> $FF911               STRING_TABS_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# S12CBase - RESET - Reset Handler                                            #
                                      ;###############################################################################
                                      ;#    Copyright 2010-2012 Dirk Heisswolf                                       #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    This module detects the cause of the previous system reset and prints a  #
                                      ;#    status message over the SCI interface.                                   #
                                      ;#                                                                             #
                                      ;#    The reset handler also provides routines for triggering system resets    #
                                      ;#    from software.                                                           #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    April 4, 2010                                                            #
                                      ;#      - Initial release                                                      #
                                      ;#    May 30, 2010                                                             #
                                      ;#      - Changed "Initialization failure" error to "Unknown cause" error      #
                                      ;#    June 8, 2010                                                             #
                                      ;#      - Changed checksum for error message                                   #
                                      ;#      - Fixed COP error handling                                             #
                                      ;#    July 2, 2010                                                             #
                                      ;#      - compined error messages "Unknown cause" and "Unknown error" to       #
                                      ;#        "Unknown problem"                                                    #
                                      ;#      - changed error codes                                                  #
                                      ;#    June 29, 2012                                                            #
                                      ;#      - Added support for linear PC                                          #
                                      ;#      - Added option to only use one shared reset vector                     #
                                      ;#    November 16, 2012                                                        #
                                      ;#      - Total redo, now called reset handler and only supporting fatal       #
                                      ;#        errors                                                               #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    STRING - String printing routines                                        #
                                      ;#    CLOCK  - Clock driver                                                    #
                                      ;#    COP    - Watchdog handler                                                #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - none                                                                   #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Configuration                                                               #
                                      ;###############################################################################
                                      ;Error detection
                                      ;---------------
                                      ;COP detection
                                      ;Clock failure detection
                                      ;Power failure detection
00F911 0FF911 -> $0001                RESET_POWFAIL_ON        EQU     1               ;default is RESET_POWFAIL_ON
                                      ;Code runaway detection
00F911 0FF911 -> $0001                RESET_CODERUN_OFF       EQU     1               ;default is RESET_CODERUN_OFF
                                      ;Welcome message
                                      ;---------------
                                      ;RESET_WELCOME  FCS     "Hello, this is S12CBase!"
                                      ;###############################################################################
                                      ;# Constants                                                                   #
                                      ;###############################################################################
                                      ;Flags
00F911 0FF911 -> $0040                RESET_FLG_POR           EQU     $40             ;power on     (PORF)
00F911 0FF911 -> $0020                RESET_FLG_POWFAIL       EQU     $20             ;power loss   (LVRF)
00F911 0FF911 -> $0004                RESET_FLG_CODERUN       EQU     $04             ;code runaway (ILAF)
00F911 0FF911 -> $0002                RESET_FLG_COP           EQU     $02             ;watchdog timeout
00F911 0FF911 -> $0001                RESET_FLG_CLKFAIL       EQU     $01             ;clock faiure
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000855 0F4855                                                 ORG     RESET_VARS_START, RESET_VARS_START_LIN
000855 0F4855 -> $0855                RESET_AUTO_LOC1         EQU     *               ;1st auto-place location
000856 0F4856                                                 ALIGN   1
000856 0F4856                         RESET_MSG               DS      2               ;error message to be displayed
000858 0F4858                         RESET_MSG_CHKSUM        DS      1               ;checksum for the errormessage
000859 0F4859 -> $0859                RESET_AUTO_LOC2         EQU     *               ;2nd auto-place location
000859 0F4859 -> $0855                RESET_FLGS              EQU     ((RESET_VARS_START&1)*RESET_AUTO_LOC1)+((~(RESET_VARS_START)&1)*RESET_AUTO_LOC2)
000859 0F4859                                                 DS      (~(RESET_VARS_START)&1)
000859 0F4859 -> $0859                RESET_VARS_END          EQU     *
000859 0F4859 -> $F4859               RESET_VARS_END_LIN      EQU     @
                                      ;#Calculate the checksum of the custom error message
                                      ; args:   X:      error message
                                      ;         Y:      return address
                                      ; result: A:      checksum
                                      ;         C-flag: set if message is valid
                                      ;         none of the registers are preserved
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F6D6 0FF6D6                                                 ORG     RESET_CODE_START, RESET_CODE_START_LIN
                                      ;#COP reset entry point
                                      ;----------------------
00F6D6 0FF6D6 -> $F6D6                RESET_COP_ENTRY         EQU     RESET_EXT_ENTRY
                                      ;#Clock monitor reset entry point
                                      ;--------------------------------
00F6D6 0FF6D6 -> $F6D6                RESET_CM_ENTRY          EQU     RESET_EXT_ENTRY
                                      ;#External reset entry point
                                      ;---------------------------
00F6D6 0FF6D6 -> $F6D6                RESET_EXT_ENTRY         EQU     *
                                                              ;Capture CRG/CPMU flags
00F6D6 0FF6D6 79 08 55                                        CLR     RESET_FLGS
00F6D9 0FF6D9 06 F0 00                                        JOB     START_OF_CODE
                                      ;#Perform a reset due to a fatal error
                                      ; args: X: message pointer
00F6DC 0FF6DC -> $F6DC                RESET_FATAL             EQU     *
00F6DC 0FF6DC 7E 08 56                                        STX     RESET_MSG
00F6DF 0FF6DF FD F7 0C                                        LDY     RESET_FATAL_1
                                      ;#Calculate the checksum of the custom error message
                                      ; args:   X:      error message
                                      ;         Y:      return address
                                      ; result: A:      checksum
                                      ;;        C-flag: set if message is valid
                                      ;         none of the registers are preserved
00F6E2 0FF6E2 -> $F6E2                RESET_CALC_CHECKSUM     EQU     *
                                                              ;Initialize checksum generation
00F6E2 0FF6E2 87                                              CLRA
                                                              ;Get next character
00F6E3 0FF6E3 E6 30                   RESET_CALC_CHECKSUM_1   LDAB    1,X+
00F6E5 0FF6E5 2B 0F                                           BMI     RESET_CALC_CHECKSUM_2   ;last charcter reached
00F6E7 0FF6E7 C1 20                                           CMPB    #STRING_SYM_SPACE
00F6E9 0FF6E9 25 1D                                           BLO     <RESET_CALC_CHECKSUM_3  ;message is invalid
00F6EB 0FF6EB C1 7E                                           CMPB    #STRING_SYM_TILDE
00F6ED 0FF6ED 22 19                                           BHI     <RESET_CALC_CHECKSUM_3  ;message is invalid
00F6EF 0FF6EF 18 06                                           ABA
00F6F1 0FF6F1 45                                              ROLA
00F6F2 0FF6F2 89 00                                           ADCA    #$00
00F6F4 0FF6F4 20 ED                                           JOB     RESET_CALC_CHECKSUM_1
                                                              ;Last charcter reached
00F6F6 0FF6F6 C1 A0                   RESET_CALC_CHECKSUM_2   CMPB    #(STRING_SYM_SPACE|$80)
00F6F8 0FF6F8 25 0E                                           BLO     <RESET_CALC_CHECKSUM_3  ;message is invalid
00F6FA 0FF6FA C1 7E                                           CMPB    #(STRING_SYM_TILDE|80)
00F6FC 0FF6FC 22 0A                                           BHI     <RESET_CALC_CHECKSUM_3  ;message is invalid
                                                              ;Message is valid
00F6FE 0FF6FE 18 06                                           ABA
00F700 0FF700 45                                              ROLA
00F701 0FF701 89 00                                           ADCA    #$00
00F703 0FF703 41                                              COMA
00F704 0FF704 14 01                                           SEC
00F706 0FF706 05 40                                           JMP     0,Y
                                                              ;Message is invalid
00F708 0FF708 10 FE                   RESET_CALC_CHECKSUM_3   CLC
00F70A 0FF70A 05 40                                           JMP     0,Y
                                      ;#Perform a reset due to a fatal error...continued
                                                              ;Check if message is valid (checksum in A, valid/invalid in C-flag)
00F70C 0FF70C 24 05                   RESET_FATAL_1           BCC     RESET_FATAL_3           ;clear message
00F70E 0FF70E 7A 08 58                                        STAA    RESET_MSG_CHKSUM
                                                              ;Trigger COP
00F711 0FF711 MACRO                   RESET_FATAL_2           COP_RESET
                                      ;# COP replacement macros                                                        (COP_RESET)
00F711 0FF711 20 C3                                           JOB     RESET_COP_ENTRY                                  (COP_RESET)
                                                              ;Clear message
00F713 0FF713 87                      RESET_FATAL_3           CLRA
00F714 0FF714 C7                                              CLRB
00F715 0FF715 7C 08 56                                        STD     RESET_MSG
00F718 0FF718 7A 08 58                                        STAA    RESET_MSG_CHKSUM
00F71B 0FF71B 20 F4                                           JOB     RESET_FATAL_2           ;trigger COP
                                      ;#Trigger a fatal error if a reset accurs
00F71D 0FF71D -> $F71D                RESET_ISR_FATAL         EQU     *
00F71D 0FF71D MACRO                                           RESET_FATAL     RESET_STR_ILLIRQ
                                      ;#Perform a reset due to a fatal error                                           (RESET_FATAL)
                                      ; args: 1: message pointer                                                       (RESET_FATAL)
                                                              ;BGND                                                    (RESET_FATAL)
00F71D 0FF71D CE F9 22                                        LDX     #\1                                              (RESET_FATAL)
00F720 0FF720 20 BA                                           JOB     RESET_FATAL                                      (RESET_FATAL)
00F722 0FF722 -> $F722                RESET_CODE_END          EQU     *
00F722 0FF722 -> $FF722               RESET_CODE_END_LIN      EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F911 0FF911                                                 ORG     RESET_TABS_START, RESET_TABS_START_LIN
                                      ;#Welcome string
                                      ;#Error indicator
00F911 0FF911 46 61 74 61 6C 21 A0    RESET_STR_FATAL         FCS     "Fatal! "
                                      ;#Error messages
00F918 0FF918 50 6F 77 65 72 20 6C 6F RESET_STR_POWFAIL       FCS     "Power loss"
              73 F3                   
00F922 0FF922 49 6C 6C 65 67 61 6C 20 RESET_STR_ILLIRQ        FCS     "Illegal interrupt"
              69 6E 74 65 72 72 75 70 
              F4                      
00F933 0FF933 -> $F933                RESET_TABS_END          EQU     *
00F933 0FF933 -> $FF933               RESET_TABS_END_LIN      EQU     @
                                      ;###############################################################################
                                      ;# S12CBase - NUM - Number printing routines                                   #
                                      ;###############################################################################
                                      ;#    Copyright 2010 Dirk Heisswolf                                            #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    This module implements various print routines for the SCI driver:        #
                                      ;#    NUM_REVERSE     - calculate a number of reverse digit order              #
                                      ;#    NUM_REVPRINT_NB - print a reverse number (non-blocking)                  #
                                      ;#    NUM_REVPRINT_BL - print a reverse number (blocking)                      #
                                      ;#                                                                             #
                                      ;#    Each of these functions has a coresponding macro definition              #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    STRING    - String printing routines                                     #
                                      ;#    SCI    - SCI driver                                                      #
                                      ;#    SSTACK - Subroutine Stack Handler                                        #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - none                                                                   #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    Apr  4, 2010                                                             #
                                      ;#      - Initial release                                                      #
                                      ;#    November 21, 2012                                                        #
                                      ;#      - Total rewrite (now called NUM)                                       #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Configuration                                                               #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Constants                                                                   #
                                      ;###############################################################################
                                      ;Valid number base
00F933 0FF933 -> $0002                NUM_BASE_MIN            EQU     2                               ;binary
00F933 0FF933 -> $0010                NUM_BASE_MAX            EQU     NUM_SYMTAB_END-NUM_SYMTAB       ;max base value determined by symbol table
00F933 0FF933 -> $000A                NUM_BASE_DEF            EQU     10                              ;default base (decimal)
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000859 0F4859                                                 ORG     NUM_VARS_START, NUM_VARS_START_LIN
000859 0F4859 -> $0859                NUM_VARS_END            EQU     *
000859 0F4859 -> $F4859               NUM_VARS_END_LIN        EQU     @
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F722 0FF722                                                 ORG     NUM_CODE_START, NUM_CODE_START_LIN
                                      ;#Reverse unsigned double word
                                      ; args:   Y:X: unsigned double value
                                      ;         B:   base   (2<=base<=16)
                                      ; result: A:   number of digits
                                      ;         SP+0: MSB
                                      ;         SP+1:  |
                                      ;         SP+2:  |reverse
                                      ;         SP+3:  |number
                                      ;         SP+4:  |
                                      ;         SP+5: LSB
                                      ; SSTACK: 18 bytes
                                      ;         X, Y and B are preserved
00F722 0FF722 -> $F722                NUM_REVERSE             EQU     *
                                      ;Stack layout:
00F722 0FF722 -> $0000                NUM_REVERSE_FHW         EQU     $00 ;SP+ 0: MSB
                                                                          ;SP+ 1:  |forward
00F722 0FF722 -> $0002                NUM_REVERSE_FLW         EQU     $02 ;SP+ 2:  |number
                                                                          ;SP+ 3: LSB
00F722 0FF722 -> $0004                NUM_REVERSE_COUNT       EQU     $04 ;SP+ 4: count -> A
00F722 0FF722 -> $0005                NUM_REVERSE_BASE        EQU     $05 ;SP+ 5: base  -> B
00F722 0FF722 -> $0006                NUM_REVERSE_Y           EQU     $06 ;SP+ 6: +Y
                                                                          ;SP+ 7: +
00F722 0FF722 -> $0008                NUM_REVERSE_X           EQU     $08 ;SP+ 8: +X
                                                                          ;SP+ 9: +
00F722 0FF722 -> $000A                NUM_REVERSE_RTN         EQU     $0A ;SP+10: +return address
                                                                          ;SP+11: +
00F722 0FF722 -> $000C                NUM_REVERSE_RHW         EQU     $0C ;SP+12: MSB
                                                                          ;SP+13:  |
00F722 0FF722 -> $000E                NUM_REVERSE_RMW         EQU     $0E ;SP+14:  |reverse
                                                                          ;SP+15:  |number
00F722 0FF722 -> $0010                NUM_REVERSE_RLW         EQU     $10 ;SP+16:  |      +return address at
                                                                          ;SP+17: LSB     +subroutine entry
                                                              ;Setup stack (double value in Y:X, base in B)
00F722 0FF722 87                                              CLRA
00F723 0FF723 18 02 80 AA                                     MOVW    0,SP, 6,-SP     ;move return address to SP+10
00F727 0FF727 6C 86                                           STD     6,SP            ;initialize reverse number
00F729 0FF729 18 00 84 00 00                                  MOVW    #$0000, 4,SP    ;  reverse number = base
00F72E 0FF72E 18 00 82 00 00                                  MOVW    #$0000, 2,SP
00F733 0FF733 34                                              PSHX                    ;store X at SP+8
00F734 0FF734 35                                              PSHY                    ;store Y at SP+6
00F735 0FF735 3B                                              PSHD                    ;store count:base at SP+4
00F736 0FF736 34                                              PSHX                    ;store double value at SP+0
00F737 0FF737 35                                              PSHY
                                                              ;Divide FHW by base
00F738 0FF738 EE 80                   NUM_REVERSE_1           LDX     NUM_REVERSE_FHW,SP      ;FHW => X
00F73A 0FF73A 27 0B                                           BEQ     NUM_REVERSE_2           ;skip division step
00F73C 0FF73C 87                                              CLRA                            ;base => D
00F73D 0FF73D E6 85                                           LDAB    NUM_REVERSE_BASE,SP
00F73F 0FF73F B7 D4                                           EXG     X, D
00F741 0FF741 18 10                                           IDIV                            ;D / X => X,  D % X => D
00F743 0FF743 6E 80                                           STX     NUM_REVERSE_FHW,SP      ;result => FHW
                                                              ;Divide FLW by base (prev. remainder in D)
00F745 0FF745 B7 45                                           TFR     D, X                    ;remainder => X
00F747 0FF747 87                      NUM_REVERSE_2           CLRA                            ;base => D
00F748 0FF748 E6 85                                           LDAB    NUM_REVERSE_BASE,SP
00F74A 0FF74A ED 82                                           LDY     NUM_REVERSE_FLW,SP      ;FLW => Y
00F74C 0FF74C B7 D6                                           EXG     X, Y
00F74E 0FF74E B7 D4                                           EXG     X, D
00F750 0FF750 11                                              EDIV                            ;Y:D / X => Y,  Y:D % X => D
00F751 0FF751 6D 82                                           STY     NUM_REVERSE_FLW,SP      ;result => FLW
                                                              ;Add remainder to the reverse value (prev. remainder in D)
00F753 0FF753 E3 F0 10                                        ADDD    NUM_REVERSE_RLW,SP      ;RLW
00F756 0FF756 6C F0 10                                        STD     NUM_REVERSE_RLW,SP
00F759 0FF759 EC 8E                                           LDD     NUM_REVERSE_RMW,SP      ;RMW
00F75B 0FF75B C9 00                                           ADCB    #$00
00F75D 0FF75D 89 00                                           ADCA    #$00
00F75F 0FF75F 6C 8E                                           STD     NUM_REVERSE_RMW,SP
00F761 0FF761 EC 8C                                           LDD     NUM_REVERSE_RHW,SP      ;RHW
00F763 0FF763 C9 00                                           ADCB    #$00
00F765 0FF765 89 00                                           ADCA    #$00
00F767 0FF767 6C 8C                                           STD     NUM_REVERSE_RHW,SP
                                                              ;Increment digit count
00F769 0FF769 62 84                                           INC     NUM_REVERSE_COUNT,SP
                                                              ;Check if the calculation is finished
00F76B 0FF76B EC 82                                           LDD     NUM_REVERSE_FLW,SP
00F76D 0FF76D 26 04                                           BNE     <NUM_REVERSE_3          ;reverse value incomplete
00F76F 0FF76F EC 80                                           LDD     NUM_REVERSE_FHW,SP
00F771 0FF771 27 28                                           BEQ     <NUM_REVERSE_4          ;reverse value has been generated
                                                              ;Multiply RLW by base
00F773 0FF773 ED F0 10                NUM_REVERSE_3           LDY     NUM_REVERSE_RLW,SP
00F776 0FF776 87                                              CLRA
00F777 0FF777 E6 85                                           LDAB    NUM_REVERSE_BASE,SP
00F779 0FF779 13                                              EMUL                            ;Y * D => Y:D
00F77A 0FF77A 6C F0 10                                        STD     NUM_REVERSE_RLW,SP
                                                              ;Multiply RMW by base (carry-over in Y)
00F77D 0FF77D EC 8E                                           LDD     NUM_REVERSE_RMW,SP
00F77F 0FF77F B7 C6                                           EXG     D, Y
00F781 0FF781 6C 8E                                           STD     NUM_REVERSE_RMW,SP
00F783 0FF783 87                                              CLRA
00F784 0FF784 E6 85                                           LDAB    NUM_REVERSE_BASE,SP
00F786 0FF786 13                                              EMUL                            ;Y * D => Y:D
00F787 0FF787 E3 8E                                           ADDD    NUM_REVERSE_RMW,SP
00F789 0FF789 6C 8E                                           STD     NUM_REVERSE_RMW,SP
                                                              ;Multiply RHW by base (carry-over in Y)
00F78B 0FF78B EC 8C                                           LDD     NUM_REVERSE_RHW,SP
00F78D 0FF78D B7 C6                                           EXG     D, Y
00F78F 0FF78F 6C 8C                                           STD     NUM_REVERSE_RHW,SP
00F791 0FF791 87                                              CLRA
00F792 0FF792 E6 85                                           LDAB    NUM_REVERSE_BASE,SP
00F794 0FF794 13                                              EMUL                            ;Y * D => Y:D
00F795 0FF795 E3 8C                                           ADDD    NUM_REVERSE_RHW,SP
00F797 0FF797 6C 8C                                           STD     NUM_REVERSE_RHW,SP
                                                              ;Start new iteration
00F799 0FF799 20 9D                                           JOB     NUM_REVERSE_1
                                                              ;Clean up
00F79B 0FF79B MACRO                   NUM_REVERSE_4           SSTACK_PREPULL  18
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F79B 0FF79B 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F79E 0FF79E 18 25 FB A7                                     BLO     OF                                               (SSTACK_PREPULL)
00F7A2 0FF7A2 8F 08 13                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F7A5 0FF7A5 18 22 FB A6                                     BHI     UF                                               (SSTACK_PREPULL)
00F7A9 0FF7A9 -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F7A9 0FF7A9 -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F7A9 0FF7A9 1B 84                                           LEAS    4,SP                    ;release temporary space for forward number
00F7AB 0FF7AB 3A                                              PULD                            ;
00F7AC 0FF7AC 31                                              PULY
00F7AD 0FF7AD 30                                              PULX
                                                              ;Done
00F7AE 0FF7AE 3D                                              RTS
                                      ;#Print a reserse number digit - non-blocking
                                      ; args:   B:    base (2<=base<=16)
                                      ;         SP+0: MSB
                                      ;         SP+1:  |
                                      ;         SP+2:  |reverse
                                      ;         SP+3:  |number
                                      ;         SP+4:  |
                                      ;         SP+5: LSB
                                      ; result: SP+0: MSB
                                      ;         SP+1:  |remaining
                                      ;         SP+2:  | digits of
                                      ;         SP+3:  |reverse
                                      ;         SP+4:  |number
                                      ;         SP+5: LSB
                                      ;         C-flag: set if successful
                                      ; SSTACK: 8 bytes
                                      ;         X, Y and D are preserved
00F7AF 0FF7AF -> $F7AF                NUM_REVPRINT_NB EQU     *
                                      ;Stack layout:
00F7AF 0FF7AF -> $0000                NUM_REVPRINT_NB_COUNT   EQU     $00 ;SP+ 0: A
00F7AF 0FF7AF -> $0001                NUM_REVPRINT_NB_BASE    EQU     $01 ;SP+ 1: base -> B
00F7AF 0FF7AF -> $0002                NUM_REVPRINT_NB_Y       EQU     $02 ;SP+ 2: +Y
                                                                          ;SP+ 3: +
00F7AF 0FF7AF -> $0004                NUM_REVPRINT_NB_X       EQU     $04 ;SP+ 4: +X
                                                                          ;SP+ 5: +
00F7AF 0FF7AF -> $0006                NUM_REVPRINT_NB_RTN     EQU     $06 ;SP+ 6: +return address
                                                                          ;SP+ 7: +
00F7AF 0FF7AF -> $0008                NUM_REVPRINT_NB_RHW     EQU     $08 ;SP+ 8: MSB
                                                                          ;SP+ 9:  |copy
00F7AF 0FF7AF -> $000A                NUM_REVPRINT_NB_RMW     EQU     $0A ;SP+10:  |of
                                                                          ;SP+11:  |reverse
00F7AF 0FF7AF -> $000C                NUM_REVPRINT_NB_RLW     EQU     $0C ;SP+12:  |number
                                                                          ;SP+13: LSB
                                                              ;Setup stack (base in B)
00F7AF 0FF7AF 34                                              PSHX                                    ;store X at SP+8
00F7B0 0FF7B0 35                                              PSHY                                    ;store Y at SP+6
00F7B1 0FF7B1 3B                                              PSHD                                    ;store count:base at SP+4
                                                              ;Check if TX queue is full already (base in B)
00F7B2 0FF7B2 MACRO                   NUM_REVPRINT_NB_1       SCI_TX_READY_NB
                                      ;#Check if TX queue can hold further data                                        (SCI_TX_READY_NB)
                                      ; args:   none                                                                   (SCI_TX_READY_NB)
                                      ; result: C-flag: set if successful                                              (SCI_TX_READY_NB)
                                      ; SSTACK: 4 bytes                                                                (SCI_TX_READY_NB)
                                      ;         X, Y, and D are preserved                                              (SCI_TX_READY_NB)
00F7B2 0FF7B2 MACRO                                           SSTACK_JOBSR    SCI_TX_READY_NB, 4                       (SCI_TX_READY_NB)
                                      ;#Check stack and call subroutine                                                (SCI_TX_READY_NB/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (SCI_TX_READY_NB/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (SCI_TX_READY_NB/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (SCI_TX_READY_NB/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (SCI_TX_READY_NB/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (SCI_TX_READY_NB/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (SCI_TX_READY_NB/SSTACK_JOBSR)
00F7B2 0FF7B2 MACRO                                           SSTACK_PREPUSH  \2                                       (SCI_TX_READY_NB/SSTACK_JOBSR)
                                      ;############################################################################### (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
00F7B2 0FF7B2 8F 08 0E                                        CPS     #SSTACK_TOP+\1                                   (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
00F7B5 0FF7B5 18 25 FB 90                                     BLO     OF                                               (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
00F7B9 0FF7B9 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
00F7BC 0FF7BC 18 22 FB 8F                                     BHI     UF                                               (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
00F7C0 0FF7C0 -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
00F7C0 0FF7C0 -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_TX_READY_NB/SSTACK_JOBSR/SSTACK_PREPUSH)
00F7C0 0FF7C0 16 F4 2D                                        JOBSR   \1                                               (SCI_TX_READY_NB/SSTACK_JOBSR)
00F7C3 0FF7C3 18 24 00 49                                     BCC     >NUM_REVPRINT_NB_4      ;TX queue is full
                                                              ;Divide RHW by base
00F7C7 0FF7C7 ED 88                                           LDY     NUM_REVPRINT_NB_RHW,SP  ;RHW => Y
00F7C9 0FF7C9 27 0D                                           BEQ     NUM_REVPRINT_NB_2               ;skip division step
00F7CB 0FF7CB B7 65                                           TFR     Y, X
00F7CD 0FF7CD 87                                              CLRA                            ;base => D
00F7CE 0FF7CE E6 81                                           LDAB    NUM_REVPRINT_NB_BASE,SP
00F7D0 0FF7D0 B7 D4                                           EXG     X, D
00F7D2 0FF7D2 18 10                                           IDIV                            ;D / X => X,  D % X => D
00F7D4 0FF7D4 6E 88                                           STX     NUM_REVPRINT_NB_RHW,SP  ;result => RHW
                                                              ;Divide RMW by base (prev remainder in D)
00F7D6 0FF7D6 B7 46                                           TFR     D, Y                    ;remainder => Y
00F7D8 0FF7D8 87                      NUM_REVPRINT_NB_2       CLRA                            ;base => D
00F7D9 0FF7D9 E6 81                                           LDAB    NUM_REVPRINT_NB_BASE,SP
00F7DB 0FF7DB EE 8A                                           LDX     NUM_REVPRINT_NB_RMW,SP  ;RMW => Y
00F7DD 0FF7DD B7 C5                                           EXG     D, X
00F7DF 0FF7DF 11                                              EDIV                            ;Y:D / X => Y,  Y:D % X => D
00F7E0 0FF7E0 6D 8A                                           STY     NUM_REVPRINT_NB_RMW,SP  ;result => RMW
                                                              ;Divide RLW by base (prev remainder in D, base in X)
00F7E2 0FF7E2 B7 46                                           TFR     D, Y                    ;remainder => Y
00F7E4 0FF7E4 EC 8C                                           LDD     NUM_REVPRINT_NB_RLW,SP  ;RLW => D
00F7E6 0FF7E6 11                                              EDIV                            ;Y:D / X => Y,  Y:D % X => D
00F7E7 0FF7E7 6D 8C                                           STY     NUM_REVPRINT_NB_RLW,SP  ;result => RLW
                                                              ;Print remainder (prev, remainder in D, RLW in Y)
00F7E9 0FF7E9 CE F9 33                                        LdX     #NUM_SYMTAB
00F7EC 0FF7EC E6 E5                                           LDAB    B,X
00F7EE 0FF7EE 16 F3 61                                        JOBSR   SCI_TX_NB               ;print character (SSTACK: 5 bytes)
                                                              ;BCC    >NUM_REVPRINT_NB_4      ;TX unsuccessful -> has already been checked
                                                              ;Repeat until the reverse value is $1 (RLW in Y)
00F7F1 0FF7F1 04 36 BE                                        DBNE    Y, NUM_REVPRINT_NB_1    ;RLW is not 1
00F7F4 0FF7F4 EC 8A                                           LDD     NUM_REVPRINT_NB_RMW,SP
00F7F6 0FF7F6 26 BA                                           BNE     NUM_REVPRINT_NB_1       ;RMW is not 0
00F7F8 0FF7F8 EC 88                                           LDD     NUM_REVPRINT_NB_RHW,SP
00F7FA 0FF7FA 26 B6                                           BNE     NUM_REVPRINT_NB_1       ;RMW is not 0
                                                              ;Printing complete
00F7FC 0FF7FC MACRO                                           SSTACK_PREPULL  14
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F7FC 0FF7FC 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F7FF 0FF7FF 18 25 FB 46                                     BLO     OF                                               (SSTACK_PREPULL)
00F803 0FF803 8F 08 17                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F806 0FF806 18 22 FB 45                                     BHI     UF                                               (SSTACK_PREPULL)
00F80A 0FF80A -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F80A 0FF80A -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F80A 0FF80A 14 01                                           SEC
00F80C 0FF80C 3A                      NUM_REVPRINT_NB_3       PULD
00F80D 0FF80D 31                                              PULY
00F80E 0FF80E 30                                              PULX
                                                              ;Done
00F80F 0FF80F 3D                                              RTS
                                                              ;Printing incomplete
00F810 0FF810 MACRO                   NUM_REVPRINT_NB_4       SSTACK_PREPULL  14
                                      ;#Check stack before pull operation                                              (SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (SSTACK_PREPULL)
                                      ; result: none                                                                   (SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (SSTACK_PREPULL)
00F810 0FF810 8F 08 0A                                        CPS     #SSTACK_TOP                                      (SSTACK_PREPULL)
00F813 0FF813 18 25 FB 32                                     BLO     OF                                               (SSTACK_PREPULL)
00F817 0FF817 8F 08 17                                        CPS     #SSTACK_BOTTOM-\1                                (SSTACK_PREPULL)
00F81A 0FF81A 18 22 FB 31                                     BHI     UF                                               (SSTACK_PREPULL)
00F81E 0FF81E -> $F34F                UF                      EQU     SSTACK_UF                                        (SSTACK_PREPULL)
00F81E 0FF81E -> $F349                OF                      EQU     SSTACK_OF                                        (SSTACK_PREPULL)
00F81E 0FF81E 10 FE                                           CLC
00F820 0FF820 20 EA                                           JOB     NUM_REVPRINT_NB_3
00F822 0FF822 -> $F822                NUM_CODE_END            EQU     *
00F822 0FF822 -> $FF822               NUM_CODE_END_LIN        EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F933 0FF933                                                 ORG     NUM_TABS_START, NUM_TABS_START_LIN
00F933 0FF933 30                      NUM_SYMTAB              DB      "0"
00F934 0FF934 31                                              DB      "1"
00F935 0FF935 32                                              DB      "2"
00F936 0FF936 33                                              DB      "3"
00F937 0FF937 34                                              DB      "4"
00F938 0FF938 35                                              DB      "5"
00F939 0FF939 36                                              DB      "6"
00F93A 0FF93A 37                                              DB      "7"
00F93B 0FF93B 38                                              DB      "8"
00F93C 0FF93C 39                                              DB      "9"
00F93D 0FF93D 41                                              DB      "A"
00F93E 0FF93E 42                                              DB      "B"
00F93F 0FF93F 43                                              DB      "C"
00F940 0FF940 44                                              DB      "D"
00F941 0FF941 45                                              DB      "E"
00F942 0FF942 46                                              DB      "F"
00F943 0FF943 43                      NUM_SYMTAB_END  DB      *
00F944 0FF944 -> $F944                NUM_TABS_END            EQU     *
00F944 0FF944 -> $FF944               NUM_TABS_END_LIN        EQU     @
                                      ;###############################################################################
                                      ;# S12CBase - NVM - Non-Volatile Memory Driver (SIMHC12)                       #
                                      ;###############################################################################
                                      ;#    Copyright 2010-2012 Dirk Heisswolf                                       #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12(X) MCU   #
                                      ;#    families                                                                 #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    This module erase and programing routines for the on-chip NVMs.          #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    November 21, 2012                                                        #
                                      ;#      - Initial release                                                      #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    - none                                                                   #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - none                                                                   #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Constants                                                                   #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000859 0F4859                                                 ORG     NVM_VARS_START, NVM_VARS_START_LIN
000859 0F4859 -> $0859                NVM_VARS_END            EQU     *
000859 0F4859 -> $F4859               NVM_VARS_END_LIN        EQU     @
                                      ;###############################################################################
                                      ;# Macros                                                                      #
                                      ;###############################################################################
                                      ;#Initialization
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F822 0FF822                                                 ORG     NVM_CODE_START, NVM_CODE_START_LIN
00F822 0FF822 -> $F822                NVM_CODE_END            EQU     *
00F822 0FF822 -> $FF822               NVM_CODE_END_LIN        EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F944 0FF944                                                 ORG     NVM_TABS_START, NVM_TABS_START_LIN
00F944 0FF944 -> $F944                NVM_TABS_END            EQU     *
00F944 0FF944 -> $FF944               NVM_TABS_END_LIN        EQU     @
                                      ;###############################################################################
                                      ;# S12CBase - VECTAB - Vector Table (SIMHC12)                                  #
                                      ;###############################################################################
                                      ;#    Copyright 2010-2012 Dirk Heisswolf                                       #
                                      ;#    This file is part of the S12CBase framework for Freescale's S12C MCU     #
                                      ;#    family.                                                                  #
                                      ;#                                                                             #
                                      ;#    S12CBase is free software: you can redistribute it and/or modify         #
                                      ;#    it under the terms of the GNU General Public License as published by     #
                                      ;#    the Free Software Foundation, either version 3 of the License, or        #
                                      ;#    (at your option) any later version.                                      #
                                      ;#                                                                             #
                                      ;#    S12CBase is distributed in the hope that it will be useful,              #
                                      ;#    but WITHOUT ANY WARRANTY; without even the implied warranty of           #
                                      ;#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            #
                                      ;#    GNU General Public License for more details.                             #
                                      ;#                                                                             #
                                      ;#    You should have received a copy of the GNU General Public License        #
                                      ;#    along with S12CBase.  If not, see <http://www.gnu.org/licenses/>.        #
                                      ;###############################################################################
                                      ;# Description:                                                                #
                                      ;#    This module defines the static vector table of the OpenBDC firmware.     #
                                      ;#    Unexpected inerrupts are cought and trigger a fatal error in the reset   #
                                      ;#    handler.                                                                 #
                                      ;###############################################################################
                                      ;# Required Modules:                                                           #
                                      ;#    SCI    - UART driver                                                     #
                                      ;#                                                                             #
                                      ;# Requirements to Software Using this Module:                                 #
                                      ;#    - none                                                                   #
                                      ;###############################################################################
                                      ;# Version History:                                                            #
                                      ;#    April 4, 2010                                                            #
                                      ;#      - Initial release                                                      #
                                      ;#    August 9, 2012                                                           #
                                      ;#      - Added support for linear PC                                          #
                                      ;#      - Added dummy vectors                                                  #
                                      ;#    November 16, 2012                                                        #
                                      ;#      - Restructured table                                                   #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Configuration                                                               #
                                      ;###############################################################################
                                      ;Make each unused interrupt point to a separate BGND instruction
                                      ;VECTAB_DEBUG           EQU     1
                                      ;###############################################################################
                                      ;# Constants                                                                   #
                                      ;###############################################################################
00F944 0FF944 -> $FF80                VECTAB_START            EQU     $FF80
00F944 0FF944 -> $FFFF80              VECTAB_START_LIN        EQU     $FFFF80
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000859 0F4859                                                 ORG     VECTAB_VARS_START, VECTAB_VARS_START_LIN
000859 0F4859 -> $0859                VECTAB_VARS_END         EQU     *
000859 0F4859 -> $F4859               VECTAB_VARS_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# Macros                                                                      #
                                      ;###############################################################################
                                      ;#Initialization
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F822 0FF822                                                 ORG     VECTAB_CODE_START, VECTAB_CODE_START_LIN
00F822 0FF822 -> $F822                VECTAB_CODE_END         EQU     *
00F822 0FF822 -> $FF822               VECTAB_CODE_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F944 0FF944                                                 ORG     VECTAB_TABS_START, VECTAB_TABS_START_LIN
                                      ;#Interrupt service routines
                                      ;#--------------------------
00F944 0FF944 -> $F71D                ISR_RES80               EQU     RESET_ISR_FATAL         ;vector base + $80
00F944 0FF944 -> $F71D                ISR_RES82               EQU     RESET_ISR_FATAL         ;vector base + $82
00F944 0FF944 -> $F71D                ISR_RES84               EQU     RESET_ISR_FATAL         ;vector base + $84
00F944 0FF944 -> $F71D                ISR_RES86               EQU     RESET_ISR_FATAL         ;vector base + $86
00F944 0FF944 -> $F71D                ISR_RES88               EQU     RESET_ISR_FATAL         ;vector base + $88
00F944 0FF944 -> $F71D                ISR_RES8A               EQU     RESET_ISR_FATAL         ;vector base + $8A
00F944 0FF944 -> $F71D                ISR_RES8C               EQU     RESET_ISR_FATAL         ;vector base + $8C
00F944 0FF944 -> $F71D                ISR_RES8E               EQU     RESET_ISR_FATAL         ;vector base + $8E
00F944 0FF944 -> $F71D                ISR_RES90               EQU     RESET_ISR_FATAL         ;vector base + $90
00F944 0FF944 -> $F71D                ISR_RES92               EQU     RESET_ISR_FATAL         ;vector base + $92
00F944 0FF944 -> $F71D                ISR_RES94               EQU     RESET_ISR_FATAL         ;vector base + $94
00F944 0FF944 -> $F71D                ISR_RES96               EQU     RESET_ISR_FATAL         ;vector base + $96
00F944 0FF944 -> $F71D                ISR_RES98               EQU     RESET_ISR_FATAL         ;vector base + $98
00F944 0FF944 -> $F71D                ISR_RES9A               EQU     RESET_ISR_FATAL         ;vector base + $9A
00F944 0FF944 -> $F71D                ISR_RES9C               EQU     RESET_ISR_FATAL         ;vector base + $9C
00F944 0FF944 -> $F71D                ISR_RES9E               EQU     RESET_ISR_FATAL         ;vector base + $9E
00F944 0FF944 -> $F71D                ISR_RESA0               EQU     RESET_ISR_FATAL         ;vector base + $A0
00F944 0FF944 -> $F71D                ISR_RESA2               EQU     RESET_ISR_FATAL         ;vector base + $A2
00F944 0FF944 -> $F71D                ISR_RESA4               EQU     RESET_ISR_FATAL         ;vector base + $A4
00F944 0FF944 -> $F71D                ISR_RESA6               EQU     RESET_ISR_FATAL         ;vector base + $A6
00F944 0FF944 -> $F71D                ISR_RESA8               EQU     RESET_ISR_FATAL         ;vector base + $A8
00F944 0FF944 -> $F71D                ISR_RESAA               EQU     RESET_ISR_FATAL         ;vector base + $AA
00F944 0FF944 -> $F71D                ISR_RESAC               EQU     RESET_ISR_FATAL         ;vector base + $AC
00F944 0FF944 -> $F71D                ISR_RESAE               EQU     RESET_ISR_FATAL         ;vector base + $AE
00F944 0FF944 -> $F71D                ISR_RESB0               EQU     RESET_ISR_FATAL         ;vector base + $A0
00F944 0FF944 -> $F71D                ISR_RESB2               EQU     RESET_ISR_FATAL         ;vector base + $B2
00F944 0FF944 -> $F71D                ISR_RESB4               EQU     RESET_ISR_FATAL         ;vector base + $B4
00F944 0FF944 -> $F71D                ISR_RESB6               EQU     RESET_ISR_FATAL         ;vector base + $B6
00F944 0FF944 -> $F71D                ISR_RESB8               EQU     RESET_ISR_FATAL         ;vector base + $B8
00F944 0FF944 -> $F71D                ISR_RESBA               EQU     RESET_ISR_FATAL         ;vector base + $BA
00F944 0FF944 -> $F71D                ISR_RESBC               EQU     RESET_ISR_FATAL         ;vector base + $BC
00F944 0FF944 -> $F71D                ISR_RESBE               EQU     RESET_ISR_FATAL         ;vector base + $BE
00F944 0FF944 -> $F71D                ISR_RESC0               EQU     RESET_ISR_FATAL         ;vector base + $C0
00F944 0FF944 -> $F71D                ISR_RESC2               EQU     RESET_ISR_FATAL         ;vector base + $C2
00F944 0FF944 -> $F71D                ISR_RESC4               EQU     RESET_ISR_FATAL                 ;vector base + $C4
00F944 0FF944 -> $F71D                ISR_RESC6               EQU     RESET_ISR_FATAL         ;vector base + $C6
00F944 0FF944 -> $F71D                ISR_RESC8               EQU     RESET_ISR_FATAL         ;vector base + $C8
00F944 0FF944 -> $F71D                ISR_RESCA               EQU     RESET_ISR_FATAL         ;vector base + $CA
00F944 0FF944 -> $F71D                ISR_RESCC               EQU     RESET_ISR_FATAL         ;vector base + $CC
00F944 0FF944 -> $F71D                ISR_PORTH               EQU     RESET_ISR_FATAL         ;vector base + $CE
00F944 0FF944 -> $F71D                ISR_PORTJ               EQU     RESET_ISR_FATAL         ;vector base + $D0
00F944 0FF944 -> $F71D                ISR_ATD                 EQU     RESET_ISR_FATAL         ;vector base + $D2
00F944 0FF944 -> $F71D                ISR_SCI1                EQU     RESET_ISR_FATAL         ;vector base + $D4
00F944 0FF944 -> $F5F8                ISR_SCI0                EQU     SCI_ISR_RXTX
00F944 0FF944 -> $F71D                ISR_SPI                 EQU     RESET_ISR_FATAL         ;vector base + $D8
00F944 0FF944 -> $F71D                ISR_TIM_PAIE            EQU     RESET_ISR_FATAL         ;vector base + $DA
00F944 0FF944 -> $F71D                ISR_TIM_PAOV            EQU     RESET_ISR_FATAL         ;vector base + $DC
00F944 0FF944 -> $F71D                ISR_TIM_TOV             EQU     RESET_ISR_FATAL         ;vector base + $DE
00F944 0FF944 -> $F71D                ISR_TIM_TC7             EQU     RESET_ISR_FATAL         ;vector base + $E0
00F944 0FF944 -> $F71D                ISR_TIM_TC6             EQU     RESET_ISR_FATAL         ;vector base + $E2
00F944 0FF944 -> $F71D                ISR_TIM_TC5             EQU     RESET_ISR_FATAL         ;vector base + $E4
00F944 0FF944 -> $F71D                ISR_TIM_TC4             EQU     RESET_ISR_FATAL         ;vector base + $E6
00F944 0FF944 -> $F595                ISR_TIM_TC3             EQU     SCI_ISR_DELAY
00F944 0FF944 -> $F71D                ISR_TIM_TC2             EQU     RESET_ISR_FATAL         ;vector base + $EA
00F944 0FF944 -> $F71D                ISR_TIM_TC1             EQU     RESET_ISR_FATAL         ;vector base + $EC
00F944 0FF944 -> $F71D                ISR_TIM_TC0             EQU     RESET_ISR_FATAL         ;vector base + $EE
00F944 0FF944 -> $F71D                ISR_RTI                 EQU     RESET_ISR_FATAL         ;vector base + $F0
00F944 0FF944 -> $F71D                ISR_IRQ                 EQU     RESET_ISR_FATAL         ;vector base + $F2
00F944 0FF944 -> $F71D                ISR_XIRQ                EQU     RESET_ISR_FATAL         ;vector base + $F4
00F944 0FF944 -> $F71D                ISR_SWI                 EQU     RESET_ISR_FATAL         ;vector base + $F6
00F944 0FF944 -> $F71D                ISR_TRAP                EQU     RESET_ISR_FATAL         ;vector base + $F8
00F944 0FF944 -> $F944                VECTAB_TABS_END         EQU     *
00F944 0FF944 -> $FF944               VECTAB_TABS_END_LIN     EQU     @
                                      ;###############################################################################
                                      ;# HC12A4 Vector Table                                                         #
                                      ;###############################################################################
00FF80 FFFF80                                                 ORG     VECTAB_START, VECTAB_START_LIN
00FF80 FFFF80 F7 1D                   VEC_RES80               DW      ISR_RES80               ;vector base + $80
00FF82 FFFF82 F7 1D                   VEC_RES82               DW      ISR_RES82               ;vector base + $82
00FF84 FFFF84 F7 1D                   VEC_RES84               DW      ISR_RES84               ;vector base + $84
00FF86 FFFF86 F7 1D                   VEC_RES86               DW      ISR_RES86               ;vector base + $86
00FF88 FFFF88 F7 1D                   VEC_RES88               DW      ISR_RES88               ;vector base + $88
00FF8A FFFF8A F7 1D                   VEC_RES8A               DW      ISR_RES8A               ;vector base + $8A
00FF8C FFFF8C F7 1D                   VEC_RES8C               DW      ISR_RES8C               ;vector base + $8C
00FF8E FFFF8E F7 1D                   VEC_RES8E               DW      ISR_RES8E               ;vector base + $8E
00FF90 FFFF90 F7 1D                   VEC_RES90               DW      ISR_RES90               ;vector base + $90
00FF92 FFFF92 F7 1D                   VEC_RES92               DW      ISR_RES92               ;vector base + $92
00FF94 FFFF94 F7 1D                   VEC_RES94               DW      ISR_RES94               ;vector base + $94
00FF96 FFFF96 F7 1D                   VEC_RES96               DW      ISR_RES96               ;vector base + $96
00FF98 FFFF98 F7 1D                   VEC_RES98               DW      ISR_RES98               ;vector base + $98
00FF9A FFFF9A F7 1D                   VEC_RES9A               DW      ISR_RES9A               ;vector base + $9A
00FF9C FFFF9C F7 1D                   VEC_RES9C               DW      ISR_RES9C               ;vector base + $9C
00FF9E FFFF9E F7 1D                   VEC_RES9E               DW      ISR_RES9E               ;vector base + $9E
00FFA0 FFFFA0 F7 1D                   VEC_RESA0               DW      ISR_RESA0               ;vector base + $A0
00FFA2 FFFFA2 F7 1D                   VEC_RESA2               DW      ISR_RESA2               ;vector base + $A2
00FFA4 FFFFA4 F7 1D                   VEC_RESA4               DW      ISR_RESA4               ;vector base + $A4
00FFA6 FFFFA6 F7 1D                   VEC_RESA6               DW      ISR_RESA6               ;vector base + $A6
00FFA8 FFFFA8 F7 1D                   VEC_RESA8               DW      ISR_RESA8               ;vector base + $A8
00FFAA FFFFAA F7 1D                   VEC_RESAA               DW      ISR_RESAA               ;vector base + $AA
00FFAC FFFFAC F7 1D                   VEC_RESAC               DW      ISR_RESAC               ;vector base + $AC
00FFAE FFFFAE F7 1D                   VEC_RESAE               DW      ISR_RESAE               ;vector base + $AE
00FFB0 FFFFB0 F7 1D                   VEC_RESB0               DW      ISR_RESB0               ;vector base + $A0
00FFB2 FFFFB2 F7 1D                   VEC_RESB2               DW      ISR_RESB2               ;vector base + $B2
00FFB4 FFFFB4 F7 1D                   VEC_RESB4               DW      ISR_RESB4               ;vector base + $B4
00FFB6 FFFFB6 F7 1D                   VEC_RESB6               DW      ISR_RESB6               ;vector base + $B6
00FFB8 FFFFB8 F7 1D                   VEC_RESB8               DW      ISR_RESB8               ;vector base + $B8
00FFBA FFFFBA F7 1D                   VEC_RESBA               DW      ISR_RESBA               ;vector base + $BA
00FFBC FFFFBC F7 1D                   VEC_RESBC               DW      ISR_RESBC               ;vector base + $BC
00FFBE FFFFBE F7 1D                   VEC_RESBE               DW      ISR_RESBE               ;vector base + $BE
00FFC0 FFFFC0 F7 1D                   VEC_RESC0               DW      ISR_RESC0               ;vector base + $C0
00FFC2 FFFFC2 F7 1D                   VEC_RESC2               DW      ISR_RESC2               ;vector base + $C2
00FFC4 FFFFC4 F7 1D                   VEC_RESC4               DW      ISR_RESC4               ;vector base + $C4
00FFC6 FFFFC6 F7 1D                   VEC_RESC6               DW      ISR_RESC6               ;vector base + $C6
00FFC8 FFFFC8 F7 1D                   VEC_RESC8               DW      ISR_RESC8               ;vector base + $C8
00FFCA FFFFCA F7 1D                   VEC_RESCA               DW      ISR_RESCA               ;vector base + $CA
00FFCC FFFFCC F7 1D                   VEC_RESCC               DW      ISR_RESCC               ;vector base + $CC
00FFCE FFFFCE F7 1D                   VEC_PORTH               DW      ISR_PORTH               ;vector base + $CE
00FFD0 FFFFD0 F7 1D                   VEC_PORTJ               DW      ISR_PORTJ               ;vector base + $D0
00FFD2 FFFFD2 F7 1D                   VEC_ATD                 DW      ISR_ATD                 ;vector base + $D2
00FFD4 FFFFD4 F7 1D                   VEC_SCI1                DW      ISR_SCI1                ;vector base + $D4
00FFD6 FFFFD6 F5 F8                   VEC_SCI0                DW      ISR_SCI0                ;vector base + $D6
00FFD8 FFFFD8 F7 1D                   VEC_SPI                 DW      ISR_SPI                 ;vector base + $D8
00FFDA FFFFDA F7 1D                   VEC_TIM_PAIE            DW      ISR_TIM_PAIE            ;vector base + $DA
00FFDC FFFFDC F7 1D                   VEC_TIM_PAOV            DW      ISR_TIM_PAOV            ;vector base + $DC
00FFDE FFFFDE F7 1D                   VEC_TIM_TOV             DW      ISR_TIM_TOV             ;vector base + $DE
00FFE0 FFFFE0 F7 1D                   VEC_TIM_TC7             DW      ISR_TIM_TC7             ;vector base + $E0
00FFE2 FFFFE2 F7 1D                   VEC_TIM_TC6             DW      ISR_TIM_TC6             ;vector base + $E2
00FFE4 FFFFE4 F7 1D                   VEC_TIM_TC5             DW      ISR_TIM_TC5             ;vector base + $E4
00FFE6 FFFFE6 F7 1D                   VEC_TIM_TC4             DW      ISR_TIM_TC4             ;vector base + $E6
00FFE8 FFFFE8 F5 95                   VEC_TIM_TC3             DW      ISR_TIM_TC3             ;vector base + $E8
00FFEA FFFFEA F7 1D                   VEC_TIM_TC2             DW      ISR_TIM_TC2             ;vector base + $EA
00FFEC FFFFEC F7 1D                   VEC_TIM_TC1             DW      ISR_TIM_TC1             ;vector base + $EC
00FFEE FFFFEE F7 1D                   VEC_TIM_TC0             DW      ISR_TIM_TC0             ;vector base + $EE
00FFF0 FFFFF0 F7 1D                   VEC_RTI                 DW      ISR_RTI                 ;vector base + $F0
00FFF2 FFFFF2 F7 1D                   VEC_IRQ                 DW      ISR_IRQ                 ;vector base + $F2
00FFF4 FFFFF4 F7 1D                   VEC_XIRQ                DW      ISR_XIRQ                ;vector base + $F4
00FFF6 FFFFF6 F7 1D                   VEC_SWI                 DW      ISR_SWI                 ;vector base + $F6
00FFF8 FFFFF8 F7 1D                   VEC_TRAP                DW      ISR_TRAP                ;vector base + $F8
00FFFA FFFFFA F6 D6                   VEC_RESET_COP           DW      RESET_COP_ENTRY         ;vector base + $FA
00FFFC FFFFFC F6 D6                   VEC_RESET_CM            DW      RESET_CM_ENTRY          ;vector base + $FC
00FFFE FFFFFE F6 D6                   VEC_RESET_EXT           DW      RESET_EXT_ENTRY         ;vector base + $FE
                                      ;###############################################################################
                                      ;# Includes                                                                    #
                                      ;###############################################################################
                                      ;###############################################################################
                                      ;# Variables                                                                   #
                                      ;###############################################################################
000800 0F4800                                                 ORG     DEMO_VARS_START, DEMO_VARS_START_LIN
000800 0F4800 -> $0800                DEMO_VARS_END           EQU     *
000800 0F4800 -> $F4800               DEMO_VARS_END_LIN       EQU     @
                                      ;###############################################################################
                                      ;# Code                                                                        #
                                      ;###############################################################################
00F000 0FF000                                                 ORG     DEMO_CODE_START, DEMO_CODE_START_LIN
                                      ;Initialization
00F000 0FF000 MACRO                                           BASE_INIT
                                      ;############################################################################### (BASE_INIT)
                                      ;# Macros                                                                      # (BASE_INIT)
                                      ;############################################################################### (BASE_INIT)
                                      ;#Initialization                                                                 (BASE_INIT)
00F000 0FF000 79 00 16                                        CLR     COPCTL ;disable COP                              (BASE_INIT)
00F003 0FF003 MACRO                                           GPIO_INIT                                                (BASE_INIT)
00F003 0FF003 MACRO                                           MMAP_INIT                                                (BASE_INIT)
                                      ;############################################################################### (BASE_INIT/MMAP_INIT)
                                      ;# Macros                                                                      # (BASE_INIT/MMAP_INIT)
                                      ;############################################################################### (BASE_INIT/MMAP_INIT)
                                      ;#Initialization                                                                 (BASE_INIT/MMAP_INIT)
00F003 0FF003 79 00 11                                        CLR     INITRG                                           (BASE_INIT/MMAP_INIT)
00F006 0FF006 18 0B 08 00 10                                  MOVB    #((MMAP_RAM_START>>8)&$F8), INITRM               (BASE_INIT/MMAP_INIT)
00F00B 0FF00B MACRO                                           VECTAB_INIT                                              (BASE_INIT)
00F00B 0FF00B MACRO                                           ISTACK_INIT                                              (BASE_INIT)
                                      ;############################################################################### (BASE_INIT/ISTACK_INIT)
                                      ;# Macros                                                                      # (BASE_INIT/ISTACK_INIT)
                                      ;############################################################################### (BASE_INIT/ISTACK_INIT)
                                      ;#Initialization                                                                 (BASE_INIT/ISTACK_INIT)
                                                              ;Set stack pointer                                       (BASE_INIT/ISTACK_INIT)
00F00B 0FF00B CF 08 25                                        LDS     #ISTACK_BOTTOM                                   (BASE_INIT/ISTACK_INIT)
                                                              ;Enable interrupts                                       (BASE_INIT/ISTACK_INIT)
00F00E 0FF00E 10 EF                                           CLI                                                      (BASE_INIT/ISTACK_INIT)
00F010 0FF010 MACRO                                           SSTACK_INIT                                              (BASE_INIT)
00F010 0FF010 MACRO                                           TIM_INIT                                                 (BASE_INIT)
                                      ;############################################################################### (BASE_INIT/TIM_INIT)
                                      ;# Macros                                                                      # (BASE_INIT/TIM_INIT)
                                      ;############################################################################### (BASE_INIT/TIM_INIT)
                                      ;#Initialization                                                                 (BASE_INIT/TIM_INIT)
                                                              ;MOVB   #%1_0_0_1_1_1_0_0, TIOS         ;default setup   (BASE_INIT/TIM_INIT)
                                                              ;MOVB   #%0_0_0_0_0_0_0_0, TIOS         ;keep at zero, for configuration with BSET (BASE_INIT/TIM_INIT)
                                                                       ;B B B   S S S S               ;  0=input capture (BASE_INIT/TIM_INIT)
                                                                       ;D D D   C C C C               ;  1=output compare (BASE_INIT/TIM_INIT)
                                                                       ;M M M   I I I I                                (BASE_INIT/TIM_INIT)
                                                                       ;T N P   T B B B                                (BASE_INIT/TIM_INIT)
                                                                       ;O E E   O D D D                                (BASE_INIT/TIM_INIT)
                                                                       ;          T N P                                (BASE_INIT/TIM_INIT)
                                                                       ;          O E E                                (BASE_INIT/TIM_INIT)
                                                              ;CFORC                                                   (BASE_INIT/TIM_INIT)
                                                              ;OC7M                                                    (BASE_INIT/TIM_INIT)
                                                                       ;7 6 5 4 3 2 1 0                                (BASE_INIT/TIM_INIT)
                                                              ;MOVB   #%0_1_0_0_0_0_0_0, TOC7D        ;default setup   (BASE_INIT/TIM_INIT)
                                                              ;MOVB   #%0_0_0_0_0_0_0_0, TOC7D        ;keep at zero, for configuration with BSET (BASE_INIT/TIM_INIT)
                                                                       ;B B B   S S S S                                (BASE_INIT/TIM_INIT)
                                                                       ;D D D   C C C C                                (BASE_INIT/TIM_INIT)
                                                                       ;M M M   I I I I                                (BASE_INIT/TIM_INIT)
                                                                       ;T N P   T B B B                                (BASE_INIT/TIM_INIT)
                                                                       ;O E E   O D D D                                (BASE_INIT/TIM_INIT)
                                                                       ;          T N P                                (BASE_INIT/TIM_INIT)
                                                                       ;          O E E                                (BASE_INIT/TIM_INIT)
                                                              ;TCNT                                                    (BASE_INIT/TIM_INIT)
00F010 0FF010 18 0B 01 00 8D                                  MOVB    #$01, TSCR2                     ;run on half bus frequency (BASE_INIT/TIM_INIT)
00F015 0FF015 MACRO                                           STRING_INIT                                              (BASE_INIT)
00F015 0FF015 MACRO                                           NUM_INIT                                                 (BASE_INIT)
00F015 0FF015 MACRO                                           NVM_INIT                                                 (BASE_INIT)
00F015 0FF015 MACRO                                           SCI_INIT                                                 (BASE_INIT)
                                      ;############################################################################### (BASE_INIT/SCI_INIT)
                                      ;# Macros                                                                      # (BASE_INIT/SCI_INIT)
                                      ;############################################################################### (BASE_INIT/SCI_INIT)
                                      ;#Initialization                                                                 (BASE_INIT/SCI_INIT)
                                                              ;Initialize queues and state flags                       (BASE_INIT/SCI_INIT)
00F015 0FF015 CC 00 00                                        LDD     #$0000                                           (BASE_INIT/SCI_INIT)
00F018 0FF018 7C 08 50                                        STD     SCI_TXBUF_IN                            ;reset in and out pointer of the TX buffer (BASE_INIT/SCI_INIT)
00F01B 0FF01B 7C 08 46                                        STD     SCI_RXBUF_IN                            ;reset in and out pointer of the RX buffer (BASE_INIT/SCI_INIT)
00F01E 0FF01E 7A 08 25                                        STAA    SCI_FLGS                                         (BASE_INIT/SCI_INIT)
                                                              ;Initialize baud rate detection                          (BASE_INIT/SCI_INIT)
                                                              ;Initialize timer                                        (BASE_INIT/SCI_INIT)
                                                              ;Invert RXD/TXD polarity                                 (BASE_INIT/SCI_INIT)
                                                              ;Set baud rate                                           (BASE_INIT/SCI_INIT)
                                                              ;Check for POR                                           (BASE_INIT/SCI_INIT)
                                                              ;Check if stored baud rate is still valid                (BASE_INIT/SCI_INIT)
00F021 0FF021 FC 08 52                                        LDD     SCI_BVAL                                ;SCI_BMUL*baud rate -> D (BASE_INIT/SCI_INIT)
00F024 0FF024 27 16                                           BEQ     SCI_INIT_2                              ;use default value if zero (BASE_INIT/SCI_INIT)
00F026 0FF026 CE 0C CC                                        LDX     #SCI_BMUL                               ;SCI_BMUL -> X (BASE_INIT/SCI_INIT)
00F029 0FF029 18 10                                           IDIV                                            ;D/X -> X, D%X -> D (BASE_INIT/SCI_INIT)
00F02B 0FF02B 8C 00 00                                        CPD     #$0000                                  ;check if the remainder is 0 (BASE_INIT/SCI_INIT)
00F02E 0FF02E 26 0C                                           BNE     SCI_INIT_2                              ;stored baud rate is invalid (BASE_INIT/SCI_INIT)
                                                              ;Check if baud rate is listed                            (BASE_INIT/SCI_INIT)
00F030 0FF030 CD F8 FE                                        LDY     #SCI_BTAB                               ;start of baud table -> Y (BASE_INIT/SCI_INIT)
00F033 0FF033 AE 71                   SCI_INIT_1              CPX     2,Y+                                    ;compare table entry with X (BASE_INIT/SCI_INIT)
00F035 0FF035 27 0E                                           BEQ     SCI_INIT_3                              ;match   (BASE_INIT/SCI_INIT)
00F037 0FF037 8D F9 0E                                        CPY     #SCI_BTAB_END                           ;check if the end of the table has been reached (BASE_INIT/SCI_INIT)
00F03A 0FF03A 26 F7                                           BNE     SCI_INIT_1                              ;loop    (BASE_INIT/SCI_INIT)
                                                              ;No match use default                                    (BASE_INIT/SCI_INIT)
00F03C 0FF03C CE 01 46                SCI_INIT_2              LDX     #SCI_BDEF                               ;default baud rate (BASE_INIT/SCI_INIT)
00F03F 0FF03F 18 03 4B C8 08 52                               MOVW    #(SCI_BDEF*SCI_BMUL), SCI_BVAL                   (BASE_INIT/SCI_INIT)
                                                              ;Match                                                   (BASE_INIT/SCI_INIT)
00F045 0FF045 5E C0                   SCI_INIT_3              STX     SCIBDH                                  ;set baud rate (BASE_INIT/SCI_INIT)
                                                              ;Set frame format and enable transmission                (BASE_INIT/SCI_INIT)
00F047 0FF047 18 03 04 2C 00 C2                               MOVW    #((SCI_8N1<<8)|RIE|TE|RE), SCICR1       ;8N1 (keep TX IRQs disabled) (BASE_INIT/SCI_INIT)
                                                              ;Initialize CTS                                          (BASE_INIT/SCI_INIT)
00F04D 0FF04D MACRO                                           SCI_ASSERT_CTS                                           (BASE_INIT/SCI_INIT)
00F04D 0FF04D MACRO                                           RESET_INIT                                               (BASE_INIT)
                                      ;############################################################################### (BASE_INIT/RESET_INIT)
                                      ;# Macros                                                                      # (BASE_INIT/RESET_INIT)
                                      ;############################################################################### (BASE_INIT/RESET_INIT)
                                      ;#Initialization                                                                 (BASE_INIT/RESET_INIT)
                                                              ;Check for POR                                           (BASE_INIT/RESET_INIT)
00F04D 0FF04D B6 08 55                                        LDAA    RESET_FLGS                                       (BASE_INIT/RESET_INIT)
00F050 0FF050 85 40                                           BITA    #RESET_FLG_POR                                   (BASE_INIT/RESET_INIT)
00F052 0FF052 26 45                                           BNE     <RESET_INIT_3            ;print welcome message  (BASE_INIT/RESET_INIT)
                                                              ;Check for power failure (flags in A)                    (BASE_INIT/RESET_INIT)
00F054 0FF054 CD F9 18                                        LDY     #RESET_STR_POWFAIL                               (BASE_INIT/RESET_INIT)
00F057 0FF057 85 20                                           BITA    #RESET_FLG_POWFAIL                               (BASE_INIT/RESET_INIT)
00F059 0FF059 26 13                                           BNE     <RESET_INIT_2            ;print error message    (BASE_INIT/RESET_INIT)
                                                              ;Check for clock failure (flags in A)                    (BASE_INIT/RESET_INIT)
                                                              ;Check for code runaway (flags in A)                     (BASE_INIT/RESET_INIT)
                                                              ;Check for COP reset (flags in A)                        (BASE_INIT/RESET_INIT)
                                                              ;Check custom error                                      (BASE_INIT/RESET_INIT)
00F05B 0FF05B FE 08 56                                        LDX     RESET_MSG                                        (BASE_INIT/RESET_INIT)
00F05E 0FF05E CD F0 64                                        LDY     #RESET_INIT_1                                    (BASE_INIT/RESET_INIT)
00F061 0FF061 06 F6 E2                                        JOB     RESET_CALC_CHECKSUM                              (BASE_INIT/RESET_INIT)
00F064 0FF064 -> $F064                RESET_INIT_1            EQU     *                                                (BASE_INIT/RESET_INIT)
00F064 0FF064 24 33                                           BCC     <RESET_INIT_3            ;print welcome message  (BASE_INIT/RESET_INIT)
                                                              ;Verify checksum (checksum in A)                         (BASE_INIT/RESET_INIT)
00F066 0FF066 B1 08 58                                        CMPA    RESET_MSG_CHKSUM                                 (BASE_INIT/RESET_INIT)
00F069 0FF069 26 2E                                           BNE     <RESET_INIT_3            ;print welcome message  (BASE_INIT/RESET_INIT)
00F06B 0FF06B FD 08 56                                        LDY     RESET_MSG                                        (BASE_INIT/RESET_INIT)
                                                              ;Print error message (error message in Y)                (BASE_INIT/RESET_INIT)
00F06E 0FF06E CE F9 11                RESET_INIT_2            LDX     #RESET_STR_FATAL                                 (BASE_INIT/RESET_INIT)
00F071 0FF071 MACRO                                           STRING_PRINT_BL                                          (BASE_INIT/RESET_INIT)
                                      ;#Basic print function - blocking                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
                                      ; args:   X:      start of the string                                            (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
                                      ; result: X;      points to the byte after the string                            (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
                                      ; SSTACK: 10 bytes                                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
                                      ;         Y and D are preserved                                                  (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
00F071 0FF071 MACRO                                           STRING_CALL_BL  STRING_PRINT_NB, 8                       (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ; args:   1: non-blocking function                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
00F071 0FF071                         LOOP                    ;Wait until TX buffer accepts new data                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
00F071 0FF071 MACRO                                           SCI_TX_READY_BL                                          (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
00F071 0FF071 MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F071 0FF071 MACRO                                           SSTACK_PREPUSH  \2                                       (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F071 0FF071 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F074 0FF074 18 25 02 D1                                     BLO     OF                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F078 0FF078 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F07B 0FF07B 18 22 02 D0                                     BHI     UF                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F07F 0FF07F -> $F34F                UF                      EQU     SSTACK_UF                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F07F 0FF07F -> $F349                OF                      EQU     SSTACK_OF                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F07F 0FF07F 16 F4 5D                                        JOBSR   \1                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
00F082 0FF082 MACRO                                           SSTACK_JOBSR    \1, \2                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ;#Check stack and call subroutine                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F082 0FF082 MACRO                                           SSTACK_PREPUSH  \2                                       (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F082 0FF082 8F 08 12                                        CPS     #SSTACK_TOP+\1                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F085 0FF085 18 25 02 C0                                     BLO     OF                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F089 0FF089 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F08C 0FF08C 18 22 02 BF                                     BHI     UF                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F090 0FF090 -> $F34F                UF                      EQU     SSTACK_UF                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F090 0FF090 -> $F349                OF                      EQU     SSTACK_OF                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F090 0FF090 16 F6 72                                        JOBSR   \1                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F093 0FF093 24 DC                                           BCC     LOOP            ;function unsuccessful           (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
00F095 0FF095 B7 65                                           TFR     Y, X                                             (BASE_INIT/RESET_INIT)
00F097 0FF097 20 03                                           JOB     RESET_INIT_4                                     (BASE_INIT/RESET_INIT)
                                                              ;Print welcome message                                   (BASE_INIT/RESET_INIT)
00F099 0FF099 CE F8 22                RESET_INIT_3            LDX     #RESET_WELCOME                                   (BASE_INIT/RESET_INIT)
00F09C 0FF09C MACRO                   RESET_INIT_4            STRING_PRINT_BL                                          (BASE_INIT/RESET_INIT)
                                      ;#Basic print function - blocking                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
                                      ; args:   X:      start of the string                                            (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
                                      ; result: X;      points to the byte after the string                            (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
                                      ; SSTACK: 10 bytes                                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
                                      ;         Y and D are preserved                                                  (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
00F09C 0FF09C MACRO                                           STRING_CALL_BL  STRING_PRINT_NB, 8                       (BASE_INIT/RESET_INIT/STRING_PRINT_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ; args:   1: non-blocking function                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
00F09C 0FF09C                         LOOP                    ;Wait until TX buffer accepts new data                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
00F09C 0FF09C MACRO                                           SCI_TX_READY_BL                                          (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
00F09C 0FF09C MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F09C 0FF09C MACRO                                           SSTACK_PREPUSH  \2                                       (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F09C 0FF09C 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F09F 0FF09F 18 25 02 A6                                     BLO     OF                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0A3 0FF0A3 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0A6 0FF0A6 18 22 02 A5                                     BHI     UF                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0AA 0FF0AA -> $F34F                UF                      EQU     SSTACK_UF                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0AA 0FF0AA -> $F349                OF                      EQU     SSTACK_OF                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0AA 0FF0AA 16 F4 5D                                        JOBSR   \1                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
00F0AD 0FF0AD MACRO                                           SSTACK_JOBSR    \1, \2                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                      ;#Check stack and call subroutine                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F0AD 0FF0AD MACRO                                           SSTACK_PREPUSH  \2                                       (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0AD 0FF0AD 8F 08 12                                        CPS     #SSTACK_TOP+\1                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0B0 0FF0B0 18 25 02 95                                     BLO     OF                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0B4 0FF0B4 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0B7 0FF0B7 18 22 02 94                                     BHI     UF                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0BB 0FF0BB -> $F34F                UF                      EQU     SSTACK_UF                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0BB 0FF0BB -> $F349                OF                      EQU     SSTACK_OF                                        (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0BB 0FF0BB 16 F6 72                                        JOBSR   \1                                               (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F0BE 0FF0BE 24 DC                                           BCC     LOOP            ;function unsuccessful           (BASE_INIT/RESET_INIT/STRING_PRINT_BL/STRING_CALL_BL)
                                                              ;Print exlamation mark and new line                      (BASE_INIT/RESET_INIT)
                                                              ;LDX    #STRING_STR_EXCLAM_NL                            (BASE_INIT/RESET_INIT)
                                                              ;STRING_PRINT_BL                                         (BASE_INIT/RESET_INIT)
                                                              ;Remove custom error message                             (BASE_INIT/RESET_INIT)
00F0C0 0FF0C0 DC 00                                           LDD     $0000                                            (BASE_INIT/RESET_INIT)
00F0C2 0FF0C2 7C 08 56                                        STD     RESET_MSG                                        (BASE_INIT/RESET_INIT)
00F0C5 0FF0C5 7A 08 58                                        STAA    RESET_MSG_CHKSUM                                 (BASE_INIT/RESET_INIT)
                                                              ;Wait until message has been transmitted                 (BASE_INIT/RESET_INIT)
00F0C8 0FF0C8 MACRO                                           SCI_TX_DONE_BL                                           (BASE_INIT/RESET_INIT)
                                      ;#Wait until all pending data is sent                                            (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL)
                                      ; args:   none                                                                   (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL)
                                      ; result: A: number of entries left in TX queue                                  (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL)
                                      ; SSTACK: 6 bytes                                                                (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL)
                                      ;         X, Y, and D are preserved                                              (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL)
00F0C8 0FF0C8 MACRO                                           SSTACK_JOBSR    SCI_TX_DONE_BL, 6                        (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL)
                                      ;#Check stack and call subroutine                                                (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR)
00F0C8 0FF0C8 MACRO                                           SSTACK_PREPUSH  \2                                       (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR)
                                      ;############################################################################### (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0C8 0FF0C8 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0CB 0FF0CB 18 25 02 7A                                     BLO     OF                                               (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0CF 0FF0CF 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0D2 0FF0D2 18 22 02 79                                     BHI     UF                                               (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0D6 0FF0D6 -> $F34F                UF                      EQU     SSTACK_UF                                        (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0D6 0FF0D6 -> $F349                OF                      EQU     SSTACK_OF                                        (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0D6 0FF0D6 16 F3 F5                                        JOBSR   \1                                               (BASE_INIT/RESET_INIT/SCI_TX_DONE_BL/SSTACK_JOBSR)
00F0D9 0FF0D9 18 0B C0 00 AF                                  MOVB    #$C0, DDRT
                                      ;Application code
00F0DE 0FF0DE MACRO                   DEMO_LOOP               SCI_RX_BL
                                      ;#Receive one byte - blocking                                                    (SCI_RX_BL)
                                      ; args:   none                                                                   (SCI_RX_BL)
                                      ; result: A: error flags                                                         (SCI_RX_BL)
                                      ;         B: received data                                                       (SCI_RX_BL)
                                      ; SSTACK: 6 bytes                                                                (SCI_RX_BL)
                                      ;         X and Y are preserved                                                  (SCI_RX_BL)
00F0DE 0FF0DE MACRO                                           SSTACK_JOBSR    SCI_RX_BL, 6                             (SCI_RX_BL)
                                      ;#Check stack and call subroutine                                                (SCI_RX_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (SCI_RX_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (SCI_RX_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (SCI_RX_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (SCI_RX_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (SCI_RX_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (SCI_RX_BL/SSTACK_JOBSR)
00F0DE 0FF0DE MACRO                                           SSTACK_PREPUSH  \2                                       (SCI_RX_BL/SSTACK_JOBSR)
                                      ;############################################################################### (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0DE 0FF0DE 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0E1 0FF0E1 18 25 02 64                                     BLO     OF                                               (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0E5 0FF0E5 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0E8 0FF0E8 18 22 02 63                                     BHI     UF                                               (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0EC 0FF0EC -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0EC 0FF0EC -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_RX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0EC 0FF0EC 16 F4 D7                                        JOBSR   \1                                               (SCI_RX_BL/SSTACK_JOBSR)
                                                              ;Ignore RX errors
00F0EF 0FF0EF 84 1F                                           ANDA    #(SCI_FLG_SWOR|OR|NF|FE|PF)
00F0F1 0FF0F1 26 EB                                           BNE     DEMO_LOOP
                                                              ;TBNE   A, DEMO_LOOP
                                                              ;Print ASCII character (char in B)
00F0F3 0FF0F3 B7 45                                           TFR     D, X
00F0F5 0FF0F5 86 04                                           LDAA    #4
00F0F7 0FF0F7 C6 20                                           LDAB    #" "
00F0F9 0FF0F9 MACRO                                           STRING_FILL_BL
                                      ;#Print a number of filler characters - blocking                                 (STRING_FILL_BL)
                                      ; args:   A: number of characters to be printed                                  (STRING_FILL_BL)
                                      ;         B: filler character                                                    (STRING_FILL_BL)
                                      ; result: A: $00                                                                 (STRING_FILL_BL)
                                      ; SSTACK: 9 bytes                                                                (STRING_FILL_BL)
                                      ;         X, Y and B are preserved                                               (STRING_FILL_BL)
00F0F9 0FF0F9 MACRO                                           STRING_CALL_BL  STRING_FILL_NB, 7                        (STRING_FILL_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; args:   1: non-blocking function                                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (STRING_FILL_BL/STRING_CALL_BL)
00F0F9 0FF0F9                         LOOP                    ;Wait until TX buffer accepts new data                   (STRING_FILL_BL/STRING_CALL_BL)
00F0F9 0FF0F9 MACRO                                           SCI_TX_READY_BL                                          (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
00F0F9 0FF0F9 MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F0F9 0FF0F9 MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0F9 0FF0F9 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F0FC 0FF0FC 18 25 02 49                                     BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F100 0FF100 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F103 0FF103 18 22 02 48                                     BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F107 0FF107 -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F107 0FF107 -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F107 0FF107 16 F4 5D                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (STRING_FILL_BL/STRING_CALL_BL)
00F10A 0FF10A MACRO                                           SSTACK_JOBSR    \1, \2                                   (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F10A 0FF10A MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F10A 0FF10A 8F 08 11                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F10D 0FF10D 18 25 02 38                                     BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F111 0FF111 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F114 0FF114 18 22 02 37                                     BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F118 0FF118 -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F118 0FF118 -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F118 0FF118 16 F6 A9                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F11B 0FF11B 24 DC                                           BCC     LOOP            ;function unsuccessful           (STRING_FILL_BL/STRING_CALL_BL)
00F11D 0FF11D B7 54                                           TFR     X, D
00F11F 0FF11F 87                                              CLRA
00F120 0FF120 MACRO                                           STRING_MAKE_PRINTABLE_B
                                      ;#Make ASCII character printable                                                 (STRING_MAKE_PRINTABLE_B)
                                      ; args:   B: ASCII character (w/out termination)                                 (STRING_MAKE_PRINTABLE_B)
                                      ; result: B: printable ASCII character or "."                                    (STRING_MAKE_PRINTABLE_B)
                                      ; SSTACK: none                                                                   (STRING_MAKE_PRINTABLE_B)
                                      ;         X, Y, and A are preserved                                              (STRING_MAKE_PRINTABLE_B)
00F120 0FF120 C1 20                                           CMPB    #$20            ;" "                             (STRING_MAKE_PRINTABLE_B)
00F122 0FF122 25 04                                           BLO     ADJUST                                           (STRING_MAKE_PRINTABLE_B)
00F124 0FF124 C1 7E                                           CMPB    #$7E            ;"~"                             (STRING_MAKE_PRINTABLE_B)
00F126 0FF126 23 02                                           BLS     DONE                                             (STRING_MAKE_PRINTABLE_B)
00F128 0FF128 C6 2E                   ADJUST                  LDAB    #$2E            ;"."                             (STRING_MAKE_PRINTABLE_B)
00F12A 0FF12A -> $F12A                DONE                    EQU     *                                                (STRING_MAKE_PRINTABLE_B)
00F12A 0FF12A MACRO                                           SCI_TX_BL
                                      ;#Transmit one byte - blocking                                                   (SCI_TX_BL)
                                      ; args:   B: data to be send                                                     (SCI_TX_BL)
                                      ; SSTACK: 7 bytes                                                                (SCI_TX_BL)
                                      ;         X, Y, and D are preserved                                              (SCI_TX_BL)
00F12A 0FF12A MACRO                                           SSTACK_JOBSR    SCI_TX_BL, 7                             (SCI_TX_BL)
                                      ;#Check stack and call subroutine                                                (SCI_TX_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (SCI_TX_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (SCI_TX_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (SCI_TX_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (SCI_TX_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (SCI_TX_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (SCI_TX_BL/SSTACK_JOBSR)
00F12A 0FF12A MACRO                                           SSTACK_PREPUSH  \2                                       (SCI_TX_BL/SSTACK_JOBSR)
                                      ;############################################################################### (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F12A 0FF12A 8F 08 11                                        CPS     #SSTACK_TOP+\1                                   (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F12D 0FF12D 18 25 02 18                                     BLO     OF                                               (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F131 0FF131 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F134 0FF134 18 22 02 17                                     BHI     UF                                               (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F138 0FF138 -> $F34F                UF                      EQU     SSTACK_UF                                        (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F138 0FF138 -> $F349                OF                      EQU     SSTACK_OF                                        (SCI_TX_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F138 0FF138 16 F3 99                                        JOBSR   \1                                               (SCI_TX_BL/SSTACK_JOBSR)
                                                              ;Print hexadecimal value (char in X)
00F13B 0FF13B CD 00 00                                        LDY     #$0000
00F13E 0FF13E C6 10                                           LDAB    #16
00F140 0FF140 MACRO                                           NUM_REVERSE
                                      ;############################################################################### (NUM_REVERSE)
                                      ;# Macros                                                                      # (NUM_REVERSE)
                                      ;############################################################################### (NUM_REVERSE)
                                      ;#Initialization                                                                 (NUM_REVERSE)
                                      ;#Reverse unsigned double word                                                   (NUM_REVERSE)
                                      ; args:   Y:X: unsigned double value                                             (NUM_REVERSE)
                                      ;         B:   base   (2<=base<=16)                                              (NUM_REVERSE)
                                      ; result: A:   number of digits                                                  (NUM_REVERSE)
                                      ;         SP+0: MSB                                                              (NUM_REVERSE)
                                      ;         SP+1:  |                                                               (NUM_REVERSE)
                                      ;         SP+2:  |reverse                                                        (NUM_REVERSE)
                                      ;         SP+3:  |number                                                         (NUM_REVERSE)
                                      ;         SP+4:  |                                                               (NUM_REVERSE)
                                      ;         SP+5: LSB                                                              (NUM_REVERSE)
                                      ; SSTACK: 18 bytes                                                               (NUM_REVERSE)
                                      ;         X, Y and B are preserved                                               (NUM_REVERSE)
00F140 0FF140 MACRO                                           SSTACK_JOBSR    NUM_REVERSE, 18                          (NUM_REVERSE)
                                      ;#Check stack and call subroutine                                                (NUM_REVERSE/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVERSE/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVERSE/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVERSE/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVERSE/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVERSE/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVERSE/SSTACK_JOBSR)
00F140 0FF140 MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVERSE/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F140 0FF140 8F 08 1C                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F143 0FF143 18 25 02 02                                     BLO     OF                                               (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F147 0FF147 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F14A 0FF14A 18 22 02 01                                     BHI     UF                                               (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F14E 0FF14E -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F14E 0FF14E -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F14E 0FF14E 16 F7 22                                        JOBSR   \1                                               (NUM_REVERSE/SSTACK_JOBSR)
00F151 0FF151 B7 76                                           TFR     SP, Y
00F153 0FF153 40                                              NEGA
00F154 0FF154 8B 05                                           ADDA    #5
00F156 0FF156 C6 20                                           LDAB    #" "
00F158 0FF158 MACRO                                           STRING_FILL_BL
                                      ;#Print a number of filler characters - blocking                                 (STRING_FILL_BL)
                                      ; args:   A: number of characters to be printed                                  (STRING_FILL_BL)
                                      ;         B: filler character                                                    (STRING_FILL_BL)
                                      ; result: A: $00                                                                 (STRING_FILL_BL)
                                      ; SSTACK: 9 bytes                                                                (STRING_FILL_BL)
                                      ;         X, Y and B are preserved                                               (STRING_FILL_BL)
00F158 0FF158 MACRO                                           STRING_CALL_BL  STRING_FILL_NB, 7                        (STRING_FILL_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; args:   1: non-blocking function                                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (STRING_FILL_BL/STRING_CALL_BL)
00F158 0FF158                         LOOP                    ;Wait until TX buffer accepts new data                   (STRING_FILL_BL/STRING_CALL_BL)
00F158 0FF158 MACRO                                           SCI_TX_READY_BL                                          (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
00F158 0FF158 MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F158 0FF158 MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F158 0FF158 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F15B 0FF15B 18 25 01 EA                                     BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F15F 0FF15F 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F162 0FF162 18 22 01 E9                                     BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F166 0FF166 -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F166 0FF166 -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F166 0FF166 16 F4 5D                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (STRING_FILL_BL/STRING_CALL_BL)
00F169 0FF169 MACRO                                           SSTACK_JOBSR    \1, \2                                   (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F169 0FF169 MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F169 0FF169 8F 08 11                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F16C 0FF16C 18 25 01 D9                                     BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F170 0FF170 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F173 0FF173 18 22 01 D8                                     BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F177 0FF177 -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F177 0FF177 -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F177 0FF177 16 F6 A9                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F17A 0FF17A 24 DC                                           BCC     LOOP            ;function unsuccessful           (STRING_FILL_BL/STRING_CALL_BL)
00F17C 0FF17C C6 10                                           LDAB    #16
00F17E 0FF17E MACRO                                           NUM_REVPRINT_BL
                                      ;#Print a reserse number digit - blocking                                        (NUM_REVPRINT_BL)
                                      ; args:   B:    base (2<=base<=16)                                               (NUM_REVPRINT_BL)
                                      ;         SP+0: MSB                                                              (NUM_REVPRINT_BL)
                                      ;         SP+1:  |                                                               (NUM_REVPRINT_BL)
                                      ;         SP+2:  |reverse                                                        (NUM_REVPRINT_BL)
                                      ;         SP+3:  |number                                                         (NUM_REVPRINT_BL)
                                      ;         SP+4:  |                                                               (NUM_REVPRINT_BL)
                                      ;         SP+5: LSB                                                              (NUM_REVPRINT_BL)
                                      ; result: SP+0: MSB                                                              (NUM_REVPRINT_BL)
                                      ;         SP+1:  |remaining                                                      (NUM_REVPRINT_BL)
                                      ;         SP+2:  | digits of                                                     (NUM_REVPRINT_BL)
                                      ;         SP+3:  |reverse                                                        (NUM_REVPRINT_BL)
                                      ;         SP+4:  |number                                                         (NUM_REVPRINT_BL)
                                      ;         SP+5: LSB                                                              (NUM_REVPRINT_BL)
                                      ;         C-flag: set if successful                                              (NUM_REVPRINT_BL)
                                      ; SSTACK: 8 bytes                                                                (NUM_REVPRINT_BL)
                                      ;         X, Y and D are preserved                                               (NUM_REVPRINT_BL)
00F17E 0FF17E MACRO                                           NUM_CALL_BL     NUM_REVPRINT_NB, 19                      (NUM_REVPRINT_BL)
                                      ;#Turn a non-blocking subroutine into a blocking subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; args:   1: non-blocking function                                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#macro NUM_MAKE_BL, 2                                                           (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       ;Call non-blocking subroutine as if it was blocking      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       NUM_CALL_BL     \1, \2                                   (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       ;Done                                                    (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       SSTACK_PREPULL  2                                        (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       RTS                                                      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#emac                                                                           (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; args:   1: non-blocking function                                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (NUM_REVPRINT_BL/NUM_CALL_BL)
00F17E 0FF17E                         LOOP                    ;Wait until TX buffer accepts new data                   (NUM_REVPRINT_BL/NUM_CALL_BL)
00F17E 0FF17E MACRO                                           SCI_TX_READY_BL                                          (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
00F17E 0FF17E MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F17E 0FF17E MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F17E 0FF17E 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F181 0FF181 18 25 01 C4                                     BLO     OF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F185 0FF185 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F188 0FF188 18 22 01 C3                                     BHI     UF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F18C 0FF18C -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F18C 0FF18C -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F18C 0FF18C 16 F4 5D                                        JOBSR   \1                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (NUM_REVPRINT_BL/NUM_CALL_BL)
00F18F 0FF18F MACRO                                           SSTACK_JOBSR    \1, \2                                   (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Check stack and call subroutine                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
00F18F 0FF18F MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F18F 0FF18F 8F 08 1D                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F192 0FF192 18 25 01 B3                                     BLO     OF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F196 0FF196 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F199 0FF199 18 22 01 B2                                     BHI     UF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F19D 0FF19D -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F19D 0FF19D -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F19D 0FF19D 16 F7 AF                                        JOBSR   \1                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
00F1A0 0FF1A0 24 DC                                           BCC     LOOP            ;function unsuccessful           (NUM_REVPRINT_BL/NUM_CALL_BL)
00F1A2 0FF1A2 MACRO                                           NUM_CLEAN_REVERSE
                                      ;#Clean-up stack space for reverse unsigned double word                          (NUM_CLEAN_REVERSE)
                                      ; args:   SP+0: MSB                                                              (NUM_CLEAN_REVERSE)
                                      ;         SP+1:  |                                                               (NUM_CLEAN_REVERSE)
                                      ;         SP+2:  |reverse                                                        (NUM_CLEAN_REVERSE)
                                      ;         SP+3:  |number                                                         (NUM_CLEAN_REVERSE)
                                      ;         SP+4:  |                                                               (NUM_CLEAN_REVERSE)
                                      ;         SP+5: LSB                                                              (NUM_CLEAN_REVERSE)
                                      ; result: none                                                                   (NUM_CLEAN_REVERSE)
                                      ; SSTACK: 18 bytes                                                               (NUM_CLEAN_REVERSE)
                                      ;         X, Y and B are preserved                                               (NUM_CLEAN_REVERSE)
00F1A2 0FF1A2 MACRO                                           SSTACK_PREPULL  6                                        (NUM_CLEAN_REVERSE)
                                      ;#Check stack before pull operation                                              (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; result: none                                                                   (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F1A2 0FF1A2 8F 08 0A                                        CPS     #SSTACK_TOP                                      (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F1A5 0FF1A5 18 25 01 A0                                     BLO     OF                                               (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F1A9 0FF1A9 8F 08 1F                                        CPS     #SSTACK_BOTTOM-\1                                (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F1AC 0FF1AC 18 22 01 9F                                     BHI     UF                                               (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F1B0 0FF1B0 -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F1B0 0FF1B0 -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F1B0 0FF1B0 1B 86                                           LEAS    6,SP                                             (NUM_CLEAN_REVERSE)
                                                              ;Print decimal value (char in X)
00F1B2 0FF1B2 CD 00 00                                        LDY     #$0000
00F1B5 0FF1B5 C6 0A                                           LDAB    #10
00F1B7 0FF1B7 MACRO                                           NUM_REVERSE
                                      ;############################################################################### (NUM_REVERSE)
                                      ;# Macros                                                                      # (NUM_REVERSE)
                                      ;############################################################################### (NUM_REVERSE)
                                      ;#Initialization                                                                 (NUM_REVERSE)
                                      ;#Reverse unsigned double word                                                   (NUM_REVERSE)
                                      ; args:   Y:X: unsigned double value                                             (NUM_REVERSE)
                                      ;         B:   base   (2<=base<=16)                                              (NUM_REVERSE)
                                      ; result: A:   number of digits                                                  (NUM_REVERSE)
                                      ;         SP+0: MSB                                                              (NUM_REVERSE)
                                      ;         SP+1:  |                                                               (NUM_REVERSE)
                                      ;         SP+2:  |reverse                                                        (NUM_REVERSE)
                                      ;         SP+3:  |number                                                         (NUM_REVERSE)
                                      ;         SP+4:  |                                                               (NUM_REVERSE)
                                      ;         SP+5: LSB                                                              (NUM_REVERSE)
                                      ; SSTACK: 18 bytes                                                               (NUM_REVERSE)
                                      ;         X, Y and B are preserved                                               (NUM_REVERSE)
00F1B7 0FF1B7 MACRO                                           SSTACK_JOBSR    NUM_REVERSE, 18                          (NUM_REVERSE)
                                      ;#Check stack and call subroutine                                                (NUM_REVERSE/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVERSE/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVERSE/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVERSE/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVERSE/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVERSE/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVERSE/SSTACK_JOBSR)
00F1B7 0FF1B7 MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVERSE/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1B7 0FF1B7 8F 08 1C                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1BA 0FF1BA 18 25 01 8B                                     BLO     OF                                               (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1BE 0FF1BE 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1C1 0FF1C1 18 22 01 8A                                     BHI     UF                                               (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1C5 0FF1C5 -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1C5 0FF1C5 -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1C5 0FF1C5 16 F7 22                                        JOBSR   \1                                               (NUM_REVERSE/SSTACK_JOBSR)
00F1C8 0FF1C8 B7 76                                           TFR     SP, Y
00F1CA 0FF1CA 40                                              NEGA
00F1CB 0FF1CB 8B 05                                           ADDA    #5
00F1CD 0FF1CD C6 20                                           LDAB    #" "
00F1CF 0FF1CF MACRO                                           STRING_FILL_BL
                                      ;#Print a number of filler characters - blocking                                 (STRING_FILL_BL)
                                      ; args:   A: number of characters to be printed                                  (STRING_FILL_BL)
                                      ;         B: filler character                                                    (STRING_FILL_BL)
                                      ; result: A: $00                                                                 (STRING_FILL_BL)
                                      ; SSTACK: 9 bytes                                                                (STRING_FILL_BL)
                                      ;         X, Y and B are preserved                                               (STRING_FILL_BL)
00F1CF 0FF1CF MACRO                                           STRING_CALL_BL  STRING_FILL_NB, 7                        (STRING_FILL_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; args:   1: non-blocking function                                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (STRING_FILL_BL/STRING_CALL_BL)
00F1CF 0FF1CF                         LOOP                    ;Wait until TX buffer accepts new data                   (STRING_FILL_BL/STRING_CALL_BL)
00F1CF 0FF1CF MACRO                                           SCI_TX_READY_BL                                          (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
00F1CF 0FF1CF MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F1CF 0FF1CF MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1CF 0FF1CF 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1D2 0FF1D2 18 25 01 73                                     BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1D6 0FF1D6 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1D9 0FF1D9 18 22 01 72                                     BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1DD 0FF1DD -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1DD 0FF1DD -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1DD 0FF1DD 16 F4 5D                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (STRING_FILL_BL/STRING_CALL_BL)
00F1E0 0FF1E0 MACRO                                           SSTACK_JOBSR    \1, \2                                   (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F1E0 0FF1E0 MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1E0 0FF1E0 8F 08 11                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1E3 0FF1E3 18 25 01 62                                     BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1E7 0FF1E7 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1EA 0FF1EA 18 22 01 61                                     BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1EE 0FF1EE -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1EE 0FF1EE -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1EE 0FF1EE 16 F6 A9                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F1F1 0FF1F1 24 DC                                           BCC     LOOP            ;function unsuccessful           (STRING_FILL_BL/STRING_CALL_BL)
00F1F3 0FF1F3 C6 0A                                           LDAB    #10
00F1F5 0FF1F5 MACRO                                           NUM_REVPRINT_BL
                                      ;#Print a reserse number digit - blocking                                        (NUM_REVPRINT_BL)
                                      ; args:   B:    base (2<=base<=16)                                               (NUM_REVPRINT_BL)
                                      ;         SP+0: MSB                                                              (NUM_REVPRINT_BL)
                                      ;         SP+1:  |                                                               (NUM_REVPRINT_BL)
                                      ;         SP+2:  |reverse                                                        (NUM_REVPRINT_BL)
                                      ;         SP+3:  |number                                                         (NUM_REVPRINT_BL)
                                      ;         SP+4:  |                                                               (NUM_REVPRINT_BL)
                                      ;         SP+5: LSB                                                              (NUM_REVPRINT_BL)
                                      ; result: SP+0: MSB                                                              (NUM_REVPRINT_BL)
                                      ;         SP+1:  |remaining                                                      (NUM_REVPRINT_BL)
                                      ;         SP+2:  | digits of                                                     (NUM_REVPRINT_BL)
                                      ;         SP+3:  |reverse                                                        (NUM_REVPRINT_BL)
                                      ;         SP+4:  |number                                                         (NUM_REVPRINT_BL)
                                      ;         SP+5: LSB                                                              (NUM_REVPRINT_BL)
                                      ;         C-flag: set if successful                                              (NUM_REVPRINT_BL)
                                      ; SSTACK: 8 bytes                                                                (NUM_REVPRINT_BL)
                                      ;         X, Y and D are preserved                                               (NUM_REVPRINT_BL)
00F1F5 0FF1F5 MACRO                                           NUM_CALL_BL     NUM_REVPRINT_NB, 19                      (NUM_REVPRINT_BL)
                                      ;#Turn a non-blocking subroutine into a blocking subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; args:   1: non-blocking function                                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#macro NUM_MAKE_BL, 2                                                           (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       ;Call non-blocking subroutine as if it was blocking      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       NUM_CALL_BL     \1, \2                                   (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       ;Done                                                    (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       SSTACK_PREPULL  2                                        (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       RTS                                                      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#emac                                                                           (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; args:   1: non-blocking function                                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (NUM_REVPRINT_BL/NUM_CALL_BL)
00F1F5 0FF1F5                         LOOP                    ;Wait until TX buffer accepts new data                   (NUM_REVPRINT_BL/NUM_CALL_BL)
00F1F5 0FF1F5 MACRO                                           SCI_TX_READY_BL                                          (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
00F1F5 0FF1F5 MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F1F5 0FF1F5 MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1F5 0FF1F5 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1F8 0FF1F8 18 25 01 4D                                     BLO     OF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1FC 0FF1FC 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F1FF 0FF1FF 18 22 01 4C                                     BHI     UF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F203 0FF203 -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F203 0FF203 -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F203 0FF203 16 F4 5D                                        JOBSR   \1                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (NUM_REVPRINT_BL/NUM_CALL_BL)
00F206 0FF206 MACRO                                           SSTACK_JOBSR    \1, \2                                   (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Check stack and call subroutine                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
00F206 0FF206 MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F206 0FF206 8F 08 1D                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F209 0FF209 18 25 01 3C                                     BLO     OF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F20D 0FF20D 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F210 0FF210 18 22 01 3B                                     BHI     UF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F214 0FF214 -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F214 0FF214 -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F214 0FF214 16 F7 AF                                        JOBSR   \1                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
00F217 0FF217 24 DC                                           BCC     LOOP            ;function unsuccessful           (NUM_REVPRINT_BL/NUM_CALL_BL)
00F219 0FF219 MACRO                                           NUM_CLEAN_REVERSE
                                      ;#Clean-up stack space for reverse unsigned double word                          (NUM_CLEAN_REVERSE)
                                      ; args:   SP+0: MSB                                                              (NUM_CLEAN_REVERSE)
                                      ;         SP+1:  |                                                               (NUM_CLEAN_REVERSE)
                                      ;         SP+2:  |reverse                                                        (NUM_CLEAN_REVERSE)
                                      ;         SP+3:  |number                                                         (NUM_CLEAN_REVERSE)
                                      ;         SP+4:  |                                                               (NUM_CLEAN_REVERSE)
                                      ;         SP+5: LSB                                                              (NUM_CLEAN_REVERSE)
                                      ; result: none                                                                   (NUM_CLEAN_REVERSE)
                                      ; SSTACK: 18 bytes                                                               (NUM_CLEAN_REVERSE)
                                      ;         X, Y and B are preserved                                               (NUM_CLEAN_REVERSE)
00F219 0FF219 MACRO                                           SSTACK_PREPULL  6                                        (NUM_CLEAN_REVERSE)
                                      ;#Check stack before pull operation                                              (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; result: none                                                                   (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F219 0FF219 8F 08 0A                                        CPS     #SSTACK_TOP                                      (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F21C 0FF21C 18 25 01 29                                     BLO     OF                                               (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F220 0FF220 8F 08 1F                                        CPS     #SSTACK_BOTTOM-\1                                (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F223 0FF223 18 22 01 28                                     BHI     UF                                               (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F227 0FF227 -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F227 0FF227 -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F227 0FF227 1B 86                                           LEAS    6,SP                                             (NUM_CLEAN_REVERSE)
                                                              ;Print octal value (char in X)
00F229 0FF229 CD 00 00                                        LDY     #$0000
00F22C 0FF22C C6 08                                           LDAB    #8
00F22E 0FF22E MACRO                                           NUM_REVERSE
                                      ;############################################################################### (NUM_REVERSE)
                                      ;# Macros                                                                      # (NUM_REVERSE)
                                      ;############################################################################### (NUM_REVERSE)
                                      ;#Initialization                                                                 (NUM_REVERSE)
                                      ;#Reverse unsigned double word                                                   (NUM_REVERSE)
                                      ; args:   Y:X: unsigned double value                                             (NUM_REVERSE)
                                      ;         B:   base   (2<=base<=16)                                              (NUM_REVERSE)
                                      ; result: A:   number of digits                                                  (NUM_REVERSE)
                                      ;         SP+0: MSB                                                              (NUM_REVERSE)
                                      ;         SP+1:  |                                                               (NUM_REVERSE)
                                      ;         SP+2:  |reverse                                                        (NUM_REVERSE)
                                      ;         SP+3:  |number                                                         (NUM_REVERSE)
                                      ;         SP+4:  |                                                               (NUM_REVERSE)
                                      ;         SP+5: LSB                                                              (NUM_REVERSE)
                                      ; SSTACK: 18 bytes                                                               (NUM_REVERSE)
                                      ;         X, Y and B are preserved                                               (NUM_REVERSE)
00F22E 0FF22E MACRO                                           SSTACK_JOBSR    NUM_REVERSE, 18                          (NUM_REVERSE)
                                      ;#Check stack and call subroutine                                                (NUM_REVERSE/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVERSE/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVERSE/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVERSE/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVERSE/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVERSE/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVERSE/SSTACK_JOBSR)
00F22E 0FF22E MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVERSE/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F22E 0FF22E 8F 08 1C                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F231 0FF231 18 25 01 14                                     BLO     OF                                               (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F235 0FF235 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F238 0FF238 18 22 01 13                                     BHI     UF                                               (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F23C 0FF23C -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F23C 0FF23C -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F23C 0FF23C 16 F7 22                                        JOBSR   \1                                               (NUM_REVERSE/SSTACK_JOBSR)
00F23F 0FF23F B7 76                                           TFR     SP, Y
00F241 0FF241 40                                              NEGA
00F242 0FF242 8B 05                                           ADDA    #5
00F244 0FF244 C6 20                                           LDAB    #" "
00F246 0FF246 MACRO                                           STRING_FILL_BL
                                      ;#Print a number of filler characters - blocking                                 (STRING_FILL_BL)
                                      ; args:   A: number of characters to be printed                                  (STRING_FILL_BL)
                                      ;         B: filler character                                                    (STRING_FILL_BL)
                                      ; result: A: $00                                                                 (STRING_FILL_BL)
                                      ; SSTACK: 9 bytes                                                                (STRING_FILL_BL)
                                      ;         X, Y and B are preserved                                               (STRING_FILL_BL)
00F246 0FF246 MACRO                                           STRING_CALL_BL  STRING_FILL_NB, 7                        (STRING_FILL_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; args:   1: non-blocking function                                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (STRING_FILL_BL/STRING_CALL_BL)
00F246 0FF246                         LOOP                    ;Wait until TX buffer accepts new data                   (STRING_FILL_BL/STRING_CALL_BL)
00F246 0FF246 MACRO                                           SCI_TX_READY_BL                                          (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
00F246 0FF246 MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F246 0FF246 MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F246 0FF246 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F249 0FF249 18 25 00 FC                                     BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F24D 0FF24D 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F250 0FF250 18 22 00 FB                                     BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F254 0FF254 -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F254 0FF254 -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F254 0FF254 16 F4 5D                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (STRING_FILL_BL/STRING_CALL_BL)
00F257 0FF257 MACRO                                           SSTACK_JOBSR    \1, \2                                   (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F257 0FF257 MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F257 0FF257 8F 08 11                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F25A 0FF25A 18 25 00 EB                                     BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F25E 0FF25E 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F261 0FF261 18 22 00 EA                                     BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F265 0FF265 -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F265 0FF265 -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F265 0FF265 16 F6 A9                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F268 0FF268 24 DC                                           BCC     LOOP            ;function unsuccessful           (STRING_FILL_BL/STRING_CALL_BL)
00F26A 0FF26A C6 08                                           LDAB    #8
00F26C 0FF26C MACRO                                           NUM_REVPRINT_BL
                                      ;#Print a reserse number digit - blocking                                        (NUM_REVPRINT_BL)
                                      ; args:   B:    base (2<=base<=16)                                               (NUM_REVPRINT_BL)
                                      ;         SP+0: MSB                                                              (NUM_REVPRINT_BL)
                                      ;         SP+1:  |                                                               (NUM_REVPRINT_BL)
                                      ;         SP+2:  |reverse                                                        (NUM_REVPRINT_BL)
                                      ;         SP+3:  |number                                                         (NUM_REVPRINT_BL)
                                      ;         SP+4:  |                                                               (NUM_REVPRINT_BL)
                                      ;         SP+5: LSB                                                              (NUM_REVPRINT_BL)
                                      ; result: SP+0: MSB                                                              (NUM_REVPRINT_BL)
                                      ;         SP+1:  |remaining                                                      (NUM_REVPRINT_BL)
                                      ;         SP+2:  | digits of                                                     (NUM_REVPRINT_BL)
                                      ;         SP+3:  |reverse                                                        (NUM_REVPRINT_BL)
                                      ;         SP+4:  |number                                                         (NUM_REVPRINT_BL)
                                      ;         SP+5: LSB                                                              (NUM_REVPRINT_BL)
                                      ;         C-flag: set if successful                                              (NUM_REVPRINT_BL)
                                      ; SSTACK: 8 bytes                                                                (NUM_REVPRINT_BL)
                                      ;         X, Y and D are preserved                                               (NUM_REVPRINT_BL)
00F26C 0FF26C MACRO                                           NUM_CALL_BL     NUM_REVPRINT_NB, 19                      (NUM_REVPRINT_BL)
                                      ;#Turn a non-blocking subroutine into a blocking subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; args:   1: non-blocking function                                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#macro NUM_MAKE_BL, 2                                                           (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       ;Call non-blocking subroutine as if it was blocking      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       NUM_CALL_BL     \1, \2                                   (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       ;Done                                                    (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       SSTACK_PREPULL  2                                        (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       RTS                                                      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#emac                                                                           (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; args:   1: non-blocking function                                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (NUM_REVPRINT_BL/NUM_CALL_BL)
00F26C 0FF26C                         LOOP                    ;Wait until TX buffer accepts new data                   (NUM_REVPRINT_BL/NUM_CALL_BL)
00F26C 0FF26C MACRO                                           SCI_TX_READY_BL                                          (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
00F26C 0FF26C MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F26C 0FF26C MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F26C 0FF26C 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F26F 0FF26F 18 25 00 D6                                     BLO     OF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F273 0FF273 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F276 0FF276 18 22 00 D5                                     BHI     UF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F27A 0FF27A -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F27A 0FF27A -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F27A 0FF27A 16 F4 5D                                        JOBSR   \1                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (NUM_REVPRINT_BL/NUM_CALL_BL)
00F27D 0FF27D MACRO                                           SSTACK_JOBSR    \1, \2                                   (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Check stack and call subroutine                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
00F27D 0FF27D MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F27D 0FF27D 8F 08 1D                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F280 0FF280 18 25 00 C5                                     BLO     OF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F284 0FF284 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F287 0FF287 18 22 00 C4                                     BHI     UF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F28B 0FF28B -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F28B 0FF28B -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F28B 0FF28B 16 F7 AF                                        JOBSR   \1                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
00F28E 0FF28E 24 DC                                           BCC     LOOP            ;function unsuccessful           (NUM_REVPRINT_BL/NUM_CALL_BL)
00F290 0FF290 MACRO                                           NUM_CLEAN_REVERSE
                                      ;#Clean-up stack space for reverse unsigned double word                          (NUM_CLEAN_REVERSE)
                                      ; args:   SP+0: MSB                                                              (NUM_CLEAN_REVERSE)
                                      ;         SP+1:  |                                                               (NUM_CLEAN_REVERSE)
                                      ;         SP+2:  |reverse                                                        (NUM_CLEAN_REVERSE)
                                      ;         SP+3:  |number                                                         (NUM_CLEAN_REVERSE)
                                      ;         SP+4:  |                                                               (NUM_CLEAN_REVERSE)
                                      ;         SP+5: LSB                                                              (NUM_CLEAN_REVERSE)
                                      ; result: none                                                                   (NUM_CLEAN_REVERSE)
                                      ; SSTACK: 18 bytes                                                               (NUM_CLEAN_REVERSE)
                                      ;         X, Y and B are preserved                                               (NUM_CLEAN_REVERSE)
00F290 0FF290 MACRO                                           SSTACK_PREPULL  6                                        (NUM_CLEAN_REVERSE)
                                      ;#Check stack before pull operation                                              (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; result: none                                                                   (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F290 0FF290 8F 08 0A                                        CPS     #SSTACK_TOP                                      (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F293 0FF293 18 25 00 B2                                     BLO     OF                                               (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F297 0FF297 8F 08 1F                                        CPS     #SSTACK_BOTTOM-\1                                (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F29A 0FF29A 18 22 00 B1                                     BHI     UF                                               (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F29E 0FF29E -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F29E 0FF29E -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F29E 0FF29E 1B 86                                           LEAS    6,SP                                             (NUM_CLEAN_REVERSE)
                                                              ;Print binary value (char in X)
00F2A0 0FF2A0 86 02                                           LDAA    #2
00F2A2 0FF2A2 C6 20                                           LDAB    #" "
00F2A4 0FF2A4 MACRO                                           STRING_FILL_BL
                                      ;#Print a number of filler characters - blocking                                 (STRING_FILL_BL)
                                      ; args:   A: number of characters to be printed                                  (STRING_FILL_BL)
                                      ;         B: filler character                                                    (STRING_FILL_BL)
                                      ; result: A: $00                                                                 (STRING_FILL_BL)
                                      ; SSTACK: 9 bytes                                                                (STRING_FILL_BL)
                                      ;         X, Y and B are preserved                                               (STRING_FILL_BL)
00F2A4 0FF2A4 MACRO                                           STRING_CALL_BL  STRING_FILL_NB, 7                        (STRING_FILL_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; args:   1: non-blocking function                                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (STRING_FILL_BL/STRING_CALL_BL)
00F2A4 0FF2A4                         LOOP                    ;Wait until TX buffer accepts new data                   (STRING_FILL_BL/STRING_CALL_BL)
00F2A4 0FF2A4 MACRO                                           SCI_TX_READY_BL                                          (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
00F2A4 0FF2A4 MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F2A4 0FF2A4 MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2A4 0FF2A4 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2A7 0FF2A7 18 25 00 9E                                     BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2AB 0FF2AB 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2AE 0FF2AE 18 22 00 9D                                     BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2B2 0FF2B2 -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2B2 0FF2B2 -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2B2 0FF2B2 16 F4 5D                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (STRING_FILL_BL/STRING_CALL_BL)
00F2B5 0FF2B5 MACRO                                           SSTACK_JOBSR    \1, \2                                   (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F2B5 0FF2B5 MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2B5 0FF2B5 8F 08 11                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2B8 0FF2B8 18 25 00 8D                                     BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2BC 0FF2BC 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2BF 0FF2BF 18 22 00 8C                                     BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2C3 0FF2C3 -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2C3 0FF2C3 -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2C3 0FF2C3 16 F6 A9                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F2C6 0FF2C6 24 DC                                           BCC     LOOP            ;function unsuccessful           (STRING_FILL_BL/STRING_CALL_BL)
00F2C8 0FF2C8 CD 00 00                                        LDY     #$0000
00F2CB 0FF2CB C6 02                                           LDAB    #2
00F2CD 0FF2CD MACRO                                           NUM_REVERSE
                                      ;############################################################################### (NUM_REVERSE)
                                      ;# Macros                                                                      # (NUM_REVERSE)
                                      ;############################################################################### (NUM_REVERSE)
                                      ;#Initialization                                                                 (NUM_REVERSE)
                                      ;#Reverse unsigned double word                                                   (NUM_REVERSE)
                                      ; args:   Y:X: unsigned double value                                             (NUM_REVERSE)
                                      ;         B:   base   (2<=base<=16)                                              (NUM_REVERSE)
                                      ; result: A:   number of digits                                                  (NUM_REVERSE)
                                      ;         SP+0: MSB                                                              (NUM_REVERSE)
                                      ;         SP+1:  |                                                               (NUM_REVERSE)
                                      ;         SP+2:  |reverse                                                        (NUM_REVERSE)
                                      ;         SP+3:  |number                                                         (NUM_REVERSE)
                                      ;         SP+4:  |                                                               (NUM_REVERSE)
                                      ;         SP+5: LSB                                                              (NUM_REVERSE)
                                      ; SSTACK: 18 bytes                                                               (NUM_REVERSE)
                                      ;         X, Y and B are preserved                                               (NUM_REVERSE)
00F2CD 0FF2CD MACRO                                           SSTACK_JOBSR    NUM_REVERSE, 18                          (NUM_REVERSE)
                                      ;#Check stack and call subroutine                                                (NUM_REVERSE/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVERSE/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVERSE/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVERSE/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVERSE/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVERSE/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVERSE/SSTACK_JOBSR)
00F2CD 0FF2CD MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVERSE/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2CD 0FF2CD 8F 08 1C                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2D0 0FF2D0 25 77                                           BLO     OF                                               (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2D2 0FF2D2 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2D5 0FF2D5 22 78                                           BHI     UF                                               (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2D7 0FF2D7 -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2D7 0FF2D7 -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVERSE/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2D7 0FF2D7 16 F7 22                                        JOBSR   \1                                               (NUM_REVERSE/SSTACK_JOBSR)
00F2DA 0FF2DA B7 76                                           TFR     SP, Y
00F2DC 0FF2DC 40                                              NEGA
00F2DD 0FF2DD 8B 08                                           ADDA    #8
00F2DF 0FF2DF C6 30                                           LDAB    #"0"
00F2E1 0FF2E1 MACRO                                           STRING_fill_BL
                                      ;#Print a number of filler characters - blocking                                 (STRING_FILL_BL)
                                      ; args:   A: number of characters to be printed                                  (STRING_FILL_BL)
                                      ;         B: filler character                                                    (STRING_FILL_BL)
                                      ; result: A: $00                                                                 (STRING_FILL_BL)
                                      ; SSTACK: 9 bytes                                                                (STRING_FILL_BL)
                                      ;         X, Y and B are preserved                                               (STRING_FILL_BL)
00F2E1 0FF2E1 MACRO                                           STRING_CALL_BL  STRING_FILL_NB, 7                        (STRING_FILL_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; args:   1: non-blocking function                                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (STRING_FILL_BL/STRING_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (STRING_FILL_BL/STRING_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (STRING_FILL_BL/STRING_CALL_BL)
00F2E1 0FF2E1                         LOOP                    ;Wait until TX buffer accepts new data                   (STRING_FILL_BL/STRING_CALL_BL)
00F2E1 0FF2E1 MACRO                                           SCI_TX_READY_BL                                          (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
00F2E1 0FF2E1 MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F2E1 0FF2E1 MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2E1 0FF2E1 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2E4 0FF2E4 25 63                                           BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2E6 0FF2E6 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2E9 0FF2E9 22 64                                           BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2EB 0FF2EB -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2EB 0FF2EB -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2EB 0FF2EB 16 F4 5D                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (STRING_FILL_BL/STRING_CALL_BL)
00F2EE 0FF2EE MACRO                                           SSTACK_JOBSR    \1, \2                                   (STRING_FILL_BL/STRING_CALL_BL)
                                      ;#Check stack and call subroutine                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F2EE 0FF2EE MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2EE 0FF2EE 8F 08 11                                        CPS     #SSTACK_TOP+\1                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2F1 0FF2F1 25 56                                           BLO     OF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2F3 0FF2F3 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2F6 0FF2F6 22 57                                           BHI     UF                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2F8 0FF2F8 -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2F8 0FF2F8 -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2F8 0FF2F8 16 F6 A9                                        JOBSR   \1                                               (STRING_FILL_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F2FB 0FF2FB 24 E4                                           BCC     LOOP            ;function unsuccessful           (STRING_FILL_BL/STRING_CALL_BL)
00F2FD 0FF2FD C6 02                                           LDAB    #2
00F2FF 0FF2FF MACRO                                           NUM_REVPRINT_BL
                                      ;#Print a reserse number digit - blocking                                        (NUM_REVPRINT_BL)
                                      ; args:   B:    base (2<=base<=16)                                               (NUM_REVPRINT_BL)
                                      ;         SP+0: MSB                                                              (NUM_REVPRINT_BL)
                                      ;         SP+1:  |                                                               (NUM_REVPRINT_BL)
                                      ;         SP+2:  |reverse                                                        (NUM_REVPRINT_BL)
                                      ;         SP+3:  |number                                                         (NUM_REVPRINT_BL)
                                      ;         SP+4:  |                                                               (NUM_REVPRINT_BL)
                                      ;         SP+5: LSB                                                              (NUM_REVPRINT_BL)
                                      ; result: SP+0: MSB                                                              (NUM_REVPRINT_BL)
                                      ;         SP+1:  |remaining                                                      (NUM_REVPRINT_BL)
                                      ;         SP+2:  | digits of                                                     (NUM_REVPRINT_BL)
                                      ;         SP+3:  |reverse                                                        (NUM_REVPRINT_BL)
                                      ;         SP+4:  |number                                                         (NUM_REVPRINT_BL)
                                      ;         SP+5: LSB                                                              (NUM_REVPRINT_BL)
                                      ;         C-flag: set if successful                                              (NUM_REVPRINT_BL)
                                      ; SSTACK: 8 bytes                                                                (NUM_REVPRINT_BL)
                                      ;         X, Y and D are preserved                                               (NUM_REVPRINT_BL)
00F2FF 0FF2FF MACRO                                           NUM_CALL_BL     NUM_REVPRINT_NB, 19                      (NUM_REVPRINT_BL)
                                      ;#Turn a non-blocking subroutine into a blocking subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; args:   1: non-blocking function                                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#macro NUM_MAKE_BL, 2                                                           (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       ;Call non-blocking subroutine as if it was blocking      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       NUM_CALL_BL     \1, \2                                   (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       ;Done                                                    (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       SSTACK_PREPULL  2                                        (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;                       RTS                                                      (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#emac                                                                           (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; args:   1: non-blocking function                                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (NUM_REVPRINT_BL/NUM_CALL_BL)
00F2FF 0FF2FF                         LOOP                    ;Wait until TX buffer accepts new data                   (NUM_REVPRINT_BL/NUM_CALL_BL)
00F2FF 0FF2FF MACRO                                           SCI_TX_READY_BL                                          (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
00F2FF 0FF2FF MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F2FF 0FF2FF MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F2FF 0FF2FF 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F302 0FF302 25 45                                           BLO     OF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F304 0FF304 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F307 0FF307 22 46                                           BHI     UF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F309 0FF309 -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F309 0FF309 -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F309 0FF309 16 F4 5D                                        JOBSR   \1                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (NUM_REVPRINT_BL/NUM_CALL_BL)
00F30C 0FF30C MACRO                                           SSTACK_JOBSR    \1, \2                                   (NUM_REVPRINT_BL/NUM_CALL_BL)
                                      ;#Check stack and call subroutine                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
00F30C 0FF30C MACRO                                           SSTACK_PREPUSH  \2                                       (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F30C 0FF30C 8F 08 1D                                        CPS     #SSTACK_TOP+\1                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F30F 0FF30F 25 38                                           BLO     OF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F311 0FF311 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F314 0FF314 22 39                                           BHI     UF                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F316 0FF316 -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F316 0FF316 -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F316 0FF316 16 F7 AF                                        JOBSR   \1                                               (NUM_REVPRINT_BL/NUM_CALL_BL/SSTACK_JOBSR)
00F319 0FF319 24 E4                                           BCC     LOOP            ;function unsuccessful           (NUM_REVPRINT_BL/NUM_CALL_BL)
00F31B 0FF31B MACRO                                           NUM_CLEAN_REVERSE
                                      ;#Clean-up stack space for reverse unsigned double word                          (NUM_CLEAN_REVERSE)
                                      ; args:   SP+0: MSB                                                              (NUM_CLEAN_REVERSE)
                                      ;         SP+1:  |                                                               (NUM_CLEAN_REVERSE)
                                      ;         SP+2:  |reverse                                                        (NUM_CLEAN_REVERSE)
                                      ;         SP+3:  |number                                                         (NUM_CLEAN_REVERSE)
                                      ;         SP+4:  |                                                               (NUM_CLEAN_REVERSE)
                                      ;         SP+5: LSB                                                              (NUM_CLEAN_REVERSE)
                                      ; result: none                                                                   (NUM_CLEAN_REVERSE)
                                      ; SSTACK: 18 bytes                                                               (NUM_CLEAN_REVERSE)
                                      ;         X, Y and B are preserved                                               (NUM_CLEAN_REVERSE)
00F31B 0FF31B MACRO                                           SSTACK_PREPULL  6                                        (NUM_CLEAN_REVERSE)
                                      ;#Check stack before pull operation                                              (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; args:   required stack content (bytes)                                         (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; result: none                                                                   (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ; SSTACK: none                                                                   (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
                                      ;         X, Y, and D are preserved                                              (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F31B 0FF31B 8F 08 0A                                        CPS     #SSTACK_TOP                                      (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F31E 0FF31E 25 29                                           BLO     OF                                               (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F320 0FF320 8F 08 1F                                        CPS     #SSTACK_BOTTOM-\1                                (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F323 0FF323 22 2A                                           BHI     UF                                               (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F325 0FF325 -> $F34F                UF                      EQU     SSTACK_UF                                        (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F325 0FF325 -> $F349                OF                      EQU     SSTACK_OF                                        (NUM_CLEAN_REVERSE/SSTACK_PREPULL)
00F325 0FF325 1B 86                                           LEAS    6,SP                                             (NUM_CLEAN_REVERSE)
                                                              ;Print new line
00F327 0FF327 CE F9 0F                                        LDX     #STRING_STR_NL
00F32A 0FF32A MACRO                                           STRING_PRINT_BL
                                      ;#Basic print function - blocking                                                (STRING_PRINT_BL)
                                      ; args:   X:      start of the string                                            (STRING_PRINT_BL)
                                      ; result: X;      points to the byte after the string                            (STRING_PRINT_BL)
                                      ; SSTACK: 10 bytes                                                               (STRING_PRINT_BL)
                                      ;         Y and D are preserved                                                  (STRING_PRINT_BL)
00F32A 0FF32A MACRO                                           STRING_CALL_BL  STRING_PRINT_NB, 8                       (STRING_PRINT_BL)
                                      ;#Run a non-blocking subroutine as if it was blocking                            (STRING_PRINT_BL/STRING_CALL_BL)
                                      ; args:   1: non-blocking function                                               (STRING_PRINT_BL/STRING_CALL_BL)
                                      ;         2: subroutine stack usage of non-blocking function (min. 4)            (STRING_PRINT_BL/STRING_CALL_BL)
                                      ; SSTACK: stack usage of non-blocking function + 2                               (STRING_PRINT_BL/STRING_CALL_BL)
                                      ;         rgister output of the non-blocking function is preserved               (STRING_PRINT_BL/STRING_CALL_BL)
00F32A 0FF32A                         LOOP                    ;Wait until TX buffer accepts new data                   (STRING_PRINT_BL/STRING_CALL_BL)
00F32A 0FF32A MACRO                                           SCI_TX_READY_BL                                          (STRING_PRINT_BL/STRING_CALL_BL)
                                      ;#Wait until TX queue can hold further data                                      (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; args:   none                                                                   (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; result: none                                                                   (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ; SSTACK: 6 bytes                                                                (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;         X, Y, and D are preserved                                              (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
00F32A 0FF32A MACRO                                           SSTACK_JOBSR    SCI_TX_READY_BL, 6                       (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL)
                                      ;#Check stack and call subroutine                                                (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
00F32A 0FF32A MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F32A 0FF32A 8F 08 10                                        CPS     #SSTACK_TOP+\1                                   (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F32D 0FF32D 25 1A                                           BLO     OF                                               (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F32F 0FF32F 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F332 0FF332 22 1B                                           BHI     UF                                               (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F334 0FF334 -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F334 0FF334 -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F334 0FF334 16 F4 5D                                        JOBSR   \1                                               (STRING_PRINT_BL/STRING_CALL_BL/SCI_TX_READY_BL/SSTACK_JOBSR)
                                                              ;Call non-blocking function                              (STRING_PRINT_BL/STRING_CALL_BL)
00F337 0FF337 MACRO                                           SSTACK_JOBSR    \1, \2                                   (STRING_PRINT_BL/STRING_CALL_BL)
                                      ;#Check stack and call subroutine                                                (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   required stack capacity (bytes)                                        (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; result: 1: subroutine                                                          (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         2: required stack space                                                (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; SSTACK: arg 2                                                                  (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;         register content may be changed by the subroutine                      (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ; args:   1: Number of bytes to be allocated (args + local vars)                 (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F337 0FF337 MACRO                                           SSTACK_PREPUSH  \2                                       (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
                                      ;############################################################################### (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;# Macros                                                                      # (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;############################################################################### (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Initialization (initialization done by ISTACK module)                          (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;#Check stack before push operation                                              (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; args:   required stack capacity (bytes)                                        (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; result: none                                                                   (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ; SSTACK: none                                                                   (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
                                      ;         X, Y, and D are preserved                                              (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F337 0FF337 8F 08 12                                        CPS     #SSTACK_TOP+\1                                   (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F33A 0FF33A 25 0D                                           BLO     OF                                               (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F33C 0FF33C 8F 08 25                                        CPS     #SSTACK_BOTTOM                                   (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F33F 0FF33F 22 0E                                           BHI     UF                                               (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F341 0FF341 -> $F34F                UF                      EQU     SSTACK_UF                                        (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F341 0FF341 -> $F349                OF                      EQU     SSTACK_OF                                        (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR/SSTACK_PREPUSH)
00F341 0FF341 16 F6 72                                        JOBSR   \1                                               (STRING_PRINT_BL/STRING_CALL_BL/SSTACK_JOBSR)
00F344 0FF344 24 E4                                           BCC     LOOP            ;function unsuccessful           (STRING_PRINT_BL/STRING_CALL_BL)
00F346 0FF346 06 F0 DE                                        JOB     DEMO_LOOP
00F349 0FF349 -> $F349                DEMO_CODE_END           EQU     *
00F349 0FF349 -> $FF349               DEMO_CODE_END_LIN       EQU     @
                                      ;###############################################################################
                                      ;# Tables                                                                      #
                                      ;###############################################################################
00F822 0FF822                                                 ORG     DEMO_TABS_START, DEMO_TABS_START_LIN
00F822 0FF822 54 68 69 73 20 69 73 20 DEMO_WELCOME            FCC     "This is the S12CBase Demo for the SIMHC12 simulator!"
              74 68 65 20 53 31 32 43 
              42 61 73 65 20 44 65 6D 
              6F 20 66 6F 72 20 74 68 
              65 20 53 49 4D 48 43 31 
              32 20 73 69 6D 75 6C 61 
              74 6F 72 21             
00F856 0FF856 MACRO                                           STRING_NL_NONTERM
                                      ;#Non-terminated line break                                                      (STRING_NL_NONTERM)
00F856 0FF856 0D                                              DB      STRING_SYM_CR                                    (STRING_NL_NONTERM)
00F857 0FF857 0A                                              DB      STRING_SYM_LF                                    (STRING_NL_NONTERM)
00F858 0FF858 MACRO                                           STRING_NL_NONTERM
                                      ;#Non-terminated line break                                                      (STRING_NL_NONTERM)
00F858 0FF858 0D                                              DB      STRING_SYM_CR                                    (STRING_NL_NONTERM)
00F859 0FF859 0A                                              DB      STRING_SYM_LF                                    (STRING_NL_NONTERM)
00F85A 0FF85A 41 53 43 49 49 20 20 48                         FCC     "ASCII  Hex  Dec  Oct       Bin"
              65 78 20 20 44 65 63 20 
              20 4F 63 74 20 20 20 20 
              20 20 20 42 69 6E       
00F878 0FF878 MACRO                                           STRING_NL_NONTERM
                                      ;#Non-terminated line break                                                      (STRING_NL_NONTERM)
00F878 0FF878 0D                                              DB      STRING_SYM_CR                                    (STRING_NL_NONTERM)
00F879 0FF879 0A                                              DB      STRING_SYM_LF                                    (STRING_NL_NONTERM)
00F87A 0FF87A 2D 2D 2D 2D 2D 2D 2D 2D                         FCC     "------------------------------"
              2D 2D 2D 2D 2D 2D 2D 2D 
              2D 2D 2D 2D 2D 2D 2D 2D 
              2D 2D 2D 2D 2D 2D       
00F898 0FF898 MACRO                                           STRING_NL_TERM
                                      ;#Terminated line break                                                          (STRING_NL_TERM)
00F898 0FF898 0D                                              DB      STRING_SYM_CR                                    (STRING_NL_TERM)
00F899 0FF899 8A                                              DB      (STRING_SYM_LF|$80)                              (STRING_NL_TERM)
00F89A 0FF89A -> $F89A                DEMO_TABS_END           EQU     *
00F89A 0FF89A -> $FF89A               DEMO_TABS_END_LIN       EQU     @
